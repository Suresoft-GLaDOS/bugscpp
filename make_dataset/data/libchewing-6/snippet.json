[
    {
        "name": "src.char.CompUint16#51",
        "src_path": "src/char.c",
        "class_name": "src.char",
        "signature": "src.char.CompUint16( const uint16_t *pa, const uint16_t *pb )",
        "snippet": "static int CompUint16( const uint16_t *pa, const uint16_t *pb )\n{\n\treturn ( (*pa) - (*pb) );\n}",
        "begin_line": 51,
        "end_line": 54,
        "is_bug": false
    },
    {
        "name": "src.char.GetCharFirst#198",
        "src_path": "src/char.c",
        "class_name": "src.char",
        "signature": "src.char.GetCharFirst( ChewingData *pgdata, Word *wrd_ptr, uint16_t phoneid )",
        "snippet": "int GetCharFirst( ChewingData *pgdata, Word *wrd_ptr, uint16_t phoneid )\n{\n\tuint16_t *pinx;\n\n\tpinx = (uint16_t *) bsearch(\n\t\t&phoneid, pgdata->static_data.arrPhone, pgdata->static_data.phone_num,\n\t\tsizeof( uint16_t ), (CompFuncType) CompUint16 );\n\tif ( ! pinx )\n\t\treturn 0;\n\n#ifndef USE_BINARY_DATA\n\tfseek( pgdata->static_data.charfile, pgdata->static_data.char_begin[ pinx - pgdata->static_data.arrPhone ], SEEK_SET );\n#else\n\tpgdata->static_data.char_cur_pos = (unsigned char*)pgdata->static_data.char_ + pgdata->static_data.char_begin[ pinx - pgdata->static_data.arrPhone ];\n#endif\n\tpgdata->static_data.char_end_pos = pgdata->static_data.char_begin[ pinx - pgdata->static_data.arrPhone + 1 ];\n\tStr2Word( pgdata, wrd_ptr );\n\treturn 1;\n}",
        "begin_line": 198,
        "end_line": 216,
        "is_bug": false
    },
    {
        "name": "src.char.GetCharNext#218",
        "src_path": "src/char.c",
        "class_name": "src.char",
        "signature": "src.char.GetCharNext( ChewingData *pgdata, Word *wrd_ptr )",
        "snippet": "int GetCharNext( ChewingData *pgdata, Word *wrd_ptr )\n{\n#ifndef USE_BINARY_DATA\n\tif ( ftell( pgdata->static_data.charfile ) >= pgdata->static_data.char_end_pos )\n\t\treturn 0;\n#else\n\tif ( (unsigned char*)pgdata->static_data.char_cur_pos >= (unsigned char*)pgdata->static_data.char_ + pgdata->static_data.char_end_pos )\n\t\treturn 0;\n#endif\n\tStr2Word( pgdata, wrd_ptr );\n\treturn 1;\n}",
        "begin_line": 218,
        "end_line": 229,
        "is_bug": false
    },
    {
        "name": "src.char.InitChar#78",
        "src_path": "src/char.c",
        "class_name": "src.char",
        "signature": "src.char.InitChar( ChewingData *pgdata, const char * prefix )",
        "snippet": "int InitChar( ChewingData *pgdata , const char * prefix )\n{\n#ifdef USE_BINARY_DATA\n\tchar filename[ PATH_MAX ];\n\tsize_t len;\n\tsize_t offset;\n\tsize_t file_size;\n\tsize_t csize;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, CHAR_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tplat_mmap_set_invalid( &pgdata->static_data.char_mmap );\n\tfile_size = plat_mmap_create( &pgdata->static_data.char_mmap, filename, FLAG_ATTRIBUTE_READ );\n\tif ( file_size <= 0 )\n\t\treturn -1;\n\n\tcsize = file_size;\n\toffset = 0;\n\tpgdata->static_data.char_ = plat_mmap_set_view( &pgdata->static_data.char_mmap, &offset, &csize );\n\tif ( !pgdata->static_data.char_ )\n\t\treturn -1;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, CHAR_INDEX_BEGIN_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tplat_mmap_set_invalid( &pgdata->static_data.char_begin_mmap );\n\tfile_size = plat_mmap_create( &pgdata->static_data.char_begin_mmap, filename, FLAG_ATTRIBUTE_READ );\n\tif ( file_size <= 0 )\n\t\treturn -1;\n\n\tpgdata->static_data.phone_num = file_size / sizeof( int );\n\n\toffset = 0;\n\tcsize = file_size;\n\tpgdata->static_data.char_begin = plat_mmap_set_view( &pgdata->static_data.char_begin_mmap, &offset, &csize );\n\tif ( !pgdata->static_data.char_begin )\n\t\treturn -1;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, CHAR_INDEX_PHONE_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tplat_mmap_set_invalid( &pgdata->static_data.char_phone_mmap );\n\tfile_size = plat_mmap_create( &pgdata->static_data.char_phone_mmap, filename, FLAG_ATTRIBUTE_READ );\n\tif ( file_size <= 0 )\n\t\treturn -1;\n\n\tif ( pgdata->static_data.phone_num != file_size / sizeof( uint16_t ))\n\t\treturn -1;\n\n\toffset = 0;\n\tcsize = file_size;\n\tpgdata->static_data.arrPhone = plat_mmap_set_view( &pgdata->static_data.char_phone_mmap, &offset, &csize );\n\tif ( !pgdata->static_data.arrPhone )\n\t\treturn -1;\n\n\treturn 0;\n#else\n\tchar filename[ PATH_MAX ];\n\tint len;\n\tint i;\n\tFILE *indexfile = NULL;\n\n\tpgdata->static_data.phone_num = PHONE_NUM;\n\n\tpgdata->static_data.arrPhone = ALC( uint16_t, pgdata->static_data.phone_num );\n\tif ( !pgdata->static_data.arrPhone )\n\t    return -1;\n\n\tpgdata->static_data.char_begin = ALC( int, pgdata->static_data.phone_num );\n\tif ( !pgdata->static_data.char_begin )\n\t    return -1;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, CHAR_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tpgdata->static_data.charfile = fopen( filename, \"r\" );\n\tif ( !pgdata->static_data.charfile )\n\t\treturn -1;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, CHAR_INDEX_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tindexfile = fopen( filename, \"r\" );\n\tif ( !indexfile )\n\t\treturn -1;\n\n\tfor ( i = 0; i < pgdata->static_data.phone_num; ++i )\n\t\tfscanf( indexfile, \"%hu %d\", &pgdata->static_data.arrPhone[i], &pgdata->static_data.char_begin[i] );\n\n\tfclose( indexfile );\n\treturn 0;\n#endif\n}",
        "begin_line": 78,
        "end_line": 176,
        "is_bug": false
    },
    {
        "name": "src.char.Str2Word#178",
        "src_path": "src/char.c",
        "class_name": "src.char",
        "signature": "src.char.Str2Word( ChewingData *pgdata, Word *wrd_ptr )",
        "snippet": "static void Str2Word( ChewingData *pgdata, Word *wrd_ptr )\n{\n#ifndef USE_BINARY_DATA\n\tchar buf[ 1000 ];\n\tuint16_t sh;\n\n\tfgettab( buf, 1000, pgdata->static_data.charfile );\n\t/* only read 6 bytes to wrd_ptr->word avoid buffer overflow */\n\tsscanf( buf, \"%hu %6[^ ]\", &sh, wrd_ptr->word );\n\tassert( wrd_ptr->word[0] != '\\0' );\n#else\n\tunsigned char size;\n\tsize = *(unsigned char *) pgdata->static_data.char_cur_pos;\n\tpgdata->static_data.char_cur_pos = (unsigned char*) pgdata->static_data.char_cur_pos + sizeof(unsigned char);\n\tmemcpy( wrd_ptr->word, pgdata->static_data.char_cur_pos, size );\n\tpgdata->static_data.char_cur_pos = (unsigned char*) pgdata->static_data.char_cur_pos + size;\n\twrd_ptr->word[ size ] = '\\0';\n#endif\n}",
        "begin_line": 178,
        "end_line": 196,
        "is_bug": false
    },
    {
        "name": "src.char.TerminateChar#56",
        "src_path": "src/char.c",
        "class_name": "src.char",
        "signature": "src.char.TerminateChar( ChewingData *pgdata )",
        "snippet": "void TerminateChar( ChewingData *pgdata )\n{\n#ifdef USE_BINARY_DATA\n\tpgdata->static_data.arrPhone = NULL;\n\tplat_mmap_close( &pgdata->static_data.char_phone_mmap );\n\n\tpgdata->static_data.char_begin = NULL;\n\tplat_mmap_close( &pgdata->static_data.char_begin_mmap );\n\n\tpgdata->static_data.char_ = NULL;\n\tplat_mmap_close( &pgdata->static_data.char_mmap );\n\n\tpgdata->static_data.phone_num = 0;\n#else\n\tif ( pgdata->static_data.charfile )\n\t\tfclose( pgdata->static_data.charfile );\n\tfree( pgdata->static_data.char_begin );\n\tfree( pgdata->static_data.arrPhone );\n\tpgdata->static_data.phone_num = 0;\n#endif\n}",
        "begin_line": 56,
        "end_line": 76,
        "is_bug": false
    },
    {
        "name": "src.chewingio.NullLogger#131",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.NullLogger( void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)",
        "snippet": "static void NullLogger( void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)\n{\n}",
        "begin_line": 131,
        "end_line": 133,
        "is_bug": false
    },
    {
        "name": "src.chewingio.allocate_ChewingData#135",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.allocate_ChewingData()",
        "snippet": "static ChewingData * allocate_ChewingData()\n{\n\tstatic const int DEFAULT_SELKEY[] = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };\n\n\tChewingData *data = ALC( ChewingData, 1 );\n\tif ( data ) {\n\t\tdata->config.candPerPage = MAX_SELKEY;\n\t\tdata->config.maxChiSymbolLen = MAX_CHI_SYMBOL_LEN;\n\t\tdata->logger = NullLogger;\n\t\tmemcpy( data->config.selKey, DEFAULT_SELKEY, sizeof( data->config.selKey ) );\n\t}\n\n\treturn data;\n}",
        "begin_line": 135,
        "end_line": 148,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chooseCandidate#104",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chooseCandidate( ChewingContext *ctx, int toSelect, int key_buf_cursor )",
        "snippet": "static void chooseCandidate( ChewingContext *ctx, int toSelect, int key_buf_cursor )\n{\n\tChewingData *pgdata = ctx->data;\n\tif ( toSelect ) {\n\t\tif ( ! pgdata->bSelect ) {\n\t\t\tChoiceFirstAvail( pgdata );\n\t\t} else {\n\t\t\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\t\t\tint avail_willbe = (pgdata->availInfo.currentAvail > 0) ?\n\t\t\t\t\tpgdata->availInfo.currentAvail - 1 :\n\t\t\t\t\tpgdata->availInfo.nAvail - 1;\n\t\t\t\tpgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor -\n\t\t\t\t\tpgdata->availInfo.avail[ avail_willbe ].len;\n\t\t\t\tif ( chewing_buffer_Len( ctx ) >\n\t\t\t\t\t\tpgdata->choiceInfo.oldChiSymbolCursor ) {\n\t\t\t\t\tpgdata->chiSymbolCursor++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tChoiceNextAvail( pgdata );\n\t\t}\n\t} else if ( pgdata->symbolKeyBuf[ key_buf_cursor ] ) {\n\t\t/* Open Symbol Choice List */\n\t\tif ( pgdata->choiceInfo.isSymbol == WORD_CHOICE )\n\t\t\tOpenSymbolChoice( pgdata );\n\t}\n}",
        "begin_line": 104,
        "end_line": 129,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.AddChi#650",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.AddChi( uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata )",
        "snippet": "int AddChi( uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata )\n{\n\tint i;\n\tint cursor = PhoneSeqCursor( pgdata );\n\n\t/* shift the selectInterval */\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( pgdata->selectInterval[ i ].from >= cursor ) {\n\t\t\tpgdata->selectInterval[ i ].from++;\n\t\t\tpgdata->selectInterval[ i ].to++;\n\t\t}\n\t}\n\n\t/* shift the Brkpt */\n\tassert( pgdata->nPhoneSeq >= cursor );\n\tmemmove(\n\t\t&( pgdata->bUserArrBrkpt[ cursor + 2 ] ),\n\t\t&( pgdata->bUserArrBrkpt[ cursor + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursor ) );\n\tmemmove(\n\t\t&( pgdata->bUserArrCnnct[ cursor + 2 ] ),\n\t\t&( pgdata->bUserArrCnnct[ cursor + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursor ) );\n\n\t/* add to phoneSeq */\n\tmemmove(\n\t\t&( pgdata->phoneSeq[ cursor + 1 ] ),\n\t\t&( pgdata->phoneSeq[ cursor ] ) ,\n\t\tsizeof( uint16_t ) * ( pgdata->nPhoneSeq - cursor ) );\n\tpgdata->phoneSeq[ cursor ] = phone;\n\tmemmove(\n\t\t&( pgdata->phoneSeqAlt[ cursor + 1 ] ),\n\t\t&( pgdata->phoneSeqAlt[ cursor ] ) ,\n\t\tsizeof( uint16_t ) * ( pgdata->nPhoneSeq - cursor ) );\n\tpgdata->phoneSeqAlt[ cursor ] = phoneAlt;\n\tpgdata->nPhoneSeq ++;\n\n\t/* add to chiSymbolBuf */\n\tassert( pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor );\n\tmemmove(\n\t\t&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor + 1 ] ),\n\t\t&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ] ) ,\n\t\tsizeof( wch_t ) * ( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\t/* \"0\" means Chinese word */\n\tpgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].wch = 0;\n\tpgdata->chiSymbolBufLen++;\n\tpgdata->chiSymbolCursor++;\n\n\treturn 0;\n}",
        "begin_line": 650,
        "end_line": 699,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.AddSelect#966",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.AddSelect( ChewingData *pgdata, int sel_i )",
        "snippet": "int AddSelect( ChewingData *pgdata, int sel_i )\n{\n\tint length, nSelect, cursor;\n\n\t/* save the typing time */\n\tlength = pgdata->availInfo.avail[ pgdata->availInfo.currentAvail ].len;\n\tnSelect = pgdata->nSelect;\n\n\t/* change \"selectStr\" , \"selectInterval\" , and \"nSelect\" of ChewingData */\n\tueStrNCpy( pgdata->selectStr[ nSelect ],\n\t\t\tpgdata->choiceInfo.totalChoiceStr[ sel_i ],\n\t\t\tlength, 1 );\n\tcursor = PhoneSeqCursor( pgdata );\n\tpgdata->selectInterval[ nSelect ].from = cursor;\n\tpgdata->selectInterval[ nSelect ].to = cursor + length;\n\tpgdata->nSelect++;\n\treturn 0;\n}",
        "begin_line": 966,
        "end_line": 983,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.AutoLearnPhrase#609",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.AutoLearnPhrase( ChewingData *pgdata )",
        "snippet": "void AutoLearnPhrase( ChewingData *pgdata )\n{\n\tuint16_t bufPhoneSeq[ MAX_PHONE_SEQ_LEN + 1 ];\n\tchar bufWordSeq[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ];\n\tint i, from, len;\n\tint prev_pos = 0;\n\tint pending = 0;\n\n\tfor ( i = 0; i < pgdata->nPrefer; i++ ) {\n\t\tfrom = pgdata->preferInterval[ i ].from;\n\t\tlen = pgdata->preferInterval[i].to - from;\n\t\tif ( len == 1 && ! ChewingIsBreakPoint( from, pgdata ) ) {\n\t\t\tmemcpy( bufPhoneSeq + prev_pos, &pgdata->phoneSeq[ from ], sizeof( uint16_t ) * len );\n\t\t\tbufPhoneSeq[ prev_pos + len ] = (uint16_t) 0;\n\t\t\tueStrNCpy( ueStrSeek( bufWordSeq, prev_pos ),\n\t\t\t\t\tueStrSeek( (char *) &pgdata->phrOut.chiBuf, from ),\n\t\t\t\t\tlen, 1);\n\t\t\tprev_pos += len;\n\t\t\tpending = 1;\n\t\t}\n\t\telse {\n\t\t\tif ( pending ) {\n\t\t\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\t\t\tprev_pos = 0;\n\t\t\t\tpending = 0;\n\t\t\t}\n\t\t\tmemcpy( bufPhoneSeq, &pgdata->phoneSeq[ from ], sizeof( uint16_t ) * len );\n\t\t\tbufPhoneSeq[ len ] = (uint16_t) 0;\n\t\t\tueStrNCpy( bufWordSeq,\n\t\t\t\t\tueStrSeek( (char *) &pgdata->phrOut.chiBuf, from ),\n\t\t\t\t\tlen, 1);\n\t\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\t}\n\t}\n\tif ( pending ) {\n\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\tprev_pos = 0;\n\t\tpending = 0;\n\t}\n}",
        "begin_line": 609,
        "end_line": 648,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CallPhrasing#746",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CallPhrasing( ChewingData *pgdata )",
        "snippet": "int CallPhrasing( ChewingData *pgdata )\n{\n\t/* set \"bSymbolArrBrkpt\" && \"bArrBrkpt\" */\n\tint i, ch_count = 0;\n\n\tmemcpy(\n\t\tpgdata->bArrBrkpt,\n\t\tpgdata->bUserArrBrkpt,\n\t\t(MAX_PHONE_SEQ_LEN + 1) * sizeof( int ) );\n\tmemset(\n\t\tpgdata->bSymbolArrBrkpt, 0,\n\t\t(MAX_PHONE_SEQ_LEN + 1) * sizeof( int ) );\n\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) )\n\t\t\tch_count++;\n\t\telse {\n\t\t\tpgdata->bArrBrkpt[ ch_count ] = 1;\n\t\t\tpgdata->bSymbolArrBrkpt[ ch_count ] = 1;\n\t\t}\n\t}\n\n\t/* kill select interval */\n\tfor ( i = 0; i < pgdata->nPhoneSeq; i++ ) {\n\t\tif ( pgdata->bArrBrkpt[ i ] ) {\n\t\t\tChewingKillSelectIntervalAcross( i, pgdata );\n\t\t}\n\t}\n\n\tShowChewingData(pgdata);\n\n\t/* then phrasing */\n\tPhrasing( pgdata );\n\n\t/* and then make prefer interval */\n\tMakePreferInterval( pgdata );\n\n\treturn 0;\n}",
        "begin_line": 746,
        "end_line": 784,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingIsBreakPoint#564",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingIsBreakPoint( int cursor, ChewingData *pgdata )",
        "snippet": "static int ChewingIsBreakPoint( int cursor, ChewingData *pgdata )\n{\n\tstatic const char * const break_word[] = {\n\t\t\"\\xE6\\x98\\xAF\", \"\\xE7\\x9A\\x84\", \"\\xE4\\xBA\\x86\", \"\\xE4\\xB8\\x8D\",\n\t\t/* \u662f              \u7684              \u4e86              \u4e0d */\n\t\t\"\\xE4\\xB9\\x9F\", \"\\xE8\\x80\\x8C\", \"\\xE4\\xBD\\xA0\", \"\\xE6\\x88\\x91\",\n\t\t/* \u4e5f              \u800c              \u4f60              \u6211 */\n\t\t\"\\xE4\\xBB\\x96\", \"\\xE8\\x88\\x87\", \"\\xE5\\xAE\\x83\", \"\\xE5\\xA5\\xB9\",\n\t\t/* \u4ed6              \u8207              \u5b83              \u5979 */\n\t\t\"\\xE5\\x85\\xB6\", \"\\xE5\\xB0\\xB1\", \"\\xE5\\x92\\x8C\", \"\\xE6\\x88\\x96\",\n\t\t/* \u5176              \u5c31              \u548c              \u6216 */\n\t\t\"\\xE5\\x80\\x91\", \"\\xE6\\x80\\xA7\", \"\\xE5\\x93\\xA1\", \"\\xE5\\xAD\\x90\",\n\t\t/* \u5011              \u6027              \u54e1              \u5b50 */\n\t\t\"\\xE4\\xB8\\x8A\", \"\\xE4\\xB8\\x8B\", \"\\xE4\\xB8\\xAD\", \"\\xE5\\x85\\xA7\",\n\t\t/* \u4e0a              \u4e0b              \u4e2d              \u5167 */\n\t\t\"\\xE5\\xA4\\x96\", \"\\xE5\\x8C\\x96\", \"\\xE8\\x80\\x85\", \"\\xE5\\xAE\\xB6\",\n\t\t/* \u5916              \u5316              \u8005              \u5bb6 */\n\t\t\"\\xE5\\x85\\x92\", \"\\xE5\\xB9\\xB4\", \"\\xE6\\x9C\\x88\", \"\\xE6\\x97\\xA5\",\n\t\t/* \u5152              \u5e74              \u6708              \u65e5 */\n\t\t\"\\xE6\\x99\\x82\", \"\\xE5\\x88\\x86\", \"\\xE7\\xA7\\x92\", \"\\xE8\\xA1\\x97\",\n\t\t/* \u6642              \u5206              \u79d2              \u8857 */\n\t\t\"\\xE8\\xB7\\xAF\", \"\\xE6\\x9D\\x91\",\n\t\t/* \u8def              \u6751 */\n\t\t\"\\xE5\\x9C\\xA8\",\n\t\t/* \u5728 */\n\t};\n\tchar buf[ MAX_UTF8_SIZE + 1 ];\n\tint i = 0, symbols = 0;\n\tfor ( i = 0; i < cursor; i++ )\n\t\tif ( ! ChewingIsChiAt ( i + symbols, pgdata ) )\n\t\t\tsymbols++;\n\tif ( ! ChewingIsChiAt( i + symbols, pgdata ) )\n\t\treturn 1;\n\telse {\n\t\tueStrNCpy( buf,\n\t\t\t\tueStrSeek( (char *) &pgdata->phrOut.chiBuf, cursor ),\n\t\t\t\t1, 1 );\n\t\tfor ( i = 0; (size_t) i < ARRAY_SIZE( break_word ); i++ ) {\n\t\t\tif ( ! strcmp ( buf, break_word[ i ] ) )\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid AutoLearnPhrase( ChewingData *pgdata )\n{\n\tuint16_t bufPhoneSeq[ MAX_PHO",
        "begin_line": 564,
        "end_line": 607,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingIsChiAt#1013",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingIsChiAt( int chiSymbolCursor, ChewingData *pgdata )",
        "snippet": "int ChewingIsChiAt( int chiSymbolCursor, ChewingData *pgdata )\n{\n\t/* wch == 0 means Chinese */\n\treturn (\n\t\t( chiSymbolCursor < pgdata->chiSymbolBufLen ) &&\n\t\t( 0 <= chiSymbolCursor ) &&\n\t\t(pgdata->chiSymbolBuf[ chiSymbolCursor ].wch == 0 ) );\n}",
        "begin_line": 1013,
        "end_line": 1020,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingIsEntering#124",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingIsEntering( ChewingData *pgdata )",
        "snippet": "int ChewingIsEntering( ChewingData *pgdata )\n{\n\tif ( pgdata->choiceInfo.isSymbol != WORD_CHOICE )\n\t\treturn 1;\n\treturn (\n\t\tpgdata->chiSymbolBufLen != 0 ||\n\t\tZuinIsEntering( &( pgdata->zuinData ) ) );\n}",
        "begin_line": 124,
        "end_line": 131,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingKillChar#1071",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingKillChar( \t\tChewingData *pgdata, int chiSymbolCursorToKill, int minus )",
        "snippet": "int ChewingKillChar(\n\t\tChewingData *pgdata,\n\t\tint chiSymbolCursorToKill,\n\t\tint minus )\n{\n\tint tmp, cursorToKill;\n\ttmp = pgdata->chiSymbolCursor;\n\tpgdata->chiSymbolCursor = chiSymbolCursorToKill;\n\tcursorToKill = PhoneSeqCursor( pgdata );\n\tpgdata->chiSymbolCursor = tmp;\n\tif ( ChewingIsChiAt( chiSymbolCursorToKill, pgdata ) ) {\n\t\tKillCharInSelectIntervalAndBrkpt(pgdata, cursorToKill);\n\t\tassert( pgdata->nPhoneSeq - cursorToKill - 1 >= 0 );\n\t\tmemmove(\n\t\t\t&( pgdata->phoneSeq[ cursorToKill ] ),\n\t\t\t&(pgdata->phoneSeq[ cursorToKill + 1 ] ),\n\t\t\t(pgdata->nPhoneSeq - cursorToKill - 1) * sizeof( uint16_t ) );\n\t\tpgdata->nPhoneSeq--;\n\t}\n\tpgdata->symbolKeyBuf[ chiSymbolCursorToKill ] = 0;\n\tassert( pgdata->chiSymbolBufLen - chiSymbolCursorToKill );\n\tmemmove(\n\t\t& pgdata->chiSymbolBuf[ chiSymbolCursorToKill ],\n\t\t& pgdata->chiSymbolBuf[ chiSymbolCursorToKill + 1 ],\n\t\t(pgdata->chiSymbolBufLen - chiSymbolCursorToKill) * sizeof( wch_t ) );\n\tpgdata->chiSymbolBufLen--;\n\tpgdata->chiSymbolCursor -= minus;\n\tif (pgdata->chiSymbolCursor < 0)\n\t\tpgdata->chiSymbolCursor = 0;\n\treturn 0;\n}",
        "begin_line": 1071,
        "end_line": 1101,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingKillSelectIntervalAcross#1030",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingKillSelectIntervalAcross( int cursor, ChewingData *pgdata )",
        "snippet": "static int ChewingKillSelectIntervalAcross( int cursor, ChewingData *pgdata )\n{\n\tint i;\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( pgdata->selectInterval[ i ].from < cursor &&\n\t\t\tpgdata->selectInterval[ i ].to > cursor ) {\n\t\t\tRemoveSelectElement( i, pgdata );\n\t\t\ti--;\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 1030,
        "end_line": 1041,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CleanAllBuf#513",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CleanAllBuf( ChewingData *pgdata )",
        "snippet": "void CleanAllBuf( ChewingData *pgdata )\n{\n\t/* 1 */\n\tpgdata->nPhoneSeq = 0 ;\n\tmemset( pgdata->phoneSeq, 0, sizeof( pgdata->phoneSeq ) );\n\t/* 2 */\n\tpgdata->chiSymbolBufLen = 0;\n\tmemset( pgdata->chiSymbolBuf, 0, sizeof( pgdata->chiSymbolBuf ) );\n\t/* 3 */\n\tmemset( pgdata->bUserArrBrkpt, 0, sizeof( pgdata->bUserArrBrkpt ) );\n\t/* 4 */\n\tpgdata->nSelect = 0;\n\t/* 5 */\n\tpgdata->chiSymbolCursor = 0;\n\t/* 6 */\n\tmemset( pgdata->bUserArrCnnct, 0, sizeof( pgdata->bUserArrCnnct ) );\n\n\tpgdata->phrOut.nNumCut = 0;\n\n\tmemset( pgdata->symbolKeyBuf, 0, sizeof( pgdata->symbolKeyBuf ) );\n\n\tpgdata->nPrefer = 0;\n}",
        "begin_line": 513,
        "end_line": 535,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CountReleaseNum#474",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CountReleaseNum( ChewingData *pgdata )",
        "snippet": "static int CountReleaseNum( ChewingData *pgdata )\n{\n\tint remain, i;\n\n\tremain = pgdata->config.maxChiSymbolLen - pgdata->chiSymbolBufLen;\n\tif ( remain >= 0 )\n\t\treturn 0;\n\n\tqsort(\n\t\tpgdata->preferInterval,\n\t\tpgdata->nPrefer,\n\t\tsizeof( IntervalType ),\n\t\t(CompFuncType) CompInterval );\n\n\tif ( ! ChewingIsChiAt( 0, pgdata ) ) {\n\t\tfor ( i = 0; i < pgdata->chiSymbolCursor; ++i ) {\n\t\t\tif ( ChewingIsChiAt( i, pgdata ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n\n\ti = FindIntervalFrom( 0, pgdata->preferInterval, pgdata->nPrefer );\n\tif ( i >= 0 ) {\n\t\treturn ( pgdata->preferInterval[ i ].to - pgdata->preferInterval[ i ].from );\n\t}\n\n\treturn 1;\n}",
        "begin_line": 474,
        "end_line": 503,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CountSelKeyNum#985",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CountSelKeyNum( int key, ChewingData *pgdata ) \t/* return value starts from 0.  If less than zero : error key */",
        "snippet": "int CountSelKeyNum( int key, ChewingData *pgdata )\n\t/* return value starts from 0.  If less than zero : error key */\n{\n\tint i;\n\n\tfor ( i = 0; i < MAX_SELKEY; i++ )\n\t\tif ( pgdata->config.selKey[ i ] == key )\n\t\t\treturn i;\n\treturn -1;\n}",
        "begin_line": 985,
        "end_line": 994,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CountSymbols#996",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CountSymbols( ChewingData *pgdata, int to )",
        "snippet": "int CountSymbols( ChewingData *pgdata, int to )\n{\n\tint chi;\n\tint i;\n\tfor ( chi = i = 0; i < to; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) )\n\t\t\tchi++;\n\t}\n\treturn to - chi;\n}",
        "begin_line": 996,
        "end_line": 1005,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.FindEasySymbolIndex#64",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.FindEasySymbolIndex( char ch )",
        "snippet": "static int FindEasySymbolIndex( char ch )\n{\n\t/**\n\t * '0' => 0, ..., '9' => 9\n\t * 'A' => 10, 'B' => 11, ... 'Z' => 35\n\t */\n\tif ( isdigit( ch ) ) {\n\t\treturn ch - '0';\n\t}\n\telse if ( isupper( ch ) ) {\n\t\treturn ch - 'A' + 10;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n}",
        "begin_line": 64,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.FindSymbolKey#1268",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.FindSymbolKey( const char *symbol )",
        "snippet": "static int FindSymbolKey( const char *symbol )\n{\n\tunsigned int i;\n\tconst char * const *buf;\n\tfor ( i = 0; i < ARRAY_SIZE( symbol_buf ); ++i ) {\n\t\tfor ( buf = symbol_buf[ i ]; *buf; ++buf )\t{\n\t\t\tif (  0 == strcmp( *buf, symbol ) )\n\t\t\t\treturn *symbol_buf[ i ][ 0 ];\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 1268,
        "end_line": 1279,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.HaninSymbolInput#133",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.HaninSymbolInput( ChewingData *pgdata )",
        "snippet": "int HaninSymbolInput( ChewingData *pgdata )\n{\n\tunsigned int i;\n\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tAvailInfo *pai = &( pgdata->availInfo );\n\n\t/* No available symbol table */\n\tif ( ! pgdata->static_data.symbol_table )\n\t\treturn ZUIN_ABSORB;\n\n\tpci->nTotalChoice = 0;\n\tfor ( i = 0; i < pgdata->static_data.n_symbol_entry; i++ ) {\n\t\tstrcpy( pci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\tpgdata->static_data.symbol_table[ i ]->category );\n\t\tpci->nTotalChoice++;\n\t}\n\tpai->avail[ 0 ].len = 1;\n\tpai->avail[ 0 ].id = -1;\n\tpai->nAvail = 1;\n\tpai->currentAvail = 0;\n\tpci->nChoicePerPage = pgdata->config.candPerPage;\n\tassert( pci->nTotalChoice > 0 );\n\tpci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );\n\tpci->pageNo = 0;\n\tpci->isSymbol = SYMBOL_CATEGORY_CHOICE;\n\treturn ZUIN_ABSORB;\n}",
        "begin_line": 133,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.InitEasySymbolInput#1449",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.InitEasySymbolInput( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitEasySymbolInput( ChewingData *pgdata, const char *prefix )\n{\n\tstatic const size_t LINE_LEN = 512; // shall be long enough?\n\n\tFILE *file = NULL;\n\tchar *filename = NULL;\n\tchar *line = NULL;\n\tint len;\n\tint _index;\n\tchar *symbol;\n\tint ret = -1;\n\n\tret = asprintf( &filename, \"%s\" PLAT_SEPARATOR \"%s\",\n\t\t\tprefix, SOFTKBD_TABLE_FILE );\n\tif ( ret == -1 )\n\t\tgoto end;\n\n\tfile = fopen( filename, \"r\" );\n\tif ( !file )\n\t\tgoto end;\n\n\tline = ALC( char, LINE_LEN );\n\tif ( !line )\n\t\tgoto end;\n\n\twhile ( fgets( line, LINE_LEN, file ) ) {\n\t\tif ( ' ' != line[ 1 ] )\n\t\t\tcontinue;\n\n\t\t// Remove tailing \\n\n\t\tlen = strcspn( line, \"\\r\\n\" );\n\n\t\tline[ len ] = '\\0';\n\n\t\t_index = FindEasySymbolIndex( line[ 0 ] );\n\t\tif ( -1 == _index )\n\t\t\tcontinue;\n\n\t\tlen = ueStrLen( &line[ 2 ] );\n\t\tif ( 0 == len || len > MAX_PHRASE_LEN )\n\t\t\tcontinue;\n\n\t\tsymbol = ALC( char, strlen( &line[2] ) + 1 );\n\t\tif ( !symbol )\n\t\t\tgoto end;\n\n\t\tueStrNCpy( symbol, &line[ 2 ], len, 1 );\n\n\t\tfree( pgdata->static_data.g_easy_symbol_value[ _index ] );\n\t\tpgdata->static_data.g_easy_symbol_value[ _index ] = symbol;\n\t\tpgdata->static_data.g_easy_symbol_num[ _index ] = len;\n\t}\n\tret = 0;\nend:\n\tfree( line );\n\tfclose( file );\n\tfree ( filename );\n\treturn ret;\n}",
        "begin_line": 1449,
        "end_line": 1507,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.InitSymbolTable#1328",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.InitSymbolTable( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitSymbolTable( ChewingData *pgdata, const char *prefix )\n{\n\tstatic const unsigned int MAX_SYMBOL_ENTRY = 100;\n\tstatic const size_t LINE_LEN = 512; // shall be long enough?\n\n\tchar *filename = NULL;\n\tFILE *file = NULL;\n\tchar *line = NULL;\n\tSymbolEntry **entry = NULL;\n\tchar *category_end;\n\tconst char *symbols;\n\tconst char *symbols_end;\n\tconst char *symbol;\n\tsize_t i;\n\tsize_t len;\n\tsize_t size;\n\tint ret = -1;\n\n\tpgdata->static_data.n_symbol_entry = 0;\n\tpgdata->static_data.symbol_table = NULL;\n\n\tret = asprintf( &filename, \"%s\" PLAT_SEPARATOR \"%s\",\n\t\tprefix, SYMBOL_TABLE_FILE );\n\tif ( ret == -1 )\n\t\tgoto error;\n\n\tfile = fopen( filename, \"r\" );\n\tif ( !file )\n\t\tgoto error;\n\n\tline = ALC( char, LINE_LEN );\n\tif ( !line )\n\t\tgoto error;\n\n\tentry = ALC( SymbolEntry* , MAX_SYMBOL_ENTRY );\n\tif ( !entry )\n\t\tgoto error;\n\n\twhile ( fgets( line, LINE_LEN, file ) &&\n\t\tpgdata->static_data.n_symbol_entry < MAX_SYMBOL_ENTRY ) {\n\n\t\tcategory_end = strpbrk( line, \"=\\r\\n\" );\n\t\tif ( !category_end )\n\t\t\tgoto error;\n\n\t\tsymbols = category_end + 1;\n\t\tsymbols_end = strpbrk( symbols, \"\\r\\n\" );\n\t\tif ( symbols_end ) {\n\t\t\tlen = ueStrLen( symbols );\n\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ] =\n\t\t\t\t( SymbolEntry* ) malloc( sizeof ( entry[0][0] ) +\n\t\t\t\t\tsizeof( entry[0][0].symbols[0] ) * len);\n\t\t\tif ( !entry[ pgdata->static_data.n_symbol_entry ] )\n\t\t\t\tgoto error;\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ]\n\t\t\t\t->nSymbols = len;\n\n\t\t\tsymbol = symbols;\n\n\t\t\tfor ( i = 0; i < len; ++i ) {\n\t\t\t\tueStrNCpy(\n\t\t\t\t\tentry[ pgdata->static_data.n_symbol_entry ]->symbols[ i ],\n\t\t\t\t\tsymbol, 1, 1 );\n\t\t\t\t// FIXME: What if symbol is combining sequences.\n\t\t\t\tsymbol += ueBytesFromChar( symbol[0] );\n\t\t\t}\n\n\n\t\t} else {\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ] =\n\t\t\t\t( SymbolEntry* ) malloc( sizeof ( entry[0][0] ) );\n\t\t\tif ( !entry[ pgdata->static_data.n_symbol_entry ] )\n\t\t\t\tgoto error;\n\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ]\n\t\t\t\t->nSymbols = 0;\n\t\t}\n\n\t\t*category_end = 0;\n\t\tueStrNCpy(\n\t\t\tentry[pgdata->static_data.n_symbol_entry]->category,\n\t\t\tline, MAX_PHRASE_LEN, 1);\n\n\t\t++pgdata->static_data.n_symbol_entry;\n\t}\n\n\tsize = sizeof( *pgdata->static_data.symbol_table ) *\n\t\tpgdata->static_data.n_symbol_entry;\n\tpgdata->static_data.symbol_table = ( SymbolEntry ** ) malloc( size );\n\tif ( !pgdata->static_data.symbol_table )\n\t\tgoto error;\n\tmemcpy( pgdata->static_data.symbol_table, entry, size );\n\n\tret = 0;\nend:\n\tfree( entry );\n\tfree( line );\n\tfclose( file );\n\tfree ( filename );\n\treturn ret;\n\nerror:\n\tfor ( i = 0; i < pgdata->static_data.n_symbol_entry; ++i ) {\n\t\tfree( entry[ i ] );\n\t}\n\tgoto end;\n}",
        "begin_line": 1328,
        "end_line": 1435,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.IsPreferIntervalConnted#1103",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.IsPreferIntervalConnted( int cursor, ChewingData *pgdata )",
        "snippet": "int IsPreferIntervalConnted( int cursor, ChewingData *pgdata )\n{\n\tint i;\n\n\tfor ( i = 0; i < pgdata->nPrefer; i++ ) {\n\t\tif (\n\t\t\tpgdata->preferInterval[ i ].from < cursor &&\n\t\t\tpgdata->preferInterval[ i ].to > cursor )\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "begin_line": 1103,
        "end_line": 1114,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.KillCharInSelectIntervalAndBrkpt#1043",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.KillCharInSelectIntervalAndBrkpt( ChewingData *pgdata, int cursorToKill )",
        "snippet": "static int KillCharInSelectIntervalAndBrkpt( ChewingData *pgdata, int cursorToKill )\n{\n\tint i;\n\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( pgdata->selectInterval[ i ].from <= cursorToKill &&\n\t\t\tpgdata->selectInterval[ i ].to > cursorToKill ) {\n\t\t\tRemoveSelectElement( i, pgdata );\n\t\t\ti--;      /* the last one was swap to i, we need to recheck i */\n\t\t}\n\t\telse if( pgdata->selectInterval[ i ].from > cursorToKill ) {\n\t\t\tpgdata->selectInterval[ i ].from--;\n\t\t\tpgdata->selectInterval[ i ].to--;\n\t\t}\n\t}\n\tassert ( pgdata->nPhoneSeq >= cursorToKill );\n\tmemmove(\n\t\t&( pgdata->bUserArrBrkpt[ cursorToKill ] ),\n\t\t&( pgdata->bUserArrBrkpt[ cursorToKill + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursorToKill ) );\n\tmemmove(\n\t\t&( pgdata->bUserArrCnnct[ cursorToKill ] ),\n\t\t&( pgdata->bUserArrCnnct[ cursorToKill + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursorToKill ) );\n\n\treturn 0;\n}",
        "begin_line": 1043,
        "end_line": 1069,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.MakeOutput#871",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.MakeOutput( ChewingOutput *pgo, ChewingData *pgdata )",
        "snippet": "static int MakeOutput( ChewingOutput *pgo, ChewingData *pgdata )\n{\n\tint chi_i, chiSymbol_i, i ;\n\n\t/* fill zero to chiSymbolBuf first */\n\tmemset( pgo->chiSymbolBuf, 0, sizeof( wch_t ) * MAX_PHONE_SEQ_LEN );\n\n\t/* fill chiSymbolBuf */\n\tfor (\n\t\tchi_i = chiSymbol_i = 0;\n\t\tchiSymbol_i < pgdata->chiSymbolBufLen;\n\t\tchiSymbol_i ++ ) {\n\t\tif ( pgdata->chiSymbolBuf[ chiSymbol_i ].wch == 0 ) {\n\t\t\t/* is Chinese, then copy from the PhrasingOutput \"phrOut\" */\n\t\t\tpgo->chiSymbolBuf[ chiSymbol_i ].wch = 0;\n\t\t\tueStrNCpy( (char *) pgo->chiSymbolBuf[ chiSymbol_i ].s,\n\t\t\t           &( pgdata->phrOut.chiBuf[ chi_i ] ),\n\t\t\t           1, 1 );\n\t\t\tchi_i += ueBytesFromChar( pgo->chiSymbolBuf[ chiSymbol_i ].s[0] );\n\t\t}\n\t\telse {\n\t\t\t/* is Symbol */\n\t\t\tpgo->chiSymbolBuf[ chiSymbol_i ] = pgdata->chiSymbolBuf[ chiSymbol_i ];\n\t\t}\n\t}\n\n\t/* fill point */\n\tpgo->PointStart = pgdata->PointStart;\n\tpgo->PointEnd = pgdata->PointEnd;\n\n\t/* fill other fields */\n\tpgo->chiSymbolBufLen = pgdata->chiSymbolBufLen;\n\tpgo->chiSymbolCursor = pgdata->chiSymbolCursor;\n\n\t/* fill zuinBuf */\n\tif ( pgdata->zuinData.kbtype >= KB_HANYU_PINYIN ) {\n\t\tconst char *p = pgdata->zuinData.pinYinData.keySeq;\n\t\t/*\n\t\t * Copy from old content in zuinBuf\n\t\t * NOTE: No Unicode transformation here.\n\t\t */\n\t\tfor ( i = 0; i< ZUIN_SIZE; i++) {\n\t\t\tint j;\n\t\t\tfor ( j = 0; j < 2; j++ ) {\n\t\t\t\tif ( p[ 0 ] ) {\n\t\t\t\t\tpgo->zuinBuf[ i ].s[ j ] = p[ 0 ];\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpgo->zuinBuf[ i ].s[ j ] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tpgo->zuinBuf[ i ].s[ 2 ] = '\\0';\n\t\t}\n\t} else {\n\t\tfor ( i = 0; i < ZUIN_SIZE; i++ ) {\n\t\t\tif ( pgdata->zuinData.pho_inx[ i ] != 0 ) {\n\t\t\t\t/* Here we should use (zhuin_tab[i] + 2) to\n\t\t\t\t * skip the 2 space characters at\n\t\t\t\t * zhuin_tab[0] and zhuin_tab[1]. */\n\t\t\t\tueStrNCpy( (char *) pgo->zuinBuf[ i ].s,\n\t\t\t\t           ueConstStrSeek( (zhuin_tab[ i ] + 2),\n\t\t\t\t\t\t      pgdata->zuinData.pho_inx[ i ] - 1 ),\n\t\t\t\t           1, 1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tpgo->zuinBuf[ i ].wch = 0;\n\t\t}\n\t}\n\n\tShiftInterval( pgo, pgdata );\n\tmemcpy(\n\t\tpgo->dispBrkpt, pgdata->bUserArrBrkpt,\n\t\tsizeof( pgo->dispBrkpt[ 0 ] ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\tpgo->pci = &( pgdata->choiceInfo );\n\tpgo->bChiSym = pgdata->bChiSym;\n\tmemcpy( pgo->selKey, pgdata->config.selKey, sizeof( pgdata->config.selKey ) );\n\tpgo->bShowMsg = 0;\n\treturn 0;\n}",
        "begin_line": 871,
        "end_line": 950,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.MakeOutputWithRtn#952",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.MakeOutputWithRtn( ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn )",
        "snippet": "int MakeOutputWithRtn( ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn )\n{\n\tpgo->keystrokeRtn = keystrokeRtn;\n\treturn MakeOutput( pgo, pgdata );\n}",
        "begin_line": 952,
        "end_line": 956,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.MakePreferInterval#805",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.MakePreferInterval( ChewingData *pgdata )",
        "snippet": "static void MakePreferInterval( ChewingData *pgdata )\n{\n\tint i, j, set_no;\n\tint belong_set[ MAX_PHONE_SEQ_LEN + 1 ];\n\tint parent[ MAX_PHONE_SEQ_LEN + 1 ];\n\n\tmemset( belong_set, 0 , sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\tmemset( parent, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\n\t/* for each interval */\n\tfor ( i = 0; i < pgdata->phrOut.nDispInterval; i++ ) {\n\t\tfor (\n\t\t\tj = pgdata->phrOut.dispInterval[ i ].from;\n\t\t\tj < pgdata->phrOut.dispInterval[ i ].to;\n\t\t\tj++ ) {\n\t\t\tbelong_set[ j ] = i + 1;\n\t\t}\n\t}\n\tset_no = i + 1;\n\tfor ( i = 0; i < pgdata->nPhoneSeq; i++ )\n\t\tif ( belong_set[i] == 0 )\n\t\t\tbelong_set[ i ] = set_no++;\n\n\t/* for each connect point */\n\tfor ( i = 1; i < pgdata->nPhoneSeq; i++ ) {\n\t\tif ( pgdata->bUserArrCnnct[ i ] ) {\n\t\t\tUnion( belong_set[ i - 1 ], belong_set[ i ], parent );\n\t\t}\n\t}\n\n\t/* generate new intervals */\n\tpgdata->nPrefer = 0;\n\ti = 0;\n\twhile ( i < pgdata->nPhoneSeq ) {\n\t\tfor ( j = i + 1; j < pgdata->nPhoneSeq; j++ )\n\t\t\tif ( ! SameSet( belong_set[ i ], belong_set[ j ], parent ) )\n\t\t\t\tbreak;\n\n\t\tpgdata->preferInterval[ pgdata->nPrefer ].from = i;\n\t\tpgdata->preferInterval[ pgdata->nPrefer ].to = j;\n\t\tpgdata->nPrefer++;\n\t\ti = j;\n\t}\n}",
        "begin_line": 805,
        "end_line": 848,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.PhoneSeqCursor#1007",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.PhoneSeqCursor( ChewingData *pgdata )",
        "snippet": "int PhoneSeqCursor( ChewingData *pgdata )\n{\n\tint cursor = pgdata->chiSymbolCursor - CountSymbols( pgdata, pgdata->chiSymbolCursor );\n\treturn cursor > 0 ? cursor : 0;\n}",
        "begin_line": 1007,
        "end_line": 1011,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ReleaseChiSymbolBuf#537",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ReleaseChiSymbolBuf( ChewingData *pgdata, ChewingOutput *pgo )",
        "snippet": "int ReleaseChiSymbolBuf( ChewingData *pgdata, ChewingOutput *pgo )\n{\n\tint throwEnd;\n\tuint16_t bufPhoneSeq[ MAX_PHONE_SEQ_LEN + 1 ];\n\tchar bufWordSeq[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ];\n\n\tthrowEnd = CountReleaseNum( pgdata );\n\n\tpgo->nCommitStr = throwEnd;\n\tif ( throwEnd ) {\n\t\t/*\n\t\t * count how many chinese words in \"chiSymbolBuf[ 0 .. (throwEnd - 1)]\"\n\t\t * And release from \"chiSymbolBuf\" && \"phoneSeq\"\n\t\t */\n\t\tWriteChiSymbolToBuf( pgo->commitStr, throwEnd, pgdata );\n\n\t\t/* Add to userphrase */\n\t\tmemcpy( bufPhoneSeq, pgdata->phoneSeq, sizeof( uint16_t ) * throwEnd );\n\t\tbufPhoneSeq[ throwEnd ] = (uint16_t) 0;\n\t\tueStrNCpy( bufWordSeq, pgdata->phrOut.chiBuf, throwEnd, 1 );\n\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\n\t\tKillFromLeft( pgdata, throwEnd );\n\t}\n\treturn throwEnd;\n}",
        "begin_line": 537,
        "end_line": 562,
        "is_bug": true
    },
    {
        "name": "src.chewingutil.RemoveSelectElement#1022",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.RemoveSelectElement( int i, ChewingData *pgdata )",
        "snippet": "void RemoveSelectElement( int i, ChewingData *pgdata )\n{\n\tif ( --pgdata->nSelect == i )\n\t\treturn;\n\tpgdata->selectInterval[ i ] = pgdata->selectInterval[ pgdata->nSelect ];\n\tstrcpy( pgdata->selectStr[ i ], pgdata->selectStr[ pgdata->nSelect ] );\n}",
        "begin_line": 1022,
        "end_line": 1028,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.SameSet#793",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.SameSet( int set1, int set2, int parent[] )",
        "snippet": "static int SameSet( int set1,int set2, int parent[] )\n{\n\twhile ( parent[ set1 ] != 0 ) {\n\t\tset1 = parent[ set1 ];\n\t}\n\twhile ( parent[ set2 ] != 0 ) {\n\t\tset2 = parent[ set2 ];\n\t}\n\treturn ( set1 == set2 );\n}",
        "begin_line": 793,
        "end_line": 802,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ShiftInterval#851",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ShiftInterval( ChewingOutput *pgo, ChewingData *pgdata )",
        "snippet": "static void ShiftInterval( ChewingOutput *pgo, ChewingData *pgdata )\n{\n\tint i, arrPos[ MAX_PHONE_SEQ_LEN ], k = 0, from, len;\n\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) ) {\n\t\t\tarrPos[ k++ ] = i;\n\t\t}\n\t}\n\tarrPos[ k ] = i;\n\n\tpgo->nDispInterval = pgdata->nPrefer;\n\tfor ( i = 0; i < pgdata->nPrefer; i++ ) {\n\t\tfrom = pgdata->preferInterval[ i ].from;\n\t\tlen = pgdata->preferInterval[ i ].to - from;\n\t\tpgo->dispInterval[ i ].from = arrPos[ from ];\n\t\tpgo->dispInterval[ i ].to = arrPos[ from ] + len;\n\t}\n}",
        "begin_line": 851,
        "end_line": 869,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ShowChewingData#701",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ShowChewingData( ChewingData *pgdata )",
        "snippet": "static void ShowChewingData( ChewingData *pgdata )\n{\n\tint i ;\n\n\tDEBUG_OUT(\n\t\t\"nPhoneSeq : %d\\n\"\n\t\t\"phoneSeq  : \",\n\t\tpgdata->nPhoneSeq );\n\tfor ( i = 0; i < pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%hu \", pgdata->phoneSeq[ i ] );\n\tDEBUG_OUT(\n\t\t\"[cursor : %d]\\n\"\n\t\t\"nSelect : %d\\n\"\n\t\t\"selectStr       selectInterval\\n\",\n\t\tPhoneSeqCursor( pgdata ),\n\t\tpgdata->nSelect );\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tDEBUG_OUT(\n\t\t\t\"  %14s%4d%4d\\n\",\n\t\t\tpgdata->selectStr[ i ],\n\t\t\tpgdata->selectInterval[ i ].from,\n\t\t\tpgdata->selectInterval[ i ].to );\n\t}\n\n\tDEBUG_OUT( \"bUserArrCnnct : \" );\n\tfor ( i = 0; i <= pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%d \", pgdata->bUserArrCnnct[ i ] );\n\tDEBUG_OUT( \"\\n\" );\n\n\tDEBUG_OUT( \"bUserArrBrkpt : \" );\n\tfor ( i = 0; i <= pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%d \", pgdata->bUserArrBrkpt[ i ] );\n\tDEBUG_OUT( \"\\n\" );\n\n\tDEBUG_OUT( \"bArrBrkpt     : \" );\n\tfor ( i = 0; i <= pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%d \", pgdata->bArrBrkpt[ i ] );\n\tDEBUG_OUT( \"\\n\" );\n\n\tDEBUG_OUT(\n\t\t\"bChiSym : %d , bSelect : %d\\n\",\n\t\tpgdata->bChiSym,\n\t\tpgdata->bSelect );\n}",
        "begin_line": 701,
        "end_line": 744,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.SymbolChoice#334",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.SymbolChoice( ChewingData *pgdata, int sel_i )",
        "snippet": "int SymbolChoice( ChewingData *pgdata, int sel_i )\n{\n\tint kbtype;\n\tint i;\n\tint symbol_type;\n\tint key;\n\n\tif ( ! pgdata->static_data.symbol_table && pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_UPDATE )\n\t\treturn ZUIN_ABSORB;\n\n\tif ( pgdata->choiceInfo.isSymbol == SYMBOL_CATEGORY_CHOICE &&\n\t\t\t0 == pgdata->static_data.symbol_table[sel_i]->nSymbols )\n\t\tsymbol_type = SYMBOL_CHOICE_INSERT;\n\telse\n\t\tsymbol_type = pgdata->choiceInfo.isSymbol;\n\n\t/* level one, symbol category */\n\tif ( symbol_type == SYMBOL_CATEGORY_CHOICE ) {\n\t\tChoiceInfo* pci = &pgdata->choiceInfo;\n\t\tAvailInfo* pai = &pgdata->availInfo;\n\n\t\t/* Display all symbols in this category */\n\t\tpci->nTotalChoice = 0;\n\t\tfor ( i = 0; i < pgdata->static_data.symbol_table[ sel_i ]->nSymbols; i++ ) {\n\t\t\tueStrNCpy( pci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\t\tpgdata->static_data.symbol_table[ sel_i ]->symbols[ i ], 1, 1 );\n\t\t\tpci->nTotalChoice++;\n\t\t}\n\t\tpai->avail[ 0 ].len = 1;\n\t\tpai->avail[ 0 ].id = -1;\n\t\tpai->nAvail = 1;\n\t\tpai->currentAvail = 0;\n\t\tpci->nChoicePerPage = pgdata->config.candPerPage;\n\t\tassert( pci->nTotalChoice > 0 );\n\t\tpci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );\n\t\tpci->pageNo = 0;\n\t\tpci->isSymbol = SYMBOL_CHOICE_INSERT;\n\t}\n\telse { /* level 2 symbol or OpenSymbolChoice */\n\t\t/* TODO: FIXME, this part is buggy! */\n\t\tif ( symbol_type == SYMBOL_CHOICE_INSERT ) {\n\t\t\tassert( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );\n\t\t\tmemmove(\n\t\t\t\t&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor + 1 ] ),\n\t\t\t\t&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ] ),\n\t\t\t\tsizeof( wch_t ) * ( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\t\t}\n\t\tpgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].wch = 0;\n\t\tueStrNCpy( (char *) pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].s,\n\t\t\t\tpgdata->choiceInfo.totalChoiceStr[ sel_i ], 1, 1);\n\n\t\t/* This is very strange */\n\t\tkey = FindSymbolKey( pgdata->choiceInfo.totalChoiceStr[ sel_i ] );\n\t\tpgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] = key ? key : '0';\n\n\t\tpgdata->bUserArrCnnct[ PhoneSeqCursor( pgdata ) ] = 0;\n\t\tChoiceEndChoice(pgdata);\n\t\t/* Don't forget the kbtype */\n\t\tkbtype = pgdata->zuinData.kbtype;\n\t\tmemset( &( pgdata->zuinData ), 0, sizeof( ZuinData ) );\n\t\tpgdata->zuinData.kbtype = kbtype;\n\n\t\tif ( symbol_type == SYMBOL_CHOICE_INSERT ) {\n\t\t\tpgdata->chiSymbolBufLen++;\n\t\t\tpgdata->chiSymbolCursor ++ ;\n\t\t}\n\n\t\tpgdata->choiceInfo.isSymbol = WORD_CHOICE;\n\t}\n\treturn ZUIN_ABSORB;\n}",
        "begin_line": 334,
        "end_line": 404,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.SymbolInput#406",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.SymbolInput( int key, ChewingData *pgdata )",
        "snippet": "int SymbolInput( int key, ChewingData *pgdata )\n{\n\tif ( isprint( (char) key ) && /* other character was ignored */\n\t     (pgdata->chiSymbolBufLen < MAX_PHONE_SEQ_LEN) ) { /* protect the buffer */\n\t\tassert( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );\n\t\tmemmove(\n\t\t\t&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor + 1 ] ),\n\t\t\t&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ] ),\n\t\t\tsizeof( wch_t ) * ( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\n\t\tpgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].wch = 0;\n\t\tpgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].s[ 0 ] = (char) key;\n\n\t\t/* Save Symbol Key */\n\t\tmemmove( &( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor + 1 ] ),\n\t\t\t&( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] ),\n\t\t\tsizeof( pgdata->symbolKeyBuf[ 0 ] ) *\n\t\t\t( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\t\t\tpgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] = toupper( key );\n\n\t\tpgdata->bUserArrCnnct[ PhoneSeqCursor( pgdata ) ] = 0;\n\t\tpgdata->chiSymbolCursor++;\n\t\tpgdata->chiSymbolBufLen++;\n\t\treturn SYMBOL_KEY_OK;\n\t}\n\treturn SYMBOL_KEY_ERROR;\n}",
        "begin_line": 406,
        "end_line": 432,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.TerminateEasySymbolTable#1509",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.TerminateEasySymbolTable( ChewingData *pgdata )",
        "snippet": "void TerminateEasySymbolTable( ChewingData *pgdata )\n{\n\tunsigned int i;\n\tfor ( i = 0; i < EASY_SYMBOL_KEY_TAB_LEN ; ++i ) {\n\t\tif ( NULL != pgdata->static_data.g_easy_symbol_value[ i ] ) {\n\t\t\tfree( pgdata->static_data.g_easy_symbol_value[ i ] );\n\t\t\tpgdata->static_data.g_easy_symbol_value[ i ] = NULL;\n\t\t}\n\t\tpgdata->static_data.g_easy_symbol_num[ i ] = 0;\n\t}\n}",
        "begin_line": 1509,
        "end_line": 1519,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.TerminateSymbolTable#1437",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.TerminateSymbolTable( ChewingData *pgdata )",
        "snippet": "void TerminateSymbolTable( ChewingData *pgdata )\n{\n\tunsigned int i;\n\tif ( pgdata->static_data.symbol_table ) {\n\t\tfor ( i = 0; i < pgdata->static_data.n_symbol_entry; ++i )\n\t\t\tfree( pgdata->static_data.symbol_table[ i ] );\n\t\tfree( pgdata->static_data.symbol_table );\n\t\tpgdata->static_data.n_symbol_entry = 0;\n\t\tpgdata->static_data.symbol_table = NULL;\n\t}\n}",
        "begin_line": 1437,
        "end_line": 1447,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.Union#787",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.Union( int set1, int set2, int parent[] )",
        "snippet": "static void Union( int set1,int set2, int parent[] )\n{\n\tif ( set1 != set2 )\n\t\tparent[ max( set1, set2 ) ] = min( set1, set2 );\n}",
        "begin_line": 787,
        "end_line": 791,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.WriteChiSymbolToBuf#452",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.WriteChiSymbolToBuf( wch_t csBuf[], int csBufLen, ChewingData *pgdata )",
        "snippet": "int WriteChiSymbolToBuf( wch_t csBuf[], int csBufLen, ChewingData *pgdata )\n{\n\tint i, phoneseq_i = 0;\n\n\tfor ( i = 0 ; i < csBufLen; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) ) {\n\t\t\t/*\n\t\t\t * Workaround to avoid different initialization behavior\n\t\t\t * among Win32 and Unix-like OSs.\n\t\t\t */\n\t\t\tmemset( &( csBuf[ i ].s ), 0, MAX_UTF8_SIZE + 1 );\n\t\t\tueStrNCpy( (char *) csBuf[ i ].s,\n\t\t\t           &( pgdata->phrOut.chiBuf[ phoneseq_i ] ),\n\t\t\t\t   1, 1);\n\t\t\tphoneseq_i += ueBytesFromChar( pgdata->phrOut.chiBuf[ phoneseq_i ] );\n\t\t}\n\t\telse\n\t\t\tcsBuf[ i ] = pgdata->chiSymbolBuf[ i ];\n\t}\n\treturn 0;\n}",
        "begin_line": 452,
        "end_line": 472,
        "is_bug": false
    },
    {
        "name": "src.choice.ChangeSelectIntervalAndBreakpoint#35",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChangeSelectIntervalAndBreakpoint( \t\tChewingData *pgdata, int from, int to, const char *str )",
        "snippet": "static void ChangeSelectIntervalAndBreakpoint(\n\t\tChewingData *pgdata,\n\t\tint from,\n\t\tint to,\n\t\tconst char *str )\n{\n\tint i;\n\tint user_alloc;\n\n\tIntervalType inte;\n\n\tinte.from = from;\n\tinte.to = to;\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( IsIntersect( inte, pgdata->selectInterval[ i ] ) ) {\n\t\t\tRemoveSelectElement( i, pgdata );\n\t\t\ti--;\n\t\t}\n\t}\n\n\tpgdata->selectInterval[ pgdata->nSelect ].from = from;\n\tpgdata->selectInterval[ pgdata->nSelect ].to = to;\n\n\t/* No available selection */\n\tif ( ( user_alloc = ( to - from ) ) == 0 )\n\t\treturn;\n\n\tueStrNCpy( pgdata->selectStr[ pgdata->nSelect ],\n\t\t\tstr,\n\t\t\tuser_alloc, 1);\n\tpgdata->nSelect++;\n\n\tif ( user_alloc > 1 ) {\n\t\tmemset( &pgdata->bUserArrBrkpt[ from + 1 ], 0, sizeof( int ) * ( user_alloc - 1 ) );\n\t\tmemset( &pgdata->bUserArrCnnct[ from + 1 ], 0, sizeof( int ) * ( user_alloc - 1 ) );\n\t}\n}",
        "begin_line": 35,
        "end_line": 71,
        "is_bug": false
    },
    {
        "name": "src.choice.ChangeUserData#417",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChangeUserData( ChewingData *pgdata, int selectNo )",
        "snippet": "static void ChangeUserData( ChewingData *pgdata, int selectNo )\n{\n\tuint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];\n\tint len;\n\n\tlen = ueStrLen( pgdata->choiceInfo.totalChoiceStr[ selectNo ] );\n\tmemcpy(\n\t\tuserPhoneSeq,\n\t\t&( pgdata->phoneSeq[ PhoneSeqCursor( pgdata ) ] ),\n\t\tlen * sizeof( uint16_t ) );\n\tuserPhoneSeq[ len ] = 0;\n\tUserUpdatePhrase( pgdata, userPhoneSeq, pgdata->choiceInfo.totalChoiceStr[ selectNo ] );\n}",
        "begin_line": 417,
        "end_line": 429,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceEndChoice#402",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceEndChoice( ChewingData *pgdata )",
        "snippet": "int ChoiceEndChoice( ChewingData *pgdata )\n{\n\tpgdata->bSelect = 0;\n\tpgdata->choiceInfo.nTotalChoice = 0;\n\tpgdata->choiceInfo.nPage = 0;\n\n\tif ( pgdata->choiceInfo.isSymbol != WORD_CHOICE || pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_INSERT ) {\n\t\t/* return to the old chiSymbolCursor position */\n\t\tpgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor;\n\t\tassert ( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );\n\t}\n\tpgdata->choiceInfo.isSymbol = WORD_CHOICE;\n\treturn 0;\n}",
        "begin_line": 402,
        "end_line": 415,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceFirstAvail#350",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceFirstAvail( ChewingData *pgdata )",
        "snippet": "int ChoiceFirstAvail( ChewingData *pgdata )\n{\n\tint end, begin;\n\n\t/* save old cursor position */\n\tpgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n\t/* see if there is some word in the cursor position */\n\tif ( pgdata->chiSymbolBufLen == pgdata->chiSymbolCursor ) {\n\t\tpgdata->chiSymbolCursor--;\n\t}\n\n\tend = PhoneSeqCursor( pgdata );\n\n\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\tpgdata->chiSymbolCursor = SeekPhraseHead( pgdata ) +\n\t\t\tCountSymbols( pgdata, pgdata->chiSymbolCursor );\n\t}\n\tbegin = PhoneSeqCursor( pgdata );\n\n\tpgdata->bSelect = 1;\n\n\tSetAvailInfo( pgdata, begin, end );\n\n\tif ( ! pgdata->availInfo.nAvail )\n\t\treturn ChoiceEndChoice( pgdata );\n\n\tpgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;\n\tSetChoiceInfo( pgdata );\n\treturn 0;\n}",
        "begin_line": 350,
        "end_line": 380,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceInfoAppendChi#160",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceInfoAppendChi( ChewingData *pgdata, ChoiceInfo *pci, uint16_t phone )",
        "snippet": "static void ChoiceInfoAppendChi( ChewingData *pgdata,  ChoiceInfo *pci, uint16_t phone )\n{\n\tWord tempWord;\n\tint len;\n\tif ( GetCharFirst( pgdata, &tempWord, phone ) ) {\n\t\tdo {\n\t\t\tlen = ueBytesFromChar( tempWord.word[ 0 ] );\n\t\t\tif ( ChoiceTheSame( pci, tempWord.word,\n\t\t\t\t\t    len) )\n\t\t\t\tcontinue;\n\t\t\tassert( pci->nTotalChoice < MAX_CHOICE );\n\t\t\tmemcpy(\n\t\t\t\tpci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\ttempWord.word, len );\n\t\t\tpci->totalChoiceStr[ pci->nTotalChoice ]\n\t\t\t\t\t   [ len ] = '\\0';\n\t\t\tpci->nTotalChoice++;\n\t\t} while ( GetCharNext( pgdata, &tempWord ) );\n\t}\n}",
        "begin_line": 160,
        "end_line": 179,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceNextAvail#393",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceNextAvail( ChewingData *pgdata )",
        "snippet": "int ChoiceNextAvail( ChewingData *pgdata )\n{\n\tif (pgdata->choiceInfo.isSymbol) return 0;\n\tif ( --( pgdata->availInfo.currentAvail ) < 0 )\n\t\tpgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;\n\tSetChoiceInfo( pgdata );\n\treturn 0;\n}",
        "begin_line": 393,
        "end_line": 400,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceSelect#432",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceSelect( ChewingData *pgdata, int selectNo )",
        "snippet": "int ChoiceSelect( ChewingData *pgdata, int selectNo )\n{\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tAvailInfo *pai = &( pgdata->availInfo );\n\n\tChangeUserData( pgdata, selectNo );\n\tChangeSelectIntervalAndBreakpoint(\n\t\t\tpgdata,\n\t\t\tPhoneSeqCursor( pgdata ),\n\t\t\tPhoneSeqCursor( pgdata ) + pai->avail[ pai->currentAvail ].len,\n\t\t\tpci->totalChoiceStr[ selectNo ] );\n\tChoiceEndChoice( pgdata );\n\treturn 0;\n}",
        "begin_line": 432,
        "end_line": 445,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceTheSame#150",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceTheSame( ChoiceInfo *pci, const char *str, int len )",
        "snippet": "static int ChoiceTheSame( ChoiceInfo *pci, const char *str, int len )\n{\n\tint i;\n\n\tfor ( i = 0; i < pci->nTotalChoice; i++ )\n\t\tif ( ! memcmp( pci->totalChoiceStr[ i ], str, len ) )\n\t\t\treturn 1;\n\treturn 0;\n}",
        "begin_line": 150,
        "end_line": 158,
        "is_bug": false
    },
    {
        "name": "src.choice.SeekPhraseHead#336",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.SeekPhraseHead( ChewingData *pgdata )",
        "snippet": "static int SeekPhraseHead( ChewingData *pgdata )\n{\n\tint i;\n\tint phoneSeq = PhoneSeqCursor( pgdata );\n\tfor ( i = pgdata->nPrefer - 1; i >= 0; i-- ) {\n\t\tif ( pgdata->preferInterval[ i ].from > phoneSeq\n\t\t\t\t|| pgdata->preferInterval[ i ].to < phoneSeq )\n\t\t\tcontinue;\n\t\treturn pgdata->preferInterval[ i ].from;\n\t}\n\treturn 0;\n}",
        "begin_line": 336,
        "end_line": 347,
        "is_bug": false
    },
    {
        "name": "src.choice.SetAvailInfo#74",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.SetAvailInfo( ChewingData *pgdata, int begin, int end)",
        "snippet": "static void SetAvailInfo( ChewingData *pgdata, int begin, int end)\n{\n\tAvailInfo *pai = &( pgdata->availInfo );\n\tconst uint16_t *phoneSeq = pgdata->phoneSeq;\n\tint nPhoneSeq = pgdata->nPhoneSeq;\n\tconst int *bSymbolArrBrkpt = pgdata->bSymbolArrBrkpt;\n\n\tint pho_id;\n\tint diff;\n\tuint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];\n\n\tint i, head, head_tmp;\n\tint tail, tail_tmp;\n\n\thead = tail = 0;\n\n\tpai->nAvail = 0;\n\n\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\tfor ( i = end; i >= begin; i--){\n\t\t\thead = i;\n\t\t\tif ( bSymbolArrBrkpt[ i ] )\n\t\t\t\tbreak;\n\t\t}\n\t\thead_tmp = end;\n\t} else {\n\t\thead_tmp = head = begin;\n\t}\n\n\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\ttail_tmp = tail = end;\n\t} else {\n\t\tfor ( i = begin; i < nPhoneSeq; i++ ) {\n\t\t\tif ( bSymbolArrBrkpt[ i ] )\n\t\t\t\tbreak;\n\t\t\ttail = i;\n\t\t}\n\t\ttail_tmp = begin;\n\t}\n\n\twhile ( head <= head_tmp && tail_tmp <= tail ) {\n\t\tdiff = tail_tmp - head_tmp;\n\t\tpho_id = TreeFindPhrase( pgdata, head_tmp, tail_tmp, phoneSeq );\n\n\t\tif ( pho_id != -1 ) {\n\t\t\t/* save it! */\n\t\t\tpai->avail[ pai->nAvail ].len = diff + 1;\n\t\t\tpai->avail[ pai->nAvail ].id = pho_id;\n\t\t\tpai->nAvail++;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(\n\t\t\t\tuserPhoneSeq,\n\t\t\t\t&phoneSeq[ head_tmp ],\n\t\t\t\tsizeof( uint16_t ) * ( diff + 1 ) ) ;\n\t\t\tuserPhoneSeq[ diff + 1 ] = 0;\n\t\t\tif ( UserGetPhraseFirst( pgdata, userPhoneSeq ) ) {\n\t\t\t\t/* save it! */\n\t\t\t\tpai->avail[ pai->nAvail ].len = diff + 1;\n\t\t\t\tpai->avail[ pai->nAvail ].id = -1;\n\t\t\t\tpai->nAvail++;\n\t\t\t} else {\n\t\t\t\tpai->avail[ pai->nAvail ].len = 0;\n\t\t\t\tpai->avail[ pai->nAvail ].id = -1;\n\t\t\t}\n\t\t}\n\n\t\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\t\thead_tmp--;\n\t\t} else {\n\t\t\ttail_tmp++;\n\t\t}\n\t}\n}",
        "begin_line": 74,
        "end_line": 147,
        "is_bug": false
    },
    {
        "name": "src.choice.SetChoiceInfo#187",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.SetChoiceInfo( ChewingData *pgdata )",
        "snippet": "static void SetChoiceInfo( ChewingData *pgdata )\n{\n\tPhrase tempPhrase;\n\tint len;\n\tUserPhraseData *pUserPhraseData;\n\tuint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];\n\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tAvailInfo *pai = &( pgdata->availInfo );\n\tuint16_t *phoneSeq = pgdata->phoneSeq;\n\tuint16_t *phoneSeqAlt = pgdata->phoneSeqAlt;\n\tint cursor = PhoneSeqCursor( pgdata );\n\tint candPerPage = pgdata->config.candPerPage;\n\n\t/* Clears previous candidates. */\n\tmemset( pci->totalChoiceStr, '\\0',\n\t\tMAX_CHOICE * MAX_PHRASE_LEN * MAX_UTF8_SIZE + 1);\n\n\tpci->nTotalChoice = 0;\n\tlen = pai->avail[ pai->currentAvail ].len;\n\tassert(len);\n\n\t/* secondly, read tree phrase */\n\tif ( len == 1 ) { /* single character */\n\t\tChoiceInfoAppendChi( pgdata, pci, phoneSeq[ cursor ] );\n\n\t\tif ( phoneSeq[ cursor ] != phoneSeqAlt[ cursor ] ) {\n\t\t\tChoiceInfoAppendChi( pgdata, pci, phoneSeqAlt[ cursor ] );\n\t\t}\n\n\t\tif ( pgdata->zuinData.kbtype == KB_HSU ||\n\t\t     pgdata->zuinData.kbtype == KB_DVORAK_HSU ) {\n\t\t\tswitch ( phoneSeq[ cursor ] ) {\n\t\t\t\tcase 0x2800:\t/* '\u3118' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x30 );\t\t/* '\u311f' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x80:\t/* '\u3127' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x20 );\t\t/* '\u311d' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2A00:\t/* '\u3119' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1 );\t\t/* '\u02d9' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xA00:\t/* '\u3109' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x2 );\t\t/* '\u02ca' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x800:\t/* '\u3108' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x3 ); \t\t/* '\u02c7' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x18:\t/* '\u311c' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1200 );\t/* '\u310d' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x10:\t/* '\u311b' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1600 );\t/* '\u310f' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x1E00:\t/* '\u3113' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1800 );\t/* '\u3110' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x4 );\t\t/* '\u02cb' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x58:\t/* '\u3124' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1400 );\t/* '\u310e' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x68:\t/* '\u3126' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1000 );\t/* '\u310c' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x60 );\t\t/* '\u3125' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2200:\t/* '\u3115' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1C00 );\t/* '\u3112' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2000:\t/* '\u3114' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1A00 );\t/* '\u3111' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x50:\t/* '\u3123' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0xE00 );\t/* '\u310b' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x48:\t/* '\u3122' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x600 );\t/* '\u3107' */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* phrase */\n\telse {\n\t\tif ( pai->avail[ pai->currentAvail ].id != -1 ) {\n\t\t\tGetPhraseFirst( pgdata, &tempPhrase, pai->avail[ pai->currentAvail ].id );\n\t\t\tdo {\n\t\t\t\tif ( ChoiceTheSame(\n\t\t\t\t\tpci,\n\t\t\t\t\ttempPhrase.phrase,\n\t\t\t\t\tlen * ueBytesFromChar( tempPhrase.phrase[0] ) ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tueStrNCpy( pci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\t\t\ttempPhrase.phrase, len, 1);\n\t\t\t\tpci->nTotalChoice++;\n\t\t\t} while( GetPhraseNext( pgdata, &tempPhrase ) );\n\t\t}\n\n\t\tmemcpy( userPhoneSeq, &phoneSeq[ cursor ], sizeof( uint16_t ) * len );\n\t\tuserPhoneSeq[ len ] = 0;\n\t\tpUserPhraseData = UserGetPhraseFirst( pgdata, userPhoneSeq );\n\t\tif ( pUserPhraseData ) {\n\t\t\tdo {\n\t\t\t\t/* check if the phrase is already in the choice list */\n\t\t\t\tif ( ChoiceTheSame(\n\t\t\t\t\tpci,\n\t\t\t\t\tpUserPhraseData->wordSeq,\n\t\t\t\t\tlen * ueBytesFromChar( pUserPhraseData->wordSeq[0] ) ) )\n\t\t\t\t\tcontinue;\n\t\t\t\t/* otherwise store it */\n\t\t\t\tueStrNCpy(\n\t\t\t\t\t\tpci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\t\t\tpUserPhraseData->wordSeq,\n\t\t\t\t\t\tlen, 1);\n\t\t\t\tpci->nTotalChoice++;\n\t\t\t} while ( ( pUserPhraseData =\n\t\t\t\t    UserGetPhraseNext( pgdata, userPhoneSeq ) ) != NULL );\n\t\t}\n\n\t}\n\n\t/* magic number */\n\tpci->nChoicePerPage = candPerPage;\n\tassert( pci->nTotalChoice > 0 );\n\tpci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );\n\tpci->pageNo = 0;\n\tpci->isSymbol = WORD_CHOICE;\n}\n\n/*\n * Seek the start of the phrase (English characters",
        "begin_line": 187,
        "end_line": 331,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueBytesFromChar#42",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueBytesFromChar( unsigned char b )",
        "snippet": "int ueBytesFromChar( unsigned char b )\n{\n\treturn utf8len_tab[ b ];\n}",
        "begin_line": 42,
        "end_line": 45,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueConstStrSeek#69",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueConstStrSeek( const char *src, size_t n )",
        "snippet": "const char *ueConstStrSeek( const char *src, size_t n )\n{\n\tsize_t i = 0;\n\tconst char *iter = src;\n\tfor ( i = 0; i < n; i++ ) {\n\t\titer += ueBytesFromChar( iter[0] );\n\t}\n\treturn iter;\n}",
        "begin_line": 69,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueStrLen#29",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueStrLen( const char *str )",
        "snippet": "int ueStrLen( const char *str )\n{\n\tint length = 0;\n\tconst char *strptr = str;\n\n\twhile ( strptr[ 0 ] != '\\0' ) {\n\t\tstrptr += ueBytesFromChar( strptr[0] );\n\t\t++length;\n\t}\n\treturn length;\n}",
        "begin_line": 29,
        "end_line": 39,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueStrNBytes#48",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueStrNBytes( const char *str, int n )",
        "snippet": "int ueStrNBytes( const char *str, int n )\n{\n\tint i = 0, len = 0;\n\tconst char *iter = str;\n\tfor ( i = 0; i < n; i++ ) {\n\t\tlen += ueBytesFromChar( iter[ len ] );\n\t}\n\treturn len;\n}",
        "begin_line": 48,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueStrNCpy#59",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueStrNCpy( char dest[], const char *src, size_t n, int end )",
        "snippet": "int ueStrNCpy( char dest[], const char *src, size_t n, int end )\n{\n\tint len = 0;\n\tlen = ueStrNBytes( src, n );\n\tmemcpy( dest, src, len );\n\tif ( end == STRNCPY_CLOSE )\n\t\tdest[ len ] = '\\0';\n\treturn len;\n}",
        "begin_line": 59,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueStrSeek#79",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueStrSeek( char *src, size_t n )",
        "snippet": "char *ueStrSeek( char *src, size_t n )\n{\n\tsize_t i = 0;\n\tchar *iter = src;\n\tfor ( i = 0; i < n; i++ ) {\n\t\titer += ueBytesFromChar( iter[0] );\n\t}\n\treturn iter;\n}",
        "begin_line": 79,
        "end_line": 87,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.PhoneFromKey#126",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.PhoneFromKey( char *pho, const char *inputkey, int kbtype, int searchTimes )",
        "snippet": "int PhoneFromKey( char *pho, const char *inputkey, int kbtype, int searchTimes )\n{\n\tint len = strlen( inputkey ), i, s;\n\tconst char *pTarget;\n\n\tpho[ 0 ] = '\\0';\n\tfor ( i = 0; i < len; i++ ) {\n\t\tchar *findptr = NULL;\n\t\tint _index;\n\n\t\tfor (\n\t\t\t\ts = 0, pTarget = key_str[ kbtype ];\n\t\t\t\ts < searchTimes;\n\t\t\t\ts++, pTarget = findptr + 1 ) {\n\t\t\tfindptr = strchr( pTarget, inputkey[ i ] );\n\t\t\tif ( ! findptr ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t_index = findptr - key_str[ kbtype ];\n\t\tueStrNCpy( ueStrSeek( pho, i ),\n\t\t           ueConstStrSeek( ph_str, _index ),\n\t\t\t   1, 0);\n\t}\n\tpho = ueStrSeek( pho, len );\n\tpho[0] = '\\0';\n\treturn 1;\n}",
        "begin_line": 126,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.PhoneInxFromKey#177",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.PhoneInxFromKey( int key, int type, int kbtype, int searchTimes )",
        "snippet": "int PhoneInxFromKey( int key, int type, int kbtype, int searchTimes )\n{\n\tchar keyStr[ 2 ], rtStr[ 10 ], *p;\n\n\tkeyStr[ 0 ] = key;\n\tkeyStr[ 1 ] = '\\0';\n\tif ( ! PhoneFromKey( rtStr, keyStr, kbtype, searchTimes ) )\n\t\treturn 0;\n\tp = strstr( zhuin_tab[ type ], rtStr );\n\tif ( ! p )\n\t\treturn 0;\n\treturn zhuin_tab_num[type] - ueStrLen(p);\n}",
        "begin_line": 177,
        "end_line": 189,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.UintFromPhone#95",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.UintFromPhone( const char *zhuin )",
        "snippet": "uint16_t UintFromPhone( const char *zhuin )\n{\n\tconst char *iter;\n\tchar *pos;\n\tchar buf[ MAX_UTF8_SIZE + 1 ];\n\tint len, result = 0;\n\tint zhuin_index = 0;\n\n\titer = zhuin;\n\n\twhile ( *iter ) {\n\t\tlen = ueStrNCpy( buf, iter, 1, STRNCPY_CLOSE );\n\n\t\tfor (; zhuin_index < ZUIN_SIZE; ++zhuin_index ) {\n\t\t\tpos = strstr( zhuin_tab[ zhuin_index ], buf );\n\t\t\tif ( pos ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( zhuin_index >= ZUIN_SIZE ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tresult |= (zhuin_tab_num[ zhuin_index ] - ueStrLen( pos )) << shift[ zhuin_index ];\n\t\t++zhuin_index;\n\t\titer += len;\n\t}\n\treturn result;\n}",
        "begin_line": 95,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.UintFromPhoneInx#191",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.UintFromPhoneInx( const int ph_inx[] )",
        "snippet": "uint16_t UintFromPhoneInx( const int ph_inx[] )\n{\n\tint i;\n\tuint16_t result = 0;\n\n\tfor ( i = 0; i < ZUIN_SIZE; i++ )\n\t\tresult |= ph_inx[ i ] << shift[ i ];\n\treturn result;\n}",
        "begin_line": 191,
        "end_line": 199,
        "is_bug": false
    },
    {
        "name": "src.dict.GetPhraseFirst#164",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.GetPhraseFirst( ChewingData *pgdata, Phrase *phr_ptr, int phone_phr_id )",
        "snippet": "int GetPhraseFirst( ChewingData *pgdata, Phrase *phr_ptr, int phone_phr_id )\n{\n\tassert( ( 0 <= phone_phr_id ) && ( phone_phr_id < PHONE_PHRASE_NUM ) );\n\n#ifndef USE_BINARY_DATA\n\tfseek( pgdata->static_data.dictfile, pgdata->static_data.dict_begin[ phone_phr_id ], SEEK_SET );\n#else\n\tpgdata->static_data.dict_cur_pos = (unsigned char *)pgdata->static_data.dict + pgdata->static_data.dict_begin[ phone_phr_id ];\n#endif\n\tpgdata->static_data.dict_end_pos = pgdata->static_data.dict_begin[ phone_phr_id + 1 ];\n\tStr2Phrase( pgdata, phr_ptr );\n\treturn 1;\n}",
        "begin_line": 164,
        "end_line": 176,
        "is_bug": false
    },
    {
        "name": "src.dict.GetPhraseNext#178",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.GetPhraseNext( ChewingData *pgdata, Phrase *phr_ptr )",
        "snippet": "int GetPhraseNext( ChewingData *pgdata, Phrase *phr_ptr )\n{\n#ifndef USE_BINARY_DATA\n\tif ( ftell( pgdata->static_data.dictfile ) >= pgdata->static_data.dict_end_pos )\n\t\treturn 0;\n#else\n\tif ( (unsigned char *)pgdata->static_data.dict_cur_pos >= (unsigned char *)pgdata->static_data.dict + pgdata->static_data.dict_end_pos )\n\t\treturn 0;\n#endif\n\tStr2Phrase( pgdata, phr_ptr );\n\treturn 1;\n}",
        "begin_line": 178,
        "end_line": 189,
        "is_bug": false
    },
    {
        "name": "src.dict.InitDict#69",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.InitDict( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitDict( ChewingData *pgdata, const char *prefix )\n{\n#ifdef USE_BINARY_DATA\n\tchar filename[ PATH_MAX ];\n\tsize_t len;\n\tsize_t offset;\n\tsize_t file_size;\n\tsize_t csize;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, DICT_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tplat_mmap_set_invalid( &pgdata->static_data.dict_mmap );\n\tfile_size = plat_mmap_create( &pgdata->static_data.dict_mmap, filename, FLAG_ATTRIBUTE_READ );\n\tif ( file_size <= 0 )\n\t\treturn -1;\n\n\toffset = 0;\n\tcsize = file_size;\n\tpgdata->static_data.dict = plat_mmap_set_view( &pgdata->static_data.dict_mmap, &offset, &csize );\n\tif ( !pgdata->static_data.dict )\n\t\treturn -1;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, PH_INDEX_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tplat_mmap_set_invalid( &pgdata->static_data.index_mmap );\n\tfile_size = plat_mmap_create( &pgdata->static_data.index_mmap, filename, FLAG_ATTRIBUTE_READ );\n\tif ( file_size <= 0 )\n\t\treturn -1;\n\n\toffset = 0;\n\tcsize = file_size;\n\tpgdata->static_data.dict_begin = plat_mmap_set_view( &pgdata->static_data.index_mmap, &offset, &csize );\n\tif ( !pgdata->static_data.dict_begin )\n\t\treturn -1;\n\n\treturn 0;\n#else\n\tchar filename[ PATH_MAX ];\n\tFILE *indexfile;\n\tint len;\n\tint i;\n\n\tpgdata->static_data.dict_begin = ALC( int, PHONE_PHRASE_NUM + 1 );\n\tif ( !pgdata->static_data.dict_begin )\n\t\treturn -1;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, DICT_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tpgdata->static_data.dictfile = fopen( filename, \"r\" );\n\tif ( !pgdata->static_data.dictfile )\n\t\treturn -1;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, PH_INDEX_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tindexfile = fopen( filename, \"r\" );\n\tif ( !indexfile )\n\t\treturn -1;\n\n\ti = 0;\n\t/* FIXME: check if begin is big enough to store all data. */\n\twhile ( !feof( indexfile ) )\n\t\tfscanf( indexfile, \"%d\", &pgdata->static_data.dict_begin[ i++ ] );\n\tfclose( indexfile );\n\n\treturn 0;\n#endif\n}",
        "begin_line": 69,
        "end_line": 143,
        "is_bug": false
    },
    {
        "name": "src.dict.Str2Phrase#145",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.Str2Phrase( ChewingData *pgdata, Phrase *phr_ptr )",
        "snippet": "static void Str2Phrase( ChewingData *pgdata, Phrase *phr_ptr )\n{\n#ifndef USE_BINARY_DATA\n\tchar buf[ 1000 ];\n\n\tfgettab( buf, 1000, pgdata->static_data.dictfile );\n\tsscanf( buf, \"%[^ ] %d\", phr_ptr->phrase, &( phr_ptr->freq ) );\n#else\n\tunsigned char size;\n\tsize = *(unsigned char *) pgdata->static_data.dict_cur_pos;\n\tpgdata->static_data.dict_cur_pos = (unsigned char *)pgdata->static_data.dict_cur_pos + sizeof(unsigned char);\n\tmemcpy( phr_ptr->phrase, pgdata->static_data.dict_cur_pos, size );\n\tpgdata->static_data.dict_cur_pos = (unsigned char *)pgdata->static_data.dict_cur_pos + size;\n\tphr_ptr->freq = GetInt32(pgdata->static_data.dict_cur_pos);\n\tpgdata->static_data.dict_cur_pos = (unsigned char *)pgdata->static_data.dict_cur_pos + sizeof(int);\n\tphr_ptr->phrase[ size ] = '\\0';\n#endif\n}",
        "begin_line": 145,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "src.dict.TerminateDict#54",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.TerminateDict( ChewingData *pgdata )",
        "snippet": "void TerminateDict( ChewingData *pgdata )\n{\n#ifdef USE_BINARY_DATA\n\tplat_mmap_close( &pgdata->static_data.index_mmap );\n\tplat_mmap_close( &pgdata->static_data.dict_mmap );\n#else\n\tif ( pgdata->static_data.dictfile ) {\n\t\tfclose( pgdata->static_data.dictfile );\n\t\tpgdata->static_data.dictfile = NULL;\n\t}\n\tfree( pgdata->static_data.dict_begin );\n\tpgdata->static_data.dict_begin = NULL;\n#endif\n}",
        "begin_line": 54,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "src.hash.AlcUserPhraseSeq#28",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.AlcUserPhraseSeq( UserPhraseData *pData, int phonelen, int wordlen )",
        "snippet": "int AlcUserPhraseSeq( UserPhraseData *pData, int phonelen, int wordlen )\n{\n\tpData->phoneSeq = ALC( uint16_t, phonelen + 1 );\n\tif ( !pData->phoneSeq )\n\t\tgoto error;\n\tpData->wordSeq = ALC( char, wordlen + 1 );\n\tif ( !pData->wordSeq )\n\t\tgoto error;\n\n\treturn 1;\n\nerror:\n\tfree( pData->phoneSeq );\n\tfree( pData->wordSeq );\n\treturn 0;\n}",
        "begin_line": 28,
        "end_line": 43,
        "is_bug": false
    },
    {
        "name": "src.hash.FreeHashItem#446",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.FreeHashItem( HASH_ITEM *aItem )",
        "snippet": "static void FreeHashItem( HASH_ITEM *aItem )\n{\n\tif ( aItem ) {\n\t\tHASH_ITEM *pItem = aItem->next;\n\t\tfree( aItem->data.phoneSeq );\n\t\tfree( aItem->data.wordSeq );\n\t\tfree( aItem );\n\t\tif ( pItem ) {\n\t\t\tFreeHashItem( pItem );\n\t\t}\n\t}\n}",
        "begin_line": 446,
        "end_line": 457,
        "is_bug": false
    },
    {
        "name": "src.hash.HashFindEntry#81",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashFindEntry( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )",
        "snippet": "HASH_ITEM *HashFindEntry( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )\n{\n\tHASH_ITEM *pItem;\n\tint hashvalue;\n\n\thashvalue = HashFunc( phoneSeq );\n\n\tfor ( pItem = pgdata->static_data.hashtable[ hashvalue ]; pItem ; pItem = pItem->next ) {\n\t\tif (\n\t\t\t! strcmp( pItem->data.wordSeq, wordSeq ) &&\n\t\t\tPhoneSeqTheSame( pItem->data.phoneSeq, phoneSeq ) ) {\n\t\t\treturn pItem;\n\t\t}\n\t}\n\treturn NULL;\n}",
        "begin_line": 81,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "src.hash.HashFindPhonePhrase#69",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashFindPhonePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], HASH_ITEM *pItemLast )",
        "snippet": "HASH_ITEM *HashFindPhonePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], HASH_ITEM *pItemLast )\n{\n\tHASH_ITEM *pNow = pItemLast ?\n\t\t\tpItemLast->next :\n\t\t\tpgdata->static_data.hashtable[ HashFunc( phoneSeq ) ];\n\n\tfor ( ; pNow; pNow = pNow->next )\n\t\tif ( PhoneSeqTheSame( pNow->data.phoneSeq, phoneSeq ) )\n\t\t\treturn pNow;\n\treturn NULL;\n}",
        "begin_line": 69,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "src.hash.HashFunc#60",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashFunc( const uint16_t phoneSeq[] )",
        "snippet": "static unsigned int HashFunc( const uint16_t phoneSeq[] )\n{\n\tint i, value = 0;\n\n\tfor ( i = 0; phoneSeq[ i ] != 0; i++ )\n\t\tvalue ^= phoneSeq[ i ];\n\treturn ( value & ( HASH_TABLE_SIZE - 1 ) );\n}",
        "begin_line": 60,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "src.hash.HashInsert#98",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashInsert( ChewingData *pgdata, UserPhraseData *pData )",
        "snippet": "HASH_ITEM *HashInsert( ChewingData *pgdata, UserPhraseData *pData )\n{\n\tint hashvalue;\n\tHASH_ITEM *pItem;\n\n\tpItem = HashFindEntry( pgdata, pData->phoneSeq, pData->wordSeq );\n\tif ( pItem != NULL )\n\t\treturn pItem;\n\n\tpItem = ALC( HASH_ITEM, 1 );\n\tif ( ! pItem )\n\t\treturn NULL;  /* Error occurs */\n\n\thashvalue = HashFunc( pData->phoneSeq );\n\t/* set the new element */\n\tpItem->next = pgdata->static_data.hashtable[ hashvalue ];\n\n\tmemcpy( &( pItem->data ), pData, sizeof( pItem->data ) );\n\tpItem->item_index = -1;\n\n\t/* set link to the new element */\n\tpgdata->static_data.hashtable[ hashvalue ] = pItem;\n\n\treturn pItem;\n}",
        "begin_line": 98,
        "end_line": 122,
        "is_bug": false
    },
    {
        "name": "src.hash.HashItem2Binary#145",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashItem2Binary( char *str, HASH_ITEM *pItem )",
        "snippet": "static void HashItem2Binary( char *str, HASH_ITEM *pItem )\n{\n\tint i, phraselen;\n\tchar *pc;\n\n\tmemset( str, 0, FIELD_SIZE );\n\tif ( sizeof(int) * 4 + ueStrLen( pItem->data.wordSeq ) * 2 +\n\t     strlen( pItem->data.wordSeq ) >= FIELD_SIZE ) {\n\t\t/* exceed buffer size */\n\t\treturn;\n\t}\n\n\t/* freq info */\n\tPutInt32( pItem->data.userfreq, &str[ 0 ] );\n\tPutInt32( pItem->data.recentTime, &str[ 4 ] );\n\tPutInt32( pItem->data.maxfreq, &str[ 8 ] );\n\tPutInt32( pItem->data.origfreq, &str[ 12 ] );\n\n\t/* phone seq*/\n\tphraselen = ueStrLen( pItem->data.wordSeq );\n\tstr[ 16 ] = phraselen;\n\tpc = &str[ 17 ];\n\tfor ( i = 0; i < phraselen; i++ ) {\n\t\tPutUint16( pItem->data.phoneSeq[ i ], pc );\n\t\tpc += 2;\n\t}\n\n\t/* phrase */\n\t*pc = strlen( pItem->data.wordSeq );\n\tstrcpy( (pc + 1), pItem->data.wordSeq );\n\tpItem->data.wordSeq[ (unsigned char) *pc ] = '\\0';\n}",
        "begin_line": 145,
        "end_line": 176,
        "is_bug": false
    },
    {
        "name": "src.hash.HashItem2String#124",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashItem2String( char *str, HASH_ITEM *pItem )",
        "snippet": "static void HashItem2String( char *str, HASH_ITEM *pItem )\n{\n\tint i, len;\n\tchar buf[ FIELD_SIZE ];\n\n\tsprintf( str, \"%s \", pItem->data.wordSeq );\n\tlen = ueStrLen( pItem->data.wordSeq );\n\tfor ( i = 0; i < len; i++ ) {\n\t\tsprintf( buf, \"%hu \", pItem->data.phoneSeq[ i ] );\n\t\tstrcat( str, buf );\n\t}\n\tsprintf(\n\t\tbuf, \"%d %d %d %d\",\n\t\tpItem->data.userfreq, pItem->data.recentTime,\n\t\tpItem->data.maxfreq, pItem->data.origfreq );\n\tstrcat( str, buf );\n}",
        "begin_line": 124,
        "end_line": 140,
        "is_bug": false
    },
    {
        "name": "src.hash.HashModify#178",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashModify( ChewingData *pgdata, HASH_ITEM *pItem )",
        "snippet": "void HashModify( ChewingData *pgdata, HASH_ITEM *pItem )\n{\n\tFILE *outfile;\n\tchar str[ FIELD_SIZE + 1 ];\n\n\toutfile = fopen( pgdata->static_data.hashfilename, \"r+b\" );\n\tif ( !outfile )\n\t\treturn;\n\n\t/* update \"lifetime\" */\n\tfseek( outfile, strlen( BIN_HASH_SIG ), SEEK_SET );\n\tfwrite( &pgdata->static_data.chewing_lifetime, 1, 4, outfile );\n\tsprintf( str, \"%d\", pgdata->static_data.chewing_lifetime );\n\tDEBUG_OUT( \"HashModify-1: '%-75s'\\n\", str );\n\n\t/* update record */\n\tif ( pItem->item_index < 0 ) {\n\t\tfseek( outfile, 0, SEEK_END );\n\t\tpItem->item_index =\n\t\t\t( ftell( outfile ) - 4 - strlen( BIN_HASH_SIG ) ) / FIELD_SIZE;\n\t}\n\telse {\n\t\tfseek( outfile,\n\t\t\tpItem->item_index * FIELD_SIZE + 4 + strlen( BIN_HASH_SIG ),\n\t\t\tSEEK_SET );\n\t}\n\n\tHashItem2String( str, pItem );\n\tDEBUG_OUT( \"HashModify-2: '%-75s'\\n\", str );\n\n\tHashItem2Binary( str, pItem );\n\tfwrite( str, 1, FIELD_SIZE, outfile );\n\tfflush( outfile );\n\tfclose( outfile );\n}",
        "begin_line": 178,
        "end_line": 212,
        "is_bug": false
    },
    {
        "name": "src.hash.InitHash#470",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.InitHash( ChewingData *pgdata )",
        "snippet": "int InitHash( ChewingData *pgdata )\n{\n\tHASH_ITEM item, *pItem, *pPool = NULL;\n\tint item_index, hashvalue, iret, fsize, hdrlen, oldest = INT_MAX;\n\tchar *dump, *seekdump;\n\n\tconst char *path = getenv( \"CHEWING_USER_PATH\" );\n\n\t/* make sure of write permission */\n\tif ( path && access( path, W_OK ) == 0 ) {\n\t\tsprintf( pgdata->static_data.hashfilename, \"%s\" PLAT_SEPARATOR \"%s\", path, HASH_FILE );\n\t} else {\n\t\tif ( getenv( \"HOME\" ) ) {\n\t\t\tsprintf(\n\t\t\t\tpgdata->static_data.hashfilename, \"%s%s\",\n\t\t\t\tgetenv( \"HOME\" ), CHEWING_HASH_PATH );\n\t\t}\n\t\telse {\n\t\t\tsprintf(\n\t\t\t\tpgdata->static_data.hashfilename, \"%s%s\",\n\t\t\t\tPLAT_TMPDIR, CHEWING_HASH_PATH );\n\t\t}\n\t\tPLAT_MKDIR( pgdata->static_data.hashfilename );\n\t\tstrcat( pgdata->static_data.hashfilename, PLAT_SEPARATOR );\n\t\tstrcat( pgdata->static_data.hashfilename, HASH_FILE );\n\t}\n\tmemset( pgdata->static_data.hashtable, 0, sizeof( pgdata->static_data.hashtable ) );\n\nopen_hash_file:\n\tdump = _load_hash_file( pgdata->static_data.hashfilename, &fsize );\n\thdrlen = strlen( BIN_HASH_SIG ) + sizeof(pgdata->static_data.chewing_lifetime);\n\titem_index = 0;\n\tif ( dump == NULL || fsize < hdrlen ) {\n\t\tFILE *outfile;\n\t\toutfile = fopen( pgdata->static_data.hashfilename, \"w+b\" );\n\t\tif ( ! outfile ) {\n\t\t\tif ( dump ) {\n\t\t\t\tfree( dump );\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tpgdata->static_data.chewing_lifetime = 0;\n\t\tfwrite( BIN_HASH_SIG, 1, strlen( BIN_HASH_SIG ), outfile );\n\t\tfwrite( &pgdata->static_data.chewing_lifetime, 1,\n\t\t                sizeof(pgdata->static_data.chewing_lifetime), outfile );\n\t\tfclose( outfile );\n\t}\n\telse {\n\t\tif ( memcmp(dump, BIN_HASH_SIG, strlen(BIN_HASH_SIG)) != 0 ) {\n\t\t\t/* perform migrate from text-based to binary form */\n\t\t\tfree( dump );\n\t\t\tif ( ! migrate_hash_to_bin( pgdata ) ) {\n\t\t\t\treturn  0;\n\t\t\t}\n\t\t\tgoto open_hash_file;\n\t\t}\n\n\t\tpgdata->static_data.chewing_lifetime = *(int *) (dump + strlen( BIN_HASH_SIG ));\n\t\tseekdump = dump + hdrlen;\n\t\tfsize -= hdrlen;\n\n\t\twhile ( fsize >= FIELD_SIZE ) {\n\t\t\tiret = ReadHashItem_bin( seekdump, &item, item_index++ );\n\t\t\t/* Ignore illegal data */\n\t\t\tif ( iret == -1 ) {\n\t\t\t\tseekdump += FIELD_SIZE;\n\t\t\t\tfsize -= FIELD_SIZE;\n\t\t\t\t--item_index;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( iret == 0 )\n\t\t\t\tbreak;\n\n\t\t\tpItem = ALC( HASH_ITEM, 1 );\n\t\t\tmemcpy( pItem, &item, sizeof( HASH_ITEM ) );\n\t\t\tpItem->next = pPool;\n\t\t\tpPool = pItem;\n\n\t\t\tif ( oldest > pItem->data.recentTime ) {\n\t\t\t\toldest = pItem->data.recentTime;\n\t\t\t}\n\n\t\t\tseekdump += FIELD_SIZE;\n\t\t\tfsize -= FIELD_SIZE;\n\t\t}\n\t\tfree( dump );\n\n\t\twhile ( pPool ) {\n\t\t\tpItem = pPool;\n\t\t\tpPool = pItem->next;\n\n\t\t\thashvalue = HashFunc( pItem->data.phoneSeq );\n\t\t\tpItem->next = pgdata->static_data.hashtable[ hashvalue ];\n\t\t\tpgdata->static_data.hashtable[ hashvalue ] = pItem;\n\t\t\tpItem->data.recentTime -= oldest;\n\t\t}\n\t\tpgdata->static_data.chewing_lifetime -= oldest;\n\t}\n\treturn 1;\n}",
        "begin_line": 470,
        "end_line": 569,
        "is_bug": false
    },
    {
        "name": "src.hash.PhoneSeqTheSame#45",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.PhoneSeqTheSame( const uint16_t p1[], const uint16_t p2[] )",
        "snippet": "static int PhoneSeqTheSame( const uint16_t p1[], const uint16_t p2[] )\n{\n\tint i;\n\tif ( ! p1 || ! p2 )\t/* FIXME: should not happend. */\n\t\treturn 0;\n\n\tfor ( i = 0; ( p1[ i ] != 0 && p2[ i ] != 0 ); i++ ) {\n\t\tif ( p1[ i ] != p2[ i ] )\n\t\t\treturn 0;\n\t}\n\tif ( p1[ i ] != p2[ i ] )\n\t\treturn 0;\n\treturn 1;\n}",
        "begin_line": 45,
        "end_line": 58,
        "is_bug": false
    },
    {
        "name": "src.hash.ReadHashItem_bin#235",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.ReadHashItem_bin( const char *srcbuf, HASH_ITEM *pItem, int item_index )",
        "snippet": "static int ReadHashItem_bin( const char *srcbuf, HASH_ITEM *pItem, int item_index )\n{\n\tint len, i;\n\tconst char *pc;\n\n\tmemset( pItem, 0, sizeof(HASH_ITEM) );\n\n\t/* freq info */\n\tpItem->data.userfreq\t= GetInt32(&srcbuf[ 0 ]);\n\tpItem->data.recentTime\t= GetInt32(&srcbuf[ 4 ]);\n\tpItem->data.maxfreq\t= GetInt32(&srcbuf[ 8 ]);\n\tpItem->data.origfreq\t= GetInt32(&srcbuf[ 12 ]);\n\n\t/* phone seq, length in num of chi words */\n\tlen = (int) srcbuf[ 16 ];\n\tpItem->data.phoneSeq = ALC( uint16_t, len + 1 );\n\tpc = &srcbuf[ 17 ];\n\tfor ( i = 0; i < len; i++ ) {\n\t\tpItem->data.phoneSeq[ i ] = GetUint16( pc );\n\t\tpc += 2;\n\t}\n\tpItem->data.phoneSeq[ i ] = 0;\n\n\t/* phrase, length in num of bytes */\n\tpItem->data.wordSeq = ALC( char, (*pc) + 1 );\n\tstrcpy( pItem->data.wordSeq, (char *) (pc + 1) );\n\tpItem->data.wordSeq[ (unsigned int) *pc ] = '\\0';\n\n\t/* Invalid UTF-8 Chinese characters found */\n\tif ( ! isValidChineseString( pItem->data.wordSeq ) ) {\n\t\tgoto ignore_corrupted_record;\n\t}\n\n\t/* set item_index */\n\tpItem->item_index = item_index;\n\n\treturn 1; /* continue */\n\nignore_corrupted_record:\n\tif ( pItem->data.phoneSeq != NULL ) {\n\t\tfree( pItem->data.phoneSeq );\n\t\tpItem->data.phoneSeq = NULL;\n\t}\n\tif ( pItem->data.wordSeq != NULL ) {\n\t\tfree( pItem->data.wordSeq );\n\t\tpItem->data.wordSeq = NULL;\n\t}\n\treturn -1; /* ignore */\n}",
        "begin_line": 235,
        "end_line": 283,
        "is_bug": false
    },
    {
        "name": "src.hash.TerminateHash#459",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.TerminateHash( ChewingData *pgdata )",
        "snippet": "void TerminateHash( ChewingData *pgdata )\n{\n\tHASH_ITEM *pItem;\n\tint i;\n\tfor ( i = 0; i < HASH_TABLE_SIZE; ++i ) {\n\t\tpItem = pgdata->static_data.hashtable[ i ];\n\t\tDEBUG_CHECKPOINT();\n\t\tFreeHashItem( pItem );\n\t}\n}",
        "begin_line": 459,
        "end_line": 468,
        "is_bug": false
    },
    {
        "name": "src.hash._load_hash_file#346",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash._load_hash_file( const char *filename, int *size )",
        "snippet": "static char *_load_hash_file( const char *filename, int *size )\n{\n\tint flen;\n\tchar *pd = NULL;\n\tFILE *tf;\n\n\ttf = open_file_get_length( filename, \"rb\", &flen );\n\tif ( tf == NULL ) {\n\t\tgoto err_load_file;\n\t}\n\tpd = ALC( char, flen );\n\tif ( pd == NULL ) {\n\t\tgoto err_load_file;\n\t}\n\tif ( fread( pd, flen, 1, tf ) != 1 ) {\n\t\tgoto err_load_file;\n\t}\n\tfclose( tf );\n\tif ( size != NULL )\n\t\t*size = flen;\n\treturn pd;\n\nerr_load_file:\n\tif ( pd != NULL )\n\t\tfree( pd );\n\tif ( tf != NULL )\n\t\tfclose( tf );\n\treturn NULL;\n}",
        "begin_line": 346,
        "end_line": 374,
        "is_bug": false
    },
    {
        "name": "src.hash.isValidChineseString#214",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.isValidChineseString( char *str )",
        "snippet": "static int isValidChineseString( char *str )\n{\n\tif ( str == NULL || *str == '\\0' ) {\n\t\treturn 0;\n\t}\n\twhile ( *str != '\\0' )  {\n\t\tint len = ueBytesFromChar( (unsigned char) *str );\n\t\tif ( len <= 1 ) {\n\t\t\treturn 0;\n\t\t}\n\t\tstr += len;\n\t};\n\treturn 1;\n}",
        "begin_line": 214,
        "end_line": 227,
        "is_bug": false
    },
    {
        "name": "src.hash.open_file_get_length#330",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.open_file_get_length( \t\tconst char *filename, const char *otype, int *size)",
        "snippet": "static FILE *open_file_get_length(\n\t\tconst char *filename,\n\t\tconst char *otype, int *size)\n{\n\tFILE *tf = fopen( filename, otype );\n\tif ( tf == NULL ) {\n\t\treturn NULL;\n\t}\n\tif ( size != NULL ) {\n\t\tfseek( tf, 0, SEEK_END );\n\t\t*size = ftell( tf );\n\t\tfseek( tf, 0, SEEK_SET );\n\t}\n\treturn tf;\n}",
        "begin_line": 330,
        "end_line": 344,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_buffer_Check#53",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_buffer_Check( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_buffer_Check( ChewingContext *ctx )\n{\n\treturn (ctx->output->chiSymbolBufLen != 0);\n}",
        "begin_line": 53,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_buffer_Len#58",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_buffer_Len( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_buffer_Len( ChewingContext *ctx )\n{\n\treturn ctx->output->chiSymbolBufLen;\n}",
        "begin_line": 58,
        "end_line": 61,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_buffer_String#63",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_buffer_String( ChewingContext *ctx )",
        "snippet": "CHEWING_API char *chewing_buffer_String( ChewingContext *ctx )\n{\n\tint i;\n\tchar *s = (char *) calloc(\n\t\t1 + ctx->output->chiSymbolBufLen,\n\t\tMAX_UTF8_SIZE );\n\tif ( s ) {\n\t\tfor ( i = 0; i < ctx->output->chiSymbolBufLen; i++ ) {\n\t\t\tstrcat( s, (char *) (ctx->output->chiSymbolBuf[ i ].s) );\n\t\t}\n\t}\n\treturn s;\n}",
        "begin_line": 63,
        "end_line": 75,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_Enumerate#146",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_Enumerate( ChewingContext *ctx )",
        "snippet": "CHEWING_API void chewing_cand_Enumerate( ChewingContext *ctx )\n{\n\tctx->cand_no = ctx->output->pci->pageNo * ctx->output->pci->nChoicePerPage;\n}",
        "begin_line": 146,
        "end_line": 149,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_String#156",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_String( ChewingContext *ctx )",
        "snippet": "CHEWING_API char *chewing_cand_String( ChewingContext *ctx )\n{\n\tchar *s;\n\tif ( chewing_cand_hasNext( ctx ) ) {\n\t\ts = strdup( ctx->output->pci->totalChoiceStr[ ctx->cand_no ] );\n\t\tctx->cand_no++;\n\t} else {\n\t\ts = strdup( \"\" );\n\t}\n\treturn s;\n}",
        "begin_line": 156,
        "end_line": 166,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_hasNext#151",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_hasNext( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_cand_hasNext( ChewingContext *ctx )\n{\n\treturn (ctx->cand_no < ctx->output->pci->nTotalChoice);\n}",
        "begin_line": 151,
        "end_line": 154,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_commit_Check#28",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_commit_Check( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_commit_Check( ChewingContext *ctx )\n{\n\treturn !!(ctx->output->keystrokeRtn & KEYSTROKE_COMMIT);\n}",
        "begin_line": 28,
        "end_line": 31,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_commit_String#39",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_commit_String( ChewingContext *ctx )",
        "snippet": "CHEWING_API char *chewing_commit_String( ChewingContext *ctx )\n{\n\tint i;\n\tchar *s = (char *) calloc(\n\t\t1 + ctx->output->nCommitStr,\n\t\tMAX_UTF8_SIZE );\n\tif ( s ) {\n\t\tfor ( i = 0; i < ctx->output->nCommitStr; i++ ) {\n\t\t\tstrcat( s, (char *) (ctx->output->commitStr[ i ].s) );\n\t\t}\n\t}\n\treturn s;\n}",
        "begin_line": 39,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cursor_Current#116",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cursor_Current( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_cursor_Current( ChewingContext *ctx )\n{\n\treturn (ctx->output->chiSymbolCursor);\n}",
        "begin_line": 116,
        "end_line": 119,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_interval_Enumerate#168",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_interval_Enumerate( ChewingContext *ctx )",
        "snippet": "CHEWING_API void chewing_interval_Enumerate( ChewingContext *ctx )\n{\n\tctx->it_no = 0;\n}",
        "begin_line": 168,
        "end_line": 171,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_interval_Get#178",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_interval_Get( ChewingContext *ctx, IntervalType *it )",
        "snippet": "CHEWING_API void chewing_interval_Get( ChewingContext *ctx, IntervalType *it )\n{\n\tif ( chewing_interval_hasNext( ctx ) ) {\n\t\tif ( it ) {\n\t\t\tit->from = ctx->output->dispInterval[ ctx->it_no ].from;\n\t\t\tit->to = ctx->output->dispInterval[ ctx->it_no ].to;\n\t\t}\n\t\tctx->it_no++;\n\t}\n}",
        "begin_line": 178,
        "end_line": 187,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_interval_hasNext#173",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_interval_hasNext( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_interval_hasNext( ChewingContext *ctx )\n{\n\treturn (ctx->it_no < ctx->output->nDispInterval);\n}",
        "begin_line": 173,
        "end_line": 176,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_keystroke_CheckAbsorb#218",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_keystroke_CheckAbsorb( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_keystroke_CheckAbsorb( ChewingContext *ctx )\n{\n\treturn !!(ctx->output->keystrokeRtn & KEYSTROKE_ABSORB);\n}",
        "begin_line": 218,
        "end_line": 221,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_keystroke_CheckIgnore#213",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_keystroke_CheckIgnore( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_keystroke_CheckIgnore( ChewingContext *ctx )\n{\n\treturn !!(ctx->output->keystrokeRtn & KEYSTROKE_IGNORE);\n}",
        "begin_line": 213,
        "end_line": 216,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_zuin_Check#104",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_zuin_Check( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_zuin_Check( ChewingContext *ctx )\n{\n\tint i;\n\n\tfor ( i = 0; i < ZUIN_SIZE; ++i ) {\n\t\tif ( ctx->output->zuinBuf[ i ].s[ 0 ] != '\\0' ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
        "begin_line": 104,
        "end_line": 114,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_zuin_String#83",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_zuin_String( ChewingContext *ctx, int *zuin_count )",
        "snippet": "CHEWING_API char *chewing_zuin_String( ChewingContext *ctx, int *zuin_count )\n{\n\tchar *s;\n\tint i;\n\tif ( zuin_count )\n\t\t*zuin_count = 0;\n\ts = (char*) calloc(\n\t\t1 + ZUIN_SIZE,\n\t\tsizeof(ctx->output->zuinBuf[ 0 ].s) );\n\tif ( s ) {\n\t\tfor ( i = 0; i < ZUIN_SIZE; i++ ) {\n\t\t\tif ( ctx->output->zuinBuf[ i ].s[ 0 ] != '\\0' ) {\n\t\t\t\tstrcat( s, (char *) (ctx->output->zuinBuf[ i ].s) );\n\t\t\t\tif ( zuin_count )\n\t\t\t\t\t(*zuin_count)++;\n\t\t\t}\n\t\t}\n\t}\n\treturn s;\n}",
        "begin_line": 83,
        "end_line": 102,
        "is_bug": false
    },
    {
        "name": "src.pinyin.InitPinyin#29",
        "src_path": "src/pinyin.c",
        "class_name": "src.pinyin",
        "signature": "src.pinyin.InitPinyin( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitPinyin( ChewingData *pgdata, const char *prefix )\n{\n\tchar filename[ PATH_MAX ];\n\tint i;\n\tFILE *fd;\n\tint ret;\n\n\tsprintf( filename,\n\t\t\"%s\" PLAT_SEPARATOR \"%s\",\n\t\tprefix, PINYIN_TAB_NAME );\n\n\tfd = fopen(filename, \"r\");\n\n\tif ( ! fd )\n\t\treturn 0;\n\n\tret = fscanf( fd, \"%d\", &pgdata->static_data.HANYU_INITIALS );\n\tif ( ret != 1 ) {\n\t\treturn 0;\n\t}\n\t++pgdata->static_data.HANYU_INITIALS;\n\tpgdata->static_data.hanyuInitialsMap = ALC( keymap, pgdata->static_data.HANYU_INITIALS );\n\tfor ( i = 0; i < pgdata->static_data.HANYU_INITIALS - 1; i++ ) {\n\t\tret = fscanf( fd, \"%s %s\",\n\t\t\tpgdata->static_data.hanyuInitialsMap[ i ].pinyin,\n\t\t\tpgdata->static_data.hanyuInitialsMap[ i ].zuin );\n\t\tif ( ret != 2 ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = fscanf( fd, \"%d\", &pgdata->static_data.HANYU_FINALS );\n\tif ( ret != 1 ) {\n\t\treturn 0;\n\t}\n\t++pgdata->static_data.HANYU_FINALS;\n\tpgdata->static_data.hanyuFinalsMap = ALC( keymap, pgdata->static_data.HANYU_FINALS );\n\tfor ( i = 0; i < pgdata->static_data.HANYU_FINALS - 1; i++ ) {\n\t\tret = fscanf( fd, \"%s %s\",\n\t\t\tpgdata->static_data.hanyuFinalsMap[ i ].pinyin,\n\t\t\tpgdata->static_data.hanyuFinalsMap[ i ].zuin );\n\t\tif ( ret != 2 ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfclose( fd );\n\n\treturn 1;\n}",
        "begin_line": 29,
        "end_line": 78,
        "is_bug": false
    },
    {
        "name": "src.pinyin.TerminatePinyin#23",
        "src_path": "src/pinyin.c",
        "class_name": "src.pinyin",
        "signature": "src.pinyin.TerminatePinyin( ChewingData *pgdata )",
        "snippet": "void TerminatePinyin( ChewingData *pgdata )\n{\n\tfree( pgdata->static_data.hanyuInitialsMap );\n\tfree( pgdata->static_data.hanyuFinalsMap );\n}",
        "begin_line": 23,
        "end_line": 27,
        "is_bug": false
    },
    {
        "name": "src.porting_layer.src.plat_path.are_all_files_readable#130",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "src.porting_layer.src.plat_path",
        "signature": "src.porting_layer.src.plat_path.are_all_files_readable( \tconst char *path, const char * const *files, char *output, size_t output_len )",
        "snippet": "static int are_all_files_readable(\n\tconst char *path,\n\tconst char * const *files,\n\tchar *output,\n\tsize_t output_len )\n{\n\tint i;\n\n\tassert( path );\n\tassert( files );\n\n\tfor ( i = 0; files[i] != NULL; ++i ) {\n\t\tsnprintf( output, output_len, \"%s\" PLAT_SEPARATOR \"%s\", path,\n\t\t\t\tfiles[i] );\n\t\tif ( access( output, R_OK ) != 0 ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
        "begin_line": 130,
        "end_line": 150,
        "is_bug": false
    },
    {
        "name": "src.porting_layer.src.plat_path.find_path_by_files#152",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "src.porting_layer.src.plat_path",
        "signature": "src.porting_layer.src.plat_path.find_path_by_files( \tconst char *search_path, const char * const *files, char *output, size_t output_len )",
        "snippet": "int find_path_by_files(\n\tconst char *search_path,\n\tconst char * const *files,\n\tchar *output,\n\tsize_t output_len )\n{\n\tchar buffer[PATH_MAX];\n\tchar *path;\n\tchar *saveptr;\n\tint ret;\n\n\tassert( search_path );\n\tassert( files );\n\tassert( output );\n\tassert( output_len );\n\n\t// strtok_r will modify its first parameter.\n\tstrncpy( buffer, search_path, sizeof( buffer ) );\n\n\tfor ( path = strtok_r( buffer, SEARCH_PATH_SEP, &saveptr );\n\t\tpath; path = strtok_r( NULL, SEARCH_PATH_SEP, &saveptr ) ) {\n\n\t\tret = are_all_files_readable( path, files, output, output_len );\n\t\tif ( ret ) {\n\t\t\tsnprintf( output, output_len, \"%s\", path );\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}",
        "begin_line": 152,
        "end_line": 181,
        "is_bug": false
    },
    {
        "name": "src.tree.AddInterval#312",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.AddInterval( \t\tTreeDataType *ptd, int begin, int end, int p_id, Phrase *p_phrase, int dict_or_user )",
        "snippet": "static void AddInterval(\n\t\tTreeDataType *ptd, int begin , int end,\n\t\tint p_id, Phrase *p_phrase, int dict_or_user )\n{\n\tptd->interval[ ptd->nInterval ].from = begin;\n\tptd->interval[ ptd->nInterval ].to = end + 1;\n\tptd->interval[ ptd->nInterval ].pho_id = p_id;\n\tptd->interval[ ptd->nInterval ].p_phr = p_phrase;\n\tptd->interval[ ptd->nInterval ].source = dict_or_user;\n\tptd->nInterval++;\n}",
        "begin_line": 312,
        "end_line": 322,
        "is_bug": false
    },
    {
        "name": "src.tree.CheckBreakpoint#148",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CheckBreakpoint( int from, int to, int bArrBrkpt[] )",
        "snippet": "static int CheckBreakpoint( int from, int to, int bArrBrkpt[] )\n{\n\tint i;\n\tfor ( i = from + 1; i < to; i++ )\n\t\tif ( bArrBrkpt[ i ] )\n\t\t\treturn 0;\n\treturn 1;\n}",
        "begin_line": 148,
        "end_line": 155,
        "is_bug": false
    },
    {
        "name": "src.tree.CheckChoose#235",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CheckChoose( \t\tChewingData *pgdata, int ph_id, int from, int to, Phrase **pp_phr, char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ], IntervalType selectInterval[], int nSelect )",
        "snippet": "static int CheckChoose(\n\t\tChewingData *pgdata,\n\t\tint ph_id, int from, int to, Phrase **pp_phr,\n\t\tchar selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],\n\t\tIntervalType selectInterval[], int nSelect )\n{\n\tIntervalType inte, c;\n\tint chno, len;\n\tPhrase *phrase = ALC( Phrase, 1 );\n\n\tassert( phrase );\n\tinte.from = from;\n\tinte.to = to;\n\t*pp_phr = NULL;\n\n\t/* if there exist one phrase satisfied all selectStr then return 1, else return 0. */\n\tGetPhraseFirst( pgdata, phrase, ph_id );\n\tdo {\n\t\tfor ( chno = 0; chno < nSelect; chno++ ) {\n\t\t\tc = selectInterval[ chno ];\n\n\t\t\tif ( IsContain( inte, c ) ) {\n\t\t\t\t/* find a phrase of ph_id where the text contains\n\t\t\t\t * 'selectStr[chno]' test if not ok then return 0, if ok\n\t\t\t\t * then continue to test\n\t\t\t\t */\n\t\t\t\tlen = c.to - c.from;\n\t\t\t\tif ( memcmp(\n\t\t\t\t\tueStrSeek( phrase->phrase, c.from - from ),\n\t\t\t\t\tselectStr[ chno ],\n\t\t\t\t\tueStrNBytes( selectStr[ chno ], len ) ) )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ( IsIntersect( inte, selectInterval[ chno ] ) ) {\n\t\t\t\tfree( phrase );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif ( chno == nSelect ) {\n\t\t\t*pp_phr = phrase;\n\t\t\treturn 1;\n\t\t}\n\t} while ( GetPhraseNext( pgdata, phrase ) );\n\tfree( phrase );\n\treturn 0;\n}",
        "begin_line": 235,
        "end_line": 280,
        "is_bug": false
    },
    {
        "name": "src.tree.CheckUserChoose#157",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CheckUserChoose( \t\tChewingData *pgdata, uint16_t *new_phoneSeq, int from, int to, Phrase **pp_phr, char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ], IntervalType selectInterval[], int nSelect )",
        "snippet": "static int CheckUserChoose(\n\t\tChewingData *pgdata,\n\t\tuint16_t *new_phoneSeq, int from , int to,\n\t\tPhrase **pp_phr,\n\t\tchar selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],\n\t\tIntervalType selectInterval[], int nSelect )\n{\n\tIntervalType inte, c;\n\tint chno, len;\n\tint user_alloc;\n\tUserPhraseData *pUserPhraseData;\n\tPhrase *p_phr = ALC( Phrase, 1 );\n\n\tassert( p_phr );\n\tinte.from = from;\n\tinte.to = to;\n\t*pp_phr = NULL;\n\n\t/* pass 1\n\t * if these exist one selected interval which is not contained by inte\n\t * but has intersection with inte, then inte is an unacceptable interval\n\t */\n\tfor ( chno = 0; chno < nSelect; chno++ ) {\n\t\tc = selectInterval[ chno ];\n\t\tif ( IsIntersect( inte, c ) && ! IsContain( inte, c ) ) {\n\t\t\tfree( p_phr );\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* pass 2\n\t * if there exist one phrase satisfied all selectStr then return 1, else return 0.\n\t * also store the phrase with highest freq\n\t */\n\tpUserPhraseData = UserGetPhraseFirst( pgdata, new_phoneSeq );\n\tp_phr->freq = -1;\n\tdo {\n\t\tfor ( chno = 0; chno < nSelect; chno++ ) {\n\t\t\tc = selectInterval[ chno ];\n\n\t\t\tif ( IsContain( inte, c ) ) {\n\t\t\t\t/*\n\t\t\t\t * find a phrase of ph_id where the text contains\n\t\t\t\t * 'selectStr[chno]' test if not ok then return 0,\n\t\t\t\t * if ok then continue to test. */\n\t\t\t\tlen = c.to - c.from;\n\t\t\t\tif ( memcmp(\n\t\t\t\t\tueStrSeek( pUserPhraseData->wordSeq, c.from - from ),\n\t\t\t\t\tselectStr[ chno ],\n\t\t\t\t\tueStrNBytes( selectStr[ chno ], len ) ) )\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif ( chno == nSelect ) {\n\t\t\t/* save phrase data to \"pp_phr\" */\n\t\t\tif ( pUserPhraseData->userfreq > p_phr->freq ) {\n\t\t\t\tif ( ( user_alloc = ( to - from ) ) > 0 ) {\n\t\t\t\t\tueStrNCpy( p_phr->phrase,\n\t\t\t\t\t\t\tpUserPhraseData->wordSeq,\n\t\t\t\t\t\t\tuser_alloc, 1);\n\t\t\t\t}\n\t\t\t\tp_phr->freq = pUserPhraseData->userfreq;\n\t\t\t\t*pp_phr = p_phr;\n\t\t\t}\n\t\t}\n\t} while ( ( pUserPhraseData = UserGetPhraseNext( pgdata, new_phoneSeq ) ) != NULL );\n\n\tif ( p_phr->freq != -1 )\n\t\treturn 1;\n\n\tfree( p_phr );\n\treturn 0;\n}",
        "begin_line": 157,
        "end_line": 230,
        "is_bug": false
    },
    {
        "name": "src.tree.CleanUpMem#842",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CleanUpMem( TreeDataType *ptd )",
        "snippet": "static void CleanUpMem( TreeDataType *ptd )\n{\n\tint i;\n\tRecordNode *pNode;\n\n\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\tif ( ptd->interval[ i ].p_phr ) {\n\t\t\tfree( ptd->interval[ i ].p_phr );\n\t\t\tptd->interval[ i ].p_phr = NULL;\n\t\t}\n\t}\n\twhile ( ptd->phList != NULL ) {\n\t\tpNode = ptd->phList;\n\t\tptd->phList = pNode->next;\n\t\tfree( pNode->arrIndex );\n\t\tfree( pNode );\n\t}\n}",
        "begin_line": 842,
        "end_line": 859,
        "is_bug": false
    },
    {
        "name": "src.tree.CountMatchCnnct#861",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CountMatchCnnct( TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq )",
        "snippet": "static void CountMatchCnnct( TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq )\n{\n\tRecordNode *p;\n\tint i, k, sum;\n\n\tfor ( p = ptd->phList; p; p = p->next ) {\n\t\t/* for each record, count its 'nMatchCnnct' */\n\t\tfor ( sum = 0, i = 1; i < nPhoneSeq; i++ ) {\n\t\t\tif ( !bUserArrCnnct[ i ] )\n\t\t\t\tcontinue;\n\t\t\t/* check if matching 'cnnct' */\n\t\t\tfor ( k = 0; k < p->nInter; k++ ) {\n\t\t\t\tif (\n\t\t\t\t\tptd->interval[ p->arrIndex[ k ] ].from < i &&\n\t\t\t\t\tptd->interval[ p->arrIndex[ k ] ].to > i ) {\n\t\t\t\t\tsum++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp->nMatchCnnct = sum;\n\t}\n}",
        "begin_line": 861,
        "end_line": 883,
        "is_bug": false
    },
    {
        "name": "src.tree.Discard1#482",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.Discard1( TreeDataType *ptd )",
        "snippet": "static void Discard1( TreeDataType *ptd )\n{\n\tint a, b;\n\tchar failflag[ INTERVAL_SIZE ];\n\tint nInterval2;\n\n\tmemset( failflag, 0, sizeof( failflag ) );\n\tfor ( a = 0; a < ptd->nInterval; a++ ) {\n\t\tif ( failflag[ a ] )\n\t\t\tcontinue;\n\t\tfor ( b = 0; b < ptd->nInterval; b++ ) {\n\t\t\tif ( a == b || failflag[ b ] )\n\t\t\t\tcontinue ;\n\t\t\tif ( ptd->interval[ b ].from >= ptd->interval[ a ].from &&\n\t\t\t\tptd->interval[ b ].to <= ptd->interval[ a ].to )\n\t\t\t\tcontinue;\n\t\t\tif ( ptd->interval[ b ].from <= ptd->interval[ a ].from &&\n\t\t\t\tptd->interval[ b ].to <= ptd->interval[ a ].from )\n\t\t\t\tcontinue;\n\t\t\tif ( ptd->interval[ b ].from >= ptd->interval[ a ].to &&\n\t\t\t\tptd->interval[ b ].to >= ptd->interval[ a ].to )\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\t/* if any other interval b is inside or leftside or rightside the\n\t\t * interval a */\n\t\tif ( b >= ptd->nInterval ) {\n\t\t\t/* then kill all the intervals inside the interval a */\n\t\t\tint i;\n\t\t\tfor ( i = 0; i < ptd->nInterval; i++ )  {\n\t\t\t\tif (\n\t\t\t\t\t! failflag[ i ] && i != a &&\n\t\t\t\t\tptd->interval[ i ].from >=\n\t\t\t\t\t\tptd->interval[ a ].from &&\n\t\t\t\t\tptd->interval[ i ].to <= ptd->interval[ a ].to ) {\n\t\t\t\t\tfailflag[ i ] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* discard all the intervals whose failflag[a] = 1 */\n\tnInterval2 = 0;\n\tfor ( a = 0; a < ptd->nInterval; a++ ) {\n\t\tif ( ! failflag[ a ] ) {\n\t\t\tptd->interval[ nInterval2++ ] = ptd->interval[ a ];\n\t\t}\n\t\telse {\n\t\t\tif ( ptd->interval[ a ].p_phr != NULL ) {\n\t\t\t\tfree( ptd->interval[ a ].p_phr );\n\t\t\t}\n\t\t}\n\t}\n\tptd->nInterval = nInterval2;\n}",
        "begin_line": 482,
        "end_line": 535,
        "is_bug": false
    },
    {
        "name": "src.tree.Discard2#548",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.Discard2( TreeDataType *ptd )",
        "snippet": "static void Discard2( TreeDataType *ptd )\n{\n\tint i, j;\n\tchar overwrite[ MAX_PHONE_SEQ_LEN ], failflag[ MAX_PHONE_SEQ_LEN ];\n\tint nInterval2;\n\n\tmemset( failflag, 0, sizeof( failflag ) );\n\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\tif ( ptd->leftmost[ ptd->interval[ i ].from ] == 0 )\n\t\t\tcontinue;\n\t\t/* test if interval i is overwrited by other intervals */\n\t\tmemset( overwrite, 0, sizeof( overwrite ) );\n\t\tfor ( j = 0; j < ptd->nInterval; j++ ) {\n\t\t\tif ( j == i )\n\t\t\t\tcontinue;\n\t\t\tmemset(\n\t\t\t\t&overwrite[ ptd->interval[ j ].from ],\n\t\t\t\t1,\n\t\t\t\tptd->interval[ j ].to - ptd->interval[ j ].from );\n\t\t}\n\t\tif ( memchr(\n\t\t\t&overwrite[ ptd->interval[ i ].from ],\n\t\t\t1,\n\t\t\tptd->interval[ i ].to - ptd->interval[ i ].from ) )\n\t\t\tfailflag[ i ] = 1;\n\t}\n\t/* discard all the intervals whose failflag[a] = 1 */\n\tnInterval2 = 0;\n\tfor ( i = 0; i < ptd->nInterval; i++ )\n\t\tif ( ! failflag[ i ] )\n\t\t\tptd->interval[ nInterval2++ ] = ptd->interval[ i ];\n\tptd->nInterval = nInterval2;\n}",
        "begin_line": 548,
        "end_line": 580,
        "is_bug": false
    },
    {
        "name": "src.tree.FindInterval#352",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.FindInterval( ChewingData *pgdata, TreeDataType *ptd )",
        "snippet": "static void FindInterval( ChewingData *pgdata, TreeDataType *ptd )\n{\n\tint end, begin, pho_id;\n\tPhrase *p_phrase, *puserphrase, *pdictphrase;\n\tUsedPhraseMode i_used_phrase;\n\tuint16_t new_phoneSeq[ MAX_PHONE_SEQ_LEN ];\n\n\tfor ( begin = 0; begin < pgdata->nPhoneSeq; begin++ ) {\n\t\tfor ( end = begin; end < pgdata->nPhoneSeq; end++ ) {\n\t\t\tif ( ! CheckBreakpoint( begin, end + 1, pgdata->bArrBrkpt ) )\n\t\t\t\tcontinue;\n\n\t\t\t/* set new_phoneSeq */\n\t\t\tmemcpy(\n\t\t\t\tnew_phoneSeq,\n\t\t\t\t&pgdata->phoneSeq[ begin ],\n\t\t\t\tsizeof( uint16_t ) * ( end - begin + 1 ) );\n\t\t\tnew_phoneSeq[ end - begin + 1 ] = 0;\n\t\t\tpuserphrase = pdictphrase = NULL;\n\t\t\ti_used_phrase = USED_PHRASE_NONE;\n\n\t\t\t/* check user phrase */\n\t\t\tif ( UserGetPhraseFirst( pgdata, new_phoneSeq ) &&\n\t\t\t\t\tCheckUserChoose( pgdata, new_phoneSeq, begin, end + 1,\n\t\t\t\t\t&p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect ) ) {\n\t\t\t\tpuserphrase = p_phrase;\n\t\t\t}\n\n\t\t\t/* check dict phrase */\n\t\t\tpho_id = TreeFindPhrase( pgdata, begin, end, pgdata->phoneSeq );\n\t\t\tif (\n\t\t\t\t( pho_id != -1 ) &&\n\t\t\t\tCheckChoose(\n\t\t\t\t\tpgdata,\n\t\t\t\t\tpho_id, begin, end + 1,\n\t\t\t\t\t&p_phrase, pgdata->selectStr,\n\t\t\t\t\tpgdata->selectInterval, pgdata->nSelect ) ) {\n\t\t\t\tpdictphrase = p_phrase;\n\t\t\t}\n\n\t\t\t/* add only one interval, which has the largest freqency\n\t\t\t * but when the phrase is the same, the user phrase overrides\n\t\t\t * static dict\n\t\t\t */\n\t\t\tif ( puserphrase != NULL && pdictphrase == NULL ) {\n\t\t\t\ti_used_phrase = USED_PHRASE_USER;\n\t\t\t}\n\t\t\telse if ( puserphrase == NULL && pdictphrase != NULL ) {\n\t\t\t\ti_used_phrase = USED_PHRASE_DICT;\n\t\t\t}\n\t\t\telse if ( puserphrase != NULL && pdictphrase != NULL ) {\n\t\t\t\t/* the same phrase, userphrase overrides */\n\t\t\t\tif ( ! strcmp(\n\t\t\t\t\tpuserphrase->phrase,\n\t\t\t\t\tpdictphrase->phrase ) ) {\n\t\t\t\t\ti_used_phrase = USED_PHRASE_USER;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( puserphrase->freq > pdictphrase->freq ) {\n\t\t\t\t\t\ti_used_phrase = USED_PHRASE_USER;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ti_used_phrase = USED_PHRASE_DICT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch ( i_used_phrase ) {\n\t\t\t\tcase USED_PHRASE_USER:\n\t\t\t\t\tAddInterval( ptd, begin, end, -1, puserphrase,\n\t\t\t\t\t\t\tIS_USER_PHRASE );\n\t\t\t\t\tbreak;\n\t\t\t\tcase USED_PHRASE_DICT:\n\t\t\t\t\tAddInterval( ptd, begin, end, pho_id, pdictphrase,\n\t\t\t\t\t\t\tIS_DICT_PHRASE );\n\t\t\t\t\tbreak;\n\t\t\t\tcase USED_PHRASE_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinternal_release_Phrase(\n\t\t\t\ti_used_phrase,\n\t\t\t\tpuserphrase,\n\t\t\t\tpdictphrase );\n\t\t}\n\t}\n}",
        "begin_line": 352,
        "end_line": 437,
        "is_bug": false
    },
    {
        "name": "src.tree.InitPhrasing#824",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.InitPhrasing( TreeDataType *ptd )",
        "snippet": "static void InitPhrasing( TreeDataType *ptd )\n{\n\tmemset( ptd, 0, sizeof( TreeDataType ) );\n}",
        "begin_line": 824,
        "end_line": 827,
        "is_bug": false
    },
    {
        "name": "src.tree.InitTree#91",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.InitTree( ChewingData *pgdata, const char * prefix )",
        "snippet": "int InitTree( ChewingData *pgdata, const char * prefix )\n{\n#ifdef USE_BINARY_DATA\n\tchar filename[ PATH_MAX ];\n\tsize_t len;\n\tsize_t offset;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, PHONE_TREE_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tplat_mmap_set_invalid( &pgdata->static_data.tree_mmap );\n\tpgdata->static_data.tree_size = plat_mmap_create( &pgdata->static_data.tree_mmap, filename, FLAG_ATTRIBUTE_READ );\n\tif ( pgdata->static_data.tree_size <= 0 )\n\t\treturn -1;\n\n\toffset = 0;\n\tpgdata->static_data.tree = (TreeType *) plat_mmap_set_view( &pgdata->static_data.tree_mmap, &offset, &pgdata->static_data.tree_size );\n\tif ( !pgdata->static_data.tree )\n\t\treturn -1;\n\n\treturn 0;\n#else\n\tchar filename[ PATH_MAX ];\n\tint len;\n\tFILE *infile = NULL;\n\tint i;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, PHONE_TREE_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tinfile = fopen( filename, \"r\" );\n\tif ( !infile )\n\t\treturn -1;\n\n\tpgdata->static_data.tree = ALC( TreeType, TREE_SIZE );\n\tif ( !pgdata->static_data.tree ) {\n\t\tfclose( infile );\n\t\treturn -1;\n\t}\n\n\t/* XXX: What happen if infile contains more than TREE_SIZE data? */\n\tfor ( i = 0; i < TREE_SIZE; i++ ) {\n\t\tif ( fscanf( infile, \"%hu%d%d%d\",\n\t\t\t\t\t&pgdata->static_data.tree[ i ].phone_id,\n\t\t\t\t\t&pgdata->static_data.tree[ i ].phrase_id,\n\t\t\t\t\t&pgdata->static_data.tree[ i ].child_begin,\n\t\t\t\t\t&pgdata->static_data.tree[ i ].child_end ) != 4 )\n\t\t\tbreak;\n\t}\n\n\tfclose( infile );\n\treturn 0;\n#endif\n}",
        "begin_line": 91,
        "end_line": 146,
        "is_bug": false
    },
    {
        "name": "src.tree.IsContain#59",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.IsContain( IntervalType in1, IntervalType in2 )",
        "snippet": "static int IsContain( IntervalType in1, IntervalType in2 )\n{\n\treturn ( in1.from <= in2.from && in1.to >= in2.to );\n}",
        "begin_line": 59,
        "end_line": 62,
        "is_bug": false
    },
    {
        "name": "src.tree.IsIntersect#64",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.IsIntersect( IntervalType in1, IntervalType in2 )",
        "snippet": "int IsIntersect( IntervalType in1, IntervalType in2 )\n{\n\treturn ( max( in1.from, in2.from ) < min( in1.to, in2.to ) );\n}",
        "begin_line": 64,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "src.tree.LoadChar#582",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.LoadChar( ChewingData *pgdata, char *buf, int buf_len, const uint16_t phoneSeq[], int nPhoneSeq )",
        "snippet": "static void LoadChar( ChewingData *pgdata, char *buf, int buf_len, const uint16_t phoneSeq[], int nPhoneSeq )\n{\n\tint i;\n\tWord word;\n\n\tmemset(buf, 0, buf_len);\n\tfor ( i = 0; i < nPhoneSeq; i++ ) {\n\t\tGetCharFirst( pgdata, &word, phoneSeq[ i ] );\n\t\tstrncat(buf, word.word, buf_len - strlen(buf) - 1);\n\t}\n\tbuf[ buf_len - 1 ] = '\\0';\n}",
        "begin_line": 582,
        "end_line": 593,
        "is_bug": false
    },
    {
        "name": "src.tree.LoadPhraseAndCountScore#678",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.LoadPhraseAndCountScore( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int LoadPhraseAndCountScore( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint total_score = 0;\n\t/* NOTE: the balance factor is tuneable */\n\tif (nRecord) {\n\t\ttotal_score += 1000*rule_largest_sum( record, nRecord, ptd );\n\t\ttotal_score += 1000*rule_largest_avgwordlen( record, nRecord, ptd );\n\t\ttotal_score += 100*rule_smallest_lenvariance( record, nRecord, ptd );\n\t\ttotal_score += rule_largest_freqsum( record, nRecord, ptd );\n\t}\n\treturn total_score;\n}",
        "begin_line": 678,
        "end_line": 689,
        "is_bug": false
    },
    {
        "name": "src.tree.NextCut#908",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.NextCut( TreeDataType *tdt, PhrasingOutput *ppo )",
        "snippet": "static RecordNode* NextCut( TreeDataType *tdt, PhrasingOutput *ppo )\n{\n\t/* pop nNumCut-th candidate to first */\n\tint i;\n\tRecordNode *former;\n\tRecordNode *want;\n\n\tif ( ppo->nNumCut >= tdt->nPhListLen )\n\t\tppo->nNumCut = 0;\n\tif (ppo->nNumCut == 0)\n\t\treturn tdt->phList;\n\n\t/* find the former of our candidate */\n\tformer = tdt->phList;\n\tfor ( i = 0; i < ppo->nNumCut - 1; i++ ) {\n\t\tformer = former->next;\n\t\tassert( former );\n\t}\n\n\t/* take the candidate out of the listed list */\n\twant = former->next;\n\tassert( want );\n\tformer->next = former->next->next;\n\n\t/* prepend to front of list */\n\twant->next = tdt->phList;\n\ttdt->phList = want;\n\n\treturn tdt->phList;\n}",
        "begin_line": 908,
        "end_line": 937,
        "is_bug": false
    },
    {
        "name": "src.tree.OutputRecordStr#596",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.OutputRecordStr( \t\tChewingData *pgdata, char *out_buf, int out_buf_len, const int *record, int nRecord, uint16_t phoneSeq[], int nPhoneSeq, char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ], IntervalType selectInterval[], int nSelect, const TreeDataType *ptd )",
        "snippet": "static void OutputRecordStr(\n\t\tChewingData *pgdata,\n\t\tchar *out_buf, int out_buf_len,\n\t\tconst int *record, int nRecord,\n\t\tuint16_t phoneSeq[], int nPhoneSeq,\n\t\tchar selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],\n\t\tIntervalType selectInterval[],\n\t\tint nSelect, const TreeDataType *ptd )\n{\n\tPhraseIntervalType inter;\n\tint i;\n\n\tLoadChar( pgdata, out_buf, out_buf_len, phoneSeq, nPhoneSeq );\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tinter = ptd->interval[ record[ i ] ];\n\t\tueStrNCpy(\n\t\t\t\tueStrSeek( out_buf, inter.from ),\n\t\t\t\t( inter.p_phr )->phrase,\n\t\t\t\t( inter.to - inter.from ), -1);\n\t}\n\tfor ( i = 0; i < nSelect; i++ ) {\n\t\tinter.from = selectInterval[ i ].from;\n\t\tinter.to = selectInterval[ i ].to ;\n\t\tueStrNCpy(\n\t\t\t\tueStrSeek( out_buf, inter.from ),\n\t\t\t\tselectStr[ i ], ( inter.to - inter.from ), -1);\n\t}\n}",
        "begin_line": 596,
        "end_line": 623,
        "is_bug": false
    },
    {
        "name": "src.tree.PhraseIntervalIntersect#74",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)",
        "snippet": "static int PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)\n{\n\treturn ( max( in1.from, in2.from ) < min( in1.to, in2.to ) );\n}",
        "begin_line": 74,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "src.tree.Phrasing#939",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.Phrasing( ChewingData *pgdata )",
        "snippet": "int Phrasing( ChewingData *pgdata )\n{\n\tTreeDataType treeData;\n\n\tInitPhrasing( &treeData );\n\n\tFindInterval( pgdata, &treeData );\n\tSetInfo( pgdata->nPhoneSeq, &treeData );\n\tDiscard1( &treeData );\n\tDiscard2( &treeData );\n\tSaveList( &treeData );\n\tCountMatchCnnct( &treeData, pgdata->bUserArrCnnct, pgdata->nPhoneSeq );\n\tSortListByScore( &treeData );\n\tNextCut( &treeData, &pgdata->phrOut );\n\n\tShowList( pgdata, &treeData );\n\n\t/* set phrasing output */\n\tOutputRecordStr(\n\t\tpgdata,\n\t\tpgdata->phrOut.chiBuf, sizeof(pgdata->phrOut.chiBuf),\n\t\t( treeData.phList )->arrIndex,\n\t\t( treeData.phList )->nInter,\n\t\tpgdata->phoneSeq,\n\t\tpgdata->nPhoneSeq,\n\t\tpgdata->selectStr, pgdata->selectInterval, pgdata->nSelect, &treeData );\n\tSaveDispInterval( &pgdata->phrOut, &treeData );\n\n\t/* free \"phrase\" */\n\tCleanUpMem( &treeData );\n\treturn 0;\n}",
        "begin_line": 939,
        "end_line": 970,
        "is_bug": false
    },
    {
        "name": "src.tree.RecursiveSave#789",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.RecursiveSave( int depth, int to, int *record, TreeDataType *ptd )",
        "snippet": "static void RecursiveSave( int depth, int to, int *record, TreeDataType *ptd )\n{\n\tint first, i;\n\t/* to find first interval */\n\tfor (\n\t\tfirst = record[ depth - 1 ] + 1;\n\t\tptd->interval[ first ].from < to && first < ptd->nInterval;\n\t\tfirst++ )\n\t\t;\n\n\tif ( first == ptd->nInterval ) {\n\t\tSaveRecord( record + 1, depth - 1, ptd );\n\t\treturn;\n\t}\n\trecord[ depth ] = first;\n\tRecursiveSave( depth + 1, ptd->interval[ first ].to, record, ptd );\n\t/* for each interval which intersects first */\n\tfor (\n\t\ti= first + 1;\n\t\tPhraseIntervalIntersect(\n\t\t\tptd->interval[ first ],\n\t\t\tptd->interval[ i ] ) && i < ptd->nInterval;\n\t\t\ti++ ) {\n\t\trecord[ depth ] = i;\n\t\tRecursiveSave( depth + 1, ptd->interval[ i ].to,record, ptd );\n\t}\n}",
        "begin_line": 789,
        "end_line": 815,
        "is_bug": false
    },
    {
        "name": "src.tree.SaveDispInterval#829",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SaveDispInterval( PhrasingOutput *ppo, TreeDataType *ptd )",
        "snippet": "static void SaveDispInterval( PhrasingOutput *ppo, TreeDataType *ptd )\n{\n\tint i;\n\n\tfor ( i = 0; i < ptd->phList->nInter; i++ ) {\n\t\tppo->dispInterval[ i ].from =\n\t\t\tptd->interval[ ptd->phList->arrIndex[ i ] ].from;\n\t\tppo->dispInterval[ i ].to =\n\t\t\tptd->interval[ ptd->phList->arrIndex[ i ] ].to;\n\t}\n\tppo->nDispInterval = ptd->phList->nInter;\n}",
        "begin_line": 829,
        "end_line": 840,
        "is_bug": false
    },
    {
        "name": "src.tree.SaveList#817",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SaveList( TreeDataType *ptd )",
        "snippet": "static void SaveList( TreeDataType *ptd )\n{\n\tint record[ MAX_PHONE_SEQ_LEN + 1 ] = { -1 };\n\n\tRecursiveSave( 1, 0, record, ptd );\n}",
        "begin_line": 817,
        "end_line": 822,
        "is_bug": false
    },
    {
        "name": "src.tree.SaveRecord#753",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SaveRecord( const int *record, int nInter, TreeDataType *ptd )",
        "snippet": "static void SaveRecord( const int *record, int nInter, TreeDataType *ptd )\n{\n\tRecordNode *now, *p, *pre;\n\n\tpre = NULL;\n\tfor ( p = ptd->phList; p; ) {\n\t\t/* if  'p' contains 'record', then discard 'record'. */\n\t\tif ( IsRecContain( p->arrIndex, p->nInter, record, nInter, ptd ) )\n\t\t\treturn;\n\n\t\t/* if 'record' contains 'p', then discard 'p'\n\t\t * -- We must deal with the linked list. */\n\t\tif ( IsRecContain( record, nInter, p->arrIndex, p->nInter, ptd ) ) {\n\t\t\tRecordNode *tp = p;\n\n\t\t\tif ( pre )\n\t\t\t\tpre->next = p->next;\n\t\t\telse\n\t\t\t\tptd->phList = ptd->phList->next;\n\t\t\tp = p->next;\n\t\t\tfree( tp->arrIndex );\n\t\t\tfree( tp );\n\t\t}\n\t\telse\n\t\t\tpre = p, p = p->next;\n\t}\n\tnow = ALC( RecordNode, 1 );\n\tassert( now );\n\tnow->next = ptd->phList;\n\tnow->arrIndex = ALC( int, nInter );\n\tassert( now->arrIndex );\n\tnow->nInter = nInter;\n\tmemcpy( now->arrIndex, record, nInter * sizeof( int ) );\n\tptd->phList = now;\n}",
        "begin_line": 753,
        "end_line": 787,
        "is_bug": false
    },
    {
        "name": "src.tree.SetInfo#439",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SetInfo( int len, TreeDataType *ptd )",
        "snippet": "static void SetInfo( int len, TreeDataType *ptd )\n{\n\tint i, a;\n\n\tfor ( i = 0; i <= len; i++ )\n\t\tptd->leftmost[ i ] = i;\n\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\tptd->graph[ ptd->interval[ i ].from ][ ptd->interval[ i ].to ] = 1;\n\t\tptd->graph[ ptd->interval[ i ].to ][ ptd->interval[ i ].from ] = 1;\n\t}\n\n\t/* set leftmost */\n\tfor ( a = 0; a <= len; a++ ) {\n\t\tfor ( i = 0; i <= len; i++ ) {\n\t\t\tif ( ! ( ptd->graph[ a ][ i ] ) )\n\t\t\t\tcontinue;\n\t\t\tif ( ptd->leftmost[ i ] < ptd->leftmost[ a ] )\n\t\t\t\tptd->leftmost[ a ] = ptd->leftmost[ i ];\n\t\t}\n\t}\n}",
        "begin_line": 439,
        "end_line": 459,
        "is_bug": false
    },
    {
        "name": "src.tree.ShowList#885",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.ShowList( ChewingData *pgdata, const TreeDataType *ptd )",
        "snippet": "static void ShowList( ChewingData *pgdata, const TreeDataType *ptd )\n{\n\tconst RecordNode *p;\n\tint i;\n\n\tDEBUG_OUT( \"After SaveList :\\n\" );\n\tfor ( p = ptd->phList; p; p = p->next ) {\n\t\tDEBUG_OUT( \"  interval : \" );\n\t\tfor ( i = 0; i < p->nInter; i++ ) {\n\t\t\tDEBUG_OUT(\n\t\t\t\t\"[%d %d] \",\n\t\t\t\tptd->interval[ p->arrIndex[ i ] ].from,\n\t\t\t\tptd->interval[ p->arrIndex[ i ] ].to );\n\t\t}\n\t\tDEBUG_OUT(\n\t\t\t\"\\n\"\n\t\t\t   \"      score : %d , nMatchCnnct : %d\\n\",\n\t\t\tp->score,\n\t\t\tp->nMatchCnnct );\n\t}\n\tDEBUG_OUT( \"\\n\" );\n}",
        "begin_line": 885,
        "end_line": 906,
        "is_bug": false
    },
    {
        "name": "src.tree.SortListByScore#715",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SortListByScore( TreeDataType *ptd )",
        "snippet": "static void SortListByScore( TreeDataType *ptd )\n{\n\tint i, listLen;\n\tRecordNode *p, **arr;\n\n\tfor (\n\t\tlistLen = 0, p = ptd->phList;\n\t\tp;\n\t\tlistLen++, p = p->next )\n\t\t;\n\tptd->nPhListLen = listLen;\n\n\tarr = ALC( RecordNode *, listLen );\n\tassert( arr );\n\n\tfor (\n\t\ti = 0, p = ptd->phList;\n\t\ti < listLen;\n\t\tp = p->next, i++ ) {\n\t\tarr[ i ] = p;\n\t\tp->score = LoadPhraseAndCountScore(\n\t\t\tp->arrIndex,\n\t\t\tp->nInter,\n\t\t\tptd );\n\t}\n\n\tqsort( arr, listLen, sizeof( RecordNode * ), (CompFuncType) CompRecord );\n\n\tptd->phList = arr[ 0 ];\n\tfor ( i = 1; i < listLen; i++ ) {\n\t\tarr[ i - 1 ]->next = arr[ i ];\n\t}\n\tarr[ listLen - 1 ]->next = NULL;\n\n\tfree( arr );\n}",
        "begin_line": 715,
        "end_line": 750,
        "is_bug": false
    },
    {
        "name": "src.tree.TerminateTree#79",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.TerminateTree( ChewingData *pgdata )",
        "snippet": "void TerminateTree( ChewingData *pgdata )\n{\n#ifdef USE_BINARY_DATA\n\t\tpgdata->static_data.tree = NULL;\n\t\tplat_mmap_close( &pgdata->static_data.tree_mmap );\n#else\n\t\tfree( pgdata->static_data.tree );\n\t\tpgdata->static_data.tree = NULL;\n#endif\n}",
        "begin_line": 79,
        "end_line": 88,
        "is_bug": false
    },
    {
        "name": "src.tree.TreeFindPhrase#285",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.TreeFindPhrase( ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq )",
        "snippet": "int TreeFindPhrase( ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq )\n{\n\tint child, tree_p, i;\n\n\ttree_p = 0;\n\tfor ( i = begin; i <= end; i++ ) {\n\t\tfor (\n\t\t\tchild = pgdata->static_data.tree[ tree_p ].child_begin;\n\t\t\tchild != -1 && child <= pgdata->static_data.tree[ tree_p ].child_end;\n\t\t\tchild++ ) {\n\n#ifdef USE_BINARY_DATA\n\t\t\tassert(0 <= child && child * sizeof(TreeType) < pgdata->static_data.tree_size);\n#endif\n\t\t\tif ( pgdata->static_data.tree[ child ].phone_id == phoneSeq[ i ] )\n\t\t\t\tbreak;\n\t\t}\n\t\t/* if not found any word then fail. */\n\t\tif ( child == -1 || child > pgdata->static_data.tree[ tree_p ].child_end )\n\t\t\treturn -1;\n\t\telse {\n\t\t\ttree_p = child;\n\t\t}\n\t}\n\treturn pgdata->static_data.tree[ tree_p ].phrase_id;\n}",
        "begin_line": 285,
        "end_line": 310,
        "is_bug": false
    },
    {
        "name": "src.tree.internal_release_Phrase#331",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.internal_release_Phrase( UsedPhraseMode mode, Phrase *pUser, Phrase *pDict )",
        "snippet": "static void internal_release_Phrase( UsedPhraseMode mode, Phrase *pUser, Phrase *pDict )\n{\n\t/* we must free unused phrase entry to avoid memory leak. */\n\tswitch ( mode ) {\n\t\tcase USED_PHRASE_USER:\n\t\t\tif ( pDict != NULL )\n\t\t\t\tfree( pDict );\n\t\t\tbreak;\n\t\tcase USED_PHRASE_DICT:\n\t\t\tif ( pUser != NULL )\n\t\t\t\tfree( pUser );\n\t\t\tbreak;\n\t\tdefault: /* In fact, it is alwyas 0 */\n\t\t\tif ( pDict != NULL )\n\t\t\t\tfree( pDict );\n\t\t\tif ( pUser != NULL )\n\t\t\t\tfree( pUser );\n\t\t\tbreak;\n\t}\n}",
        "begin_line": 331,
        "end_line": 350,
        "is_bug": false
    },
    {
        "name": "src.tree.rule_largest_avgwordlen#638",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.rule_largest_avgwordlen( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_largest_avgwordlen( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\t/* constant factor 6=1*2*3, to keep value as integer */\n\treturn 6 * rule_largest_sum( record, nRecord, ptd ) / nRecord;\n}",
        "begin_line": 638,
        "end_line": 642,
        "is_bug": false
    },
    {
        "name": "src.tree.rule_largest_freqsum#661",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.rule_largest_freqsum( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_largest_freqsum( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint i, score = 0;\n\tPhraseIntervalType inter;\n\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tinter = ptd->interval[ record[ i ] ];\n\t\tassert( inter.p_phr );\n\n\t\t/* We adjust the 'freq' of One-word Phrase */\n\t\tscore += ( inter.to - inter.from == 1 ) ?\n\t\t\t( inter.p_phr->freq / 512 ) :\n\t\t\tinter.p_phr->freq;\n\t}\n\treturn score;\n}",
        "begin_line": 661,
        "end_line": 676,
        "is_bug": false
    },
    {
        "name": "src.tree.rule_largest_sum#625",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.rule_largest_sum( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_largest_sum( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint i, score = 0;\n\tPhraseIntervalType inter;\n\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tinter = ptd->interval[ record[ i ] ];\n\t\tassert( inter.p_phr );\n\t\tscore += inter.to - inter.from;\n\t}\n\treturn score;\n}",
        "begin_line": 625,
        "end_line": 636,
        "is_bug": false
    },
    {
        "name": "src.tree.rule_smallest_lenvariance#644",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.rule_smallest_lenvariance( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_smallest_lenvariance( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint i, j, score = 0;\n\tPhraseIntervalType inter1, inter2;\n\n\t/* kcwu: heuristic? why variance no square function? */\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tfor ( j = i + 1; j < nRecord; j++ ) {\n\t\t\tinter1 = ptd->interval[ record[ i ] ];\n\t\t\tinter2 = ptd->interval[ record[ j ] ];\n\t\t\tassert( inter1.p_phr && inter2.p_phr );\n\t\t\tscore += abs((inter1.to - inter1.from) - (inter2.to - inter2.from));\n\t\t}\n\t}\n\treturn -score;\n}",
        "begin_line": 644,
        "end_line": 659,
        "is_bug": false
    },
    {
        "name": "src.userphrase.LoadMaxFreq#52",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.LoadMaxFreq( ChewingData *pgdata, const uint16_t phoneSeq[], int len )",
        "snippet": "static int LoadMaxFreq( ChewingData *pgdata, const uint16_t phoneSeq[], int len )\n{\n\tint pho_id;\n\tPhrase *phrase = ALC( Phrase, 1 );\n\tint maxFreq = FREQ_INIT_VALUE;\n\tUserPhraseData *uphrase;\n\n\tpho_id = TreeFindPhrase( pgdata, 0, len - 1, phoneSeq );\n\tif ( pho_id != -1 ) {\n\t\tGetPhraseFirst( pgdata, phrase, pho_id );\n\t\tdo {\n\t\t\tif ( phrase->freq > maxFreq )\n\t\t\t\tmaxFreq = phrase->freq;\n\t\t} while( GetPhraseNext( pgdata, phrase ) );\n\t}\n\tfree( phrase );\n\n\tuphrase = UserGetPhraseFirst( pgdata, phoneSeq );\n\twhile ( uphrase ) {\n\t\tif ( uphrase->userfreq > maxFreq )\n\t\t\tmaxFreq = uphrase->userfreq;\n\t\tuphrase = UserGetPhraseNext( pgdata, phoneSeq );\n\t}\n\n\treturn maxFreq;\n}",
        "begin_line": 52,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "src.userphrase.LoadOriginalFreq#26",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.LoadOriginalFreq( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len )",
        "snippet": "static int LoadOriginalFreq( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len )\n{\n\tint pho_id;\n\tint retval;\n\tPhrase *phrase = ALC( Phrase, 1 );\n\n\tpho_id = TreeFindPhrase( pgdata, 0, len - 1, phoneSeq );\n\tif ( pho_id != -1 ) {\n\t\tGetPhraseFirst( pgdata, phrase, pho_id );\n\t\tdo {\n\t\t\t/* find the same phrase */\n\t\t\tif ( ! strcmp(\n\t\t\t\tphrase->phrase,\n\t\t\t\twordSeq ) ) {\n\t\t\t\tretval = phrase->freq;\n\t\t\t\tfree( phrase );\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t} while ( GetPhraseNext( pgdata, phrase ) );\n\t}\n\n\tfree( phrase );\n\treturn FREQ_INIT_VALUE;\n}",
        "begin_line": 26,
        "end_line": 49,
        "is_bug": false
    },
    {
        "name": "src.userphrase.UpdateFreq#80",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.UpdateFreq( int freq, int maxfreq, int origfreq, int deltatime )",
        "snippet": "static int UpdateFreq( int freq, int maxfreq, int origfreq, int deltatime )\n{\n\tint delta;\n\n\t/* Short interval */\n\tif ( deltatime < 4000 ) {\n\t\tdelta = ( freq >= maxfreq ) ?\n\t\t\tmin(\n\t\t\t\t( maxfreq - origfreq ) / 5 + 1,\n\t\t\t\tSHORT_INCREASE_FREQ ) :\n\t\t\tmax(\n\t\t\t\t( maxfreq - origfreq ) / 5 + 1,\n\t\t\t\tSHORT_INCREASE_FREQ );\n\t\treturn min( freq + delta, MAX_ALLOW_FREQ );\n\t}\n\t/* Medium interval */\n\telse if ( deltatime < 50000 ) {\n\t\tdelta = ( freq >= maxfreq ) ?\n\t\t\tmin(\n\t\t\t\t( maxfreq - origfreq ) / 10 + 1,\n\t\t\t\tMEDIUM_INCREASE_FREQ ) :\n\t\t\tmax(\n\t\t\t\t( maxfreq - origfreq ) / 10 + 1,\n\t\t\t\tMEDIUM_INCREASE_FREQ );\n\t\treturn min( freq + delta, MAX_ALLOW_FREQ );\n\t}\n\t/* long interval */\n\telse {\n\t\tdelta = max( ( freq - origfreq ) / 5, LONG_DECREASE_FREQ );\n\t\treturn max( freq - delta, origfreq );\n\t}\n}",
        "begin_line": 80,
        "end_line": 111,
        "is_bug": false
    },
    {
        "name": "src.userphrase.UserGetPhraseFirst#153",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.UserGetPhraseFirst( ChewingData *pgdata, const uint16_t phoneSeq[] )",
        "snippet": "UserPhraseData *UserGetPhraseFirst( ChewingData *pgdata, const uint16_t phoneSeq[] )\n{\n\tpgdata->prev_userphrase = HashFindPhonePhrase( pgdata, phoneSeq, NULL );\n\tif ( ! pgdata->prev_userphrase )\n\t\treturn NULL;\n\treturn &( pgdata->prev_userphrase->data );\n}",
        "begin_line": 153,
        "end_line": 159,
        "is_bug": false
    },
    {
        "name": "src.userphrase.UserGetPhraseNext#161",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.UserGetPhraseNext( ChewingData *pgdata, const uint16_t phoneSeq[] )",
        "snippet": "UserPhraseData *UserGetPhraseNext( ChewingData *pgdata, const uint16_t phoneSeq[] )\n{\n\tpgdata->prev_userphrase = HashFindPhonePhrase( pgdata, phoneSeq, pgdata->prev_userphrase );\n\tif ( ! pgdata->prev_userphrase )\n\t\treturn NULL;\n\treturn &( pgdata->prev_userphrase->data );\n}",
        "begin_line": 161,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "src.userphrase.UserUpdatePhrase#113",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.UserUpdatePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )",
        "snippet": "int UserUpdatePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )\n{\n\tHASH_ITEM *pItem;\n\tUserPhraseData data;\n\tint len;\n\n\tlen = ueStrLen( wordSeq );\n\tpItem = HashFindEntry( pgdata, phoneSeq, wordSeq );\n\tif ( ! pItem ) {\n\t\tif ( ! AlcUserPhraseSeq( &data, len, strlen( wordSeq ) ) ) {\n\t\t\treturn USER_UPDATE_FAIL;\n\t\t}\n\n\t\tmemcpy( data.phoneSeq, phoneSeq, len * sizeof( phoneSeq[ 0 ] ) );\n\t\tdata.phoneSeq[ len ] = 0;\n\t\tstrcpy( data.wordSeq, wordSeq );\n\n\t\t/* load initial freq */\n\t\tdata.origfreq = LoadOriginalFreq( pgdata, phoneSeq, wordSeq, len );\n\t\tdata.maxfreq = LoadMaxFreq( pgdata, phoneSeq, len );\n\n\t\tdata.userfreq = data.origfreq;\n\t\tdata.recentTime = pgdata->static_data.chewing_lifetime;\n\t\tpItem = HashInsert( pgdata, &data );\n\t\tHashModify( pgdata, pItem );\n\t\treturn USER_UPDATE_INSERT;\n\t}\n\telse {\n\t\tpItem->data.maxfreq = LoadMaxFreq( pgdata, phoneSeq, len );\n\t\tpItem->data.userfreq = UpdateFreq(\n\t\t\tpItem->data.userfreq,\n\t\t\tpItem->data.maxfreq,\n\t\t\tpItem->data.origfreq,\n\t\t\tpgdata->static_data.chewing_lifetime - pItem->data.recentTime );\n\t\tpItem->data.recentTime = pgdata->static_data.chewing_lifetime;\n\t\tHashModify( pgdata, pItem );\n\t\treturn USER_UPDATE_MODIFY;\n\t}\n}",
        "begin_line": 113,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "src.zuin.DefPhoInput#149",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.DefPhoInput( ChewingData *pgdata, int key )",
        "snippet": "static int DefPhoInput( ChewingData *pgdata, int key )\n{\n\tZuinData *pZuin = &(pgdata->zuinData);\n\tint type = 0, inx = 0;\n\tint i;\n\n\tif ( IsDefPhoEndKey( key, pZuin->kbtype ) ) {\n\t\tfor ( i = 0; i < ZUIN_SIZE; ++i )\n\t\t\tif ( pZuin->pho_inx[ i ] != 0 )\n\t\t\t\tbreak;\n\t\tif ( i < ZUIN_SIZE )\n\t\t\treturn EndKeyProcess( pgdata, key, 1 );\n\t}\n\telse {\n\t\tpZuin->pho_inx[ 3 ] = 0;\n\t}\n\n\t/* decide if the key is a phone */\n\tfor ( type = 0; type <= 3; type++ ) {\n\t\tinx = PhoneInxFromKey( key, type, pZuin->kbtype, 1 );\n\t\tif ( inx )\n\t\t\tbreak;\n\t}\n\n\t/* the key is NOT a phone */\n\tif ( type > 3 ) {\n\t\treturn ZUIN_KEY_ERROR;\n\t}\n\n\t/* fill the key into the phone buffer */\n\tpZuin->pho_inx[ type ] = inx;\n\treturn ZUIN_ABSORB;\n}",
        "begin_line": 149,
        "end_line": 181,
        "is_bug": false
    },
    {
        "name": "src.zuin.EndKeyProcess#93",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.EndKeyProcess( ChewingData *pgdata, int key, int searchTimes )",
        "snippet": "static int EndKeyProcess( ChewingData *pgdata, int key, int searchTimes )\n{\n\tZuinData *pZuin = &(pgdata->zuinData);\n\tuint16_t u16Pho, u16PhoAlt;\n\tWord tempword;\n\tint pho_inx;\n\n\tif (\n\t\tpZuin->pho_inx[ 0 ] == 0 &&\n\t\tpZuin->pho_inx[ 1 ] == 0 &&\n\t\tpZuin->pho_inx[ 2 ] == 0 &&\n\t\tpZuin->pho_inx[ 3 ] == 0 ) {\n\t\t/*\n\t\t * Special handle for space key (Indeed very special one).\n\t\t * Un-break the situation that OnKeySpace() is not called,\n\t\t * hence the Candidate window doesn't show up, because\n\t\t * ZUIN_NO_WORD is returned.\n\t\t */\n\t\treturn (key == ' ') ? ZUIN_KEY_ERROR : ZUIN_NO_WORD;\n\t}\n\n\tpho_inx = PhoneInxFromKey( key, 3, pZuin->kbtype, searchTimes );\n\tif ( pZuin->pho_inx[ 3 ] == 0 ) {\n\t\tpZuin->pho_inx[ 3 ] = pho_inx;\n\t\tpZuin->pho_inx_alt[ 3 ] = pho_inx;\n\t}\n\telse if ( key != ' ' ) {\n\t\tpZuin->pho_inx[ 3 ] = pho_inx;\n\t\tpZuin->pho_inx_alt[ 3 ] = pho_inx;\n\t\treturn ZUIN_NO_WORD;\n\t}\n\n\tu16Pho = UintFromPhoneInx( pZuin->pho_inx );\n\tif ( GetCharFirst( pgdata, &tempword, u16Pho ) == 0 ) {\n\t\tZuinRemoveAll( pZuin );\n\t\treturn ZUIN_NO_WORD;\n\t}\n\n\tpZuin->phone = u16Pho;\n\n\tif ( pZuin->pho_inx_alt[ 0 ] == 0 &&\n\t     pZuin->pho_inx_alt[ 1 ] == 0 &&\n\t     pZuin->pho_inx_alt[ 2 ] == 0 ) {\n\t\t/* no alternative phone, copy from default as alt */\n\t\tpZuin->phoneAlt = u16Pho;\n\t}\n\telse {\n\t\tu16PhoAlt = UintFromPhoneInx( pZuin->pho_inx_alt );\n\t\tpZuin->phoneAlt = u16PhoAlt;\n\t}\n\n\tmemset( pZuin->pho_inx, 0, sizeof( pZuin->pho_inx ) );\n\tmemset( pZuin->pho_inx_alt, 0, sizeof( pZuin->pho_inx_alt ) );\n\treturn ZUIN_COMMIT;\n}",
        "begin_line": 93,
        "end_line": 147,
        "is_bug": false
    },
    {
        "name": "src.zuin.IsDefPhoEndKey#83",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.IsDefPhoEndKey( int key, int kbtype )",
        "snippet": "static int IsDefPhoEndKey( int key, int kbtype )\n{\n\tif ( PhoneInxFromKey( key, 3, kbtype, 1 )  )\n\t\treturn 1;\n\n\tif ( key == ' ' )\n\t\treturn 1;\n\treturn 0;\n}",
        "begin_line": 83,
        "end_line": 91,
        "is_bug": false
    },
    {
        "name": "src.zuin.ZuinIsEntering#693",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.ZuinIsEntering( ZuinData *pZuin )",
        "snippet": "int ZuinIsEntering( ZuinData *pZuin )\n{\n\tint i;\n        if ( pZuin->kbtype >= KB_HANYU_PINYIN ) {\n\t    if ( pZuin->pinYinData.keySeq[0] )\n\t\treturn 1;\n\t} else {\n\t    for ( i = 0; i < ZUIN_SIZE; i++ )\n\t\tif ( pZuin->pho_inx[ i ] )\n\t\t    return 1;\n\t}\n\treturn 0;\n}",
        "begin_line": 693,
        "end_line": 705,
        "is_bug": false
    },
    {
        "name": "src.zuin.ZuinPhoInput#642",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.ZuinPhoInput( ChewingData *pgdata, int key )",
        "snippet": "int ZuinPhoInput( ChewingData *pgdata, int key )\n{\n\tZuinData *pZuin = &(pgdata->zuinData);\n\tswitch ( pZuin->kbtype ) {\n\t\tcase KB_HSU:\n\t\tcase KB_DVORAK_HSU:\n\t\t\treturn HsuPhoInput( pgdata, key );\n\t\t\tbreak;\n\t\tcase KB_ET26:\n\t\t\treturn ET26PhoInput( pgdata, key );\n\t\t\tbreak;\n\t\tcase KB_DACHEN_CP26:\n\t\t\treturn DACHENCP26PhoInput( pgdata, key );\n\t\t\tbreak;\n\t\tcase KB_HANYU_PINYIN:\n\t\tcase KB_THL_PINYIN:\n\t\tcase KB_MPS2_PINYIN:\n\t\t\treturn PinYinInput( pgdata, key );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn DefPhoInput( pgdata, key );\n\t}\n\treturn ZUIN_ERROR;\n}",
        "begin_line": 642,
        "end_line": 665,
        "is_bug": false
    },
    {
        "name": "src.zuin.ZuinRemoveAll#686",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.ZuinRemoveAll( ZuinData *pZuin )",
        "snippet": "int ZuinRemoveAll( ZuinData *pZuin )\n{\n\tmemset( pZuin->pho_inx, 0, sizeof( pZuin->pho_inx ) );\n\tmemset( pZuin->pinYinData.keySeq, 0, sizeof( pZuin->pinYinData.keySeq ) );\n\treturn 0;\n}",
        "begin_line": 686,
        "end_line": 691,
        "is_bug": false
    },
    {
        "name": "src.zuin.ZuinRemoveLast#668",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.ZuinRemoveLast( ZuinData *pZuin )",
        "snippet": "int ZuinRemoveLast( ZuinData *pZuin )\n{\n\tint i;\n\tif ( pZuin->kbtype >= KB_HANYU_PINYIN ) {\n\t\ti = strlen( pZuin->pinYinData.keySeq );\n\t\tpZuin->pinYinData.keySeq[ i - 1 ] = '\\0';\n\t} else {\n\t\tfor ( i = 3; i >= 0; i-- ) {\n\t\t\tif ( pZuin->pho_inx[ i ] ) {\n\t\t\t\tpZuin->pho_inx[ i ] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 668,
        "end_line": 683,
        "is_bug": false
    }
]