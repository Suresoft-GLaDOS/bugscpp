From 5fac6e2fe075b5358794bc72c05a591a68b68c25 Mon Sep 17 00:00:00 2001
From: haku <gentlebuuny@gmail.com>
Date: Tue, 13 Jul 2021 14:18:58 +0900
Subject: [PATCH] split tests

---
 tests/defects4cpp.h    |  11 ++++
 tests/defects4cpp.lua  |   1 +
 tests/test-alignment.c | 101 ++++++++++++++++++++++++++++++----
 tests/test-api.c       |  29 +++++++++-
 tests/test-atoms.c     | 120 +++++++++++++++++++++++++++++++++++------
 tests/test-bitmask.c   |  10 ++++
 tests/test-dex.c       |  64 +++++++++++++++-------
 tests/test-elf.c       |  86 +++++++++++++++++++----------
 tests/test-exception.c |  16 ++++--
 tests/test-macho.c     |  95 +++++++++++++++++++++++++-------
 tests/test-math.c      |  11 ++--
 tests/test-pe.c        |  73 +++++++++++++++----------
 tests/test-rules.c     |  68 ++++++++++++++++++++---
 tests/test-stack.c     |   6 +++
 14 files changed, 557 insertions(+), 134 deletions(-)
 create mode 100644 tests/defects4cpp.h
 create mode 100644 tests/defects4cpp.lua

diff --git a/tests/defects4cpp.h b/tests/defects4cpp.h
new file mode 100644
index 00000000..39a25b15
--- /dev/null
+++ b/tests/defects4cpp.h
@@ -0,0 +1,11 @@
+#include <lua5.3/lualib.h>
+#include <lua5.3/lauxlib.h>
+
+static int defects4cpp_test_index() {
+  lua_State *L = luaL_newstate();
+  luaL_openlibs(L);
+  luaL_dofile(L, "tests/defects4cpp.lua");
+  int ret = lua_tonumber(L, -1);
+  lua_close(L);
+  return ret;
+}
diff --git a/tests/defects4cpp.lua b/tests/defects4cpp.lua
new file mode 100644
index 00000000..a4325f62
--- /dev/null
+++ b/tests/defects4cpp.lua
@@ -0,0 +1 @@
+return 1
diff --git a/tests/test-alignment.c b/tests/test-alignment.c
index 3b5a9c7a..4a290585 100644
--- a/tests/test-alignment.c
+++ b/tests/test-alignment.c
@@ -31,6 +31,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <stdio.h>
 #undef NDEBUG
 #include <assert.h>
+#include "defects4cpp.h"
 
 int err = 0;
 
@@ -64,61 +65,143 @@ int err = 0;
     }                                                 \
   } while (0)
 
-
 int main (int argc, char **argv)
 {
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 1:
   CHECK_SIZE(YR_NAMESPACE, 4 * YR_MAX_THREADS + 8);
+          break;
+      case 2:
   CHECK_OFFSET(YR_NAMESPACE, 4 * YR_MAX_THREADS, name);
-
+          break;
+      case 3:
   CHECK_SIZE(YR_META, 32);
+          break;
+      case 4:
   CHECK_OFFSET(YR_META, 8,  integer);
+          break;
+      case 5:
   CHECK_OFFSET(YR_META, 16, identifier);
+          break;
+      case 6:
   CHECK_OFFSET(YR_META, 24, string);
-
+          break;
+      case 7:
   CHECK_SIZE(YR_MATCHES, 24);
+          break;
+      case 8:
   CHECK_OFFSET(YR_MATCHES, 8,  head);
+          break;
+      case 9:
   CHECK_OFFSET(YR_MATCHES, 16, tail);
-
+          break;
+      case 10:
   CHECK_SIZE(YR_STRING, 56 + 2 * 24 /* YR_MATCHES */ * YR_MAX_THREADS);
+          break;
+      case 11:
   CHECK_OFFSET(YR_STRING, 4,  length);
+          break;
+      case 12:
   CHECK_OFFSET(YR_STRING, 8,  identifier);
+          break;
+      case 13:
   CHECK_OFFSET(YR_STRING, 16, string);
+          break;
+      case 14:
   CHECK_OFFSET(YR_STRING, 24, chained_to);
+          break;
+      case 15:
   CHECK_OFFSET(YR_STRING, 32, rule);
+          break;
+      case 16:
   CHECK_OFFSET(YR_STRING, 40, chain_gap_min);
+          break;
+      case 17:
   CHECK_OFFSET(YR_STRING, 44, chain_gap_max);
+          break;
+      case 18:
   CHECK_OFFSET(YR_STRING, 48, fixed_offset);
-
+          break;
+      case 19:
   CHECK_SIZE(YR_RULE, 64 + 12 * YR_MAX_THREADS);
+          break;
+      case 20:
   CHECK_OFFSET(YR_RULE, 4,                           t_flags);
+          break;
+      case 21:
   CHECK_OFFSET(YR_RULE, 8 + 4 * YR_MAX_THREADS,      identifier);
+          break;
+      case 22:
   CHECK_OFFSET(YR_RULE, 8 + 4 * YR_MAX_THREADS + 8,  tags);
+          break;
+      case 23:
   CHECK_OFFSET(YR_RULE, 8 + 4 * YR_MAX_THREADS + 16, metas);
+          break;
+      case 24:
   CHECK_OFFSET(YR_RULE, 8 + 4 * YR_MAX_THREADS + 24, strings);
+          break;
+      case 25:
   CHECK_OFFSET(YR_RULE, 8 + 4 * YR_MAX_THREADS + 32, ns);
-
+          break;
+      case 26:
   CHECK_SIZE(YR_EXTERNAL_VARIABLE, 24);
+          break;
+      case 27:
   CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 8,  value.i);
+          break;
+      case 28:
   CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 8,  value.f);
+          break;
+      case 29:
   CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 8,  value.s);
+          break;
+      case 30:
   CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 16, identifier);
-
+          break;
+      case 31:
   CHECK_SIZE(YR_AC_MATCH, 40);
+          break;
+      case 32:
   CHECK_OFFSET(YR_AC_MATCH, 8,  string);
+          break;
+      case 33:
   CHECK_OFFSET(YR_AC_MATCH, 16, forward_code);
+          break;
+      case 34:
   CHECK_OFFSET(YR_AC_MATCH, 24, backward_code);
+          break;
+      case 35:
   CHECK_OFFSET(YR_AC_MATCH, 32, next);
-
+          break;
+      case 36:
   CHECK_SIZE(YARA_RULES_FILE_HEADER, 48);
+          break;
+      case 37:
   CHECK_OFFSET(YARA_RULES_FILE_HEADER, 0, rules_list_head);
+          break;
+      case 38:
   CHECK_OFFSET(YARA_RULES_FILE_HEADER, 8, externals_list_head);
+          break;
+      case 39:
   CHECK_OFFSET(YARA_RULES_FILE_HEADER, 16, code_start);
+          break;
+      case 40:
   CHECK_OFFSET(YARA_RULES_FILE_HEADER, 24, ac_match_table);
+          break;
+      case 41:
   CHECK_OFFSET(YARA_RULES_FILE_HEADER, 32, ac_transition_table);
-
+          break;
+      case 42:
   CHECK_SIZE(SIZED_STRING, 12);
+          break;
+      case 43:
   CHECK_OFFSET(SIZED_STRING, 4, flags);
+          break;
+      case 44:
   CHECK_OFFSET(SIZED_STRING, 8, c_string);
+          break;
+  }
 
   return err;
 }
diff --git a/tests/test-api.c b/tests/test-api.c
index 50a321d8..6e470d55 100644
--- a/tests/test-api.c
+++ b/tests/test-api.c
@@ -10,6 +10,8 @@
 #endif
 #include <fcntl.h>
 
+#include "defects4cpp.h"
+
 void test_disabled_rules()
 {
   YR_RULES* rules;
@@ -746,17 +748,40 @@ int main(int argc, char** argv)
   char *top_srcdir = getenv("TOP_SRCDIR");
   if (top_srcdir)
     chdir(top_srcdir);
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 45:
   test_disabled_rules();
+          break;
+      case 46:
   test_file_descriptor();
+          break;
+      case 47:
   test_max_string_per_rules();
+          break;
+      case 48:
   test_max_match_data();
+          break;
+      case 49:
   test_include_callback();
+          break;
+      case 50:
   test_save_load_rules();
+          break;
+      case 51:
   test_scanner();
+          break;
+      case 52:
   test_ast_callback();
+          break;
+      case 53:
   test_rules_stats();
-
+          break;
+      case 54:
   test_issue_834();
+          break;
+      case 55:
   test_issue_920();
+          break;
+  }
 }
diff --git a/tests/test-atoms.c b/tests/test-atoms.c
index 6dd362f8..bfaa61f5 100644
--- a/tests/test-atoms.c
+++ b/tests/test-atoms.c
@@ -29,6 +29,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <yara.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 
 void test_table_quality()
@@ -62,19 +63,42 @@ void test_table_quality()
   c.quality_table = l1;
   c.quality_table_entries = 3;
 
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 56:
   assert_true_expr(yr_atoms_table_quality(&c, &a0) == 1);
+          break;
+      case 57:
   assert_true_expr(yr_atoms_table_quality(&c, &a1) == 2);
+          break;
+      case 58:
   assert_true_expr(yr_atoms_table_quality(&c, &a2) == 3);
+          break;
+      case 59:
   assert_true_expr(yr_atoms_table_quality(&c, &a3) == YR_MAX_ATOM_QUALITY);
+          break;
+  }
 
   c.quality_table = l2;
   c.quality_table_entries = 4;
 
+  switch (index) {
+      case 60:
   assert_true_expr(yr_atoms_table_quality(&c, &a0) == 1);
+          break;
+      case 61:
   assert_true_expr(yr_atoms_table_quality(&c, &a1) == 2);
+          break;
+      case 62:
   assert_true_expr(yr_atoms_table_quality(&c, &a2) == 3);
+          break;
+      case 63:
   assert_true_expr(yr_atoms_table_quality(&c, &a3) == 4);
+          break;
+      case 64:
   assert_true_expr(yr_atoms_table_quality(&c, &a4) == 1);
+          break;
+  }
 }
 
 
@@ -180,28 +204,72 @@ void test_heuristic_quality()
 
   int q010X0X   = yr_atoms_heuristic_quality(&c, &a010203);
 
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 65:
   assert_true_expr(q00000001 > q00000000);
+          break;
+      case 66:
   assert_true_expr(q00000001 > q000001);
+          break;
+      case 67:
   assert_true_expr(q000001   > q0001);
+          break;
+      case 68:
   assert_true_expr(q00000102 > q00000001);
+          break;
+      case 69:
   assert_true_expr(q00010203 > q00000102);
+          break;
+      case 70:
   assert_true_expr(q01020304 > q00010203);
+          break;
+      case 71:
   assert_true_expr(q000102   > q000001);
+          break;
+      case 72:
   assert_true_expr(q00010203 > q010203);
+          break;
+      case 73:
   assert_true_expr(q010203   > q0102);
+          break;
+      case 74:
   assert_true_expr(q0102     > q01);
+          break;
+      case 75:
   assert_true_expr(q01X203   > q0102);
+          break;
+      case 76:
   assert_true_expr(q01X203   > q0001);
+          break;
+      case 77:
   assert_true_expr(q01X203   < q010203);
+          break;
+      case 78:
   assert_true_expr(q01X203   == q010X03);
+          break;
+      case 79:
   assert_true_expr(q01XX03   <= q0102);
+          break;
+      case 80:
   assert_true_expr(q01XX03   < q010X03);
+          break;
+      case 81:
   assert_true_expr(q01XX03   < q010203);
+          break;
+      case 82:
   assert_true_expr(q010X0X   > q01);
+          break;
+      case 83:
   assert_true_expr(q010X0X   < q010203);
+          break;
+      case 84:
   assert_true_expr(q01020000 > q0102XX04);
-
+          break;
+      case 85:
   assert_true_expr(q01020304 == YR_MAX_ATOM_QUALITY);
+          break;
+  }
 }
 
 
@@ -506,67 +574,87 @@ void test_atom_choose()
       {3, {0x61, 0x6F, 0x63}},
     };
 
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 86:
     assert_re_atoms("abcd", 1, (struct atom[]) {
       {4, {0x61, 0x62, 0x63, 0x64}},
     });
-
+          break;
+      case 87:
     assert_re_atoms("abcd1234", 1, (struct atom[]) {
       {4, {0x31, 0x32, 0x33, 0x34}},
     });
-
+          break;
+      case 88:
     assert_re_atoms("a..d", 1, (struct atom[]) {
       {1, {0x61}},
     });
-
+          break;
+      case 89:
     assert_re_atoms("a..de", 1, (struct atom[]) {
       {2, {0x64, 0x65}},
     });
-
+          break;
+      case 90:
     assert_re_atoms("abcd.efgh", 1, (struct atom[]) {
       {4, {0x61, 0x62, 0x63, 0x64}},
     });
-
+          break;
+      case 91:
     assert_re_atoms("(abcd|efgh)", 2, (struct atom[]) {
       {4, {0x65, 0x66, 0x67, 0x68}},
       {4, {0x61, 0x62, 0x63, 0x64}},
     });
-
+          break;
+      case 92:
     assert_re_atoms("(abcd|efgh|ij)", 3, (struct atom[]) {
       {2, {0x69, 0x6A}},
       {4, {0x65, 0x66, 0x67, 0x68}},
       {4, {0x61, 0x62, 0x63, 0x64}},
     });
-
+          break;
+      case 93:
     assert_re_atoms("a.cd", 256, atoms_61_XX_63_64);
-
+          break;
+      case 94:
     assert_hex_atoms("{61 62 63 64}", 1, (struct atom[]) {
       {4, {0x61, 0x62, 0x63, 0x64}},
     });
-
+          break;
+      case 95:
     assert_hex_atoms("{61 62 63 64 [1-5] 65 66 67 68}", 1, (struct atom[]) {
       {4, {0x61, 0x62, 0x63, 0x64}},
     });
-
+          break;
+      case 96:
     assert_hex_atoms("{61 62 63 [1-5] 65 66 67 68}", 1, (struct atom[]) {
       {4, {0x65, 0x66, 0x67, 0x68}},
     });
-
+          break;
+      case 97:
     assert_hex_atoms("{61 62 63 [1-5] 65 66 }", 1, (struct atom[]) {
       {3, {0x61, 0x62, 0x63}},
     });
-
+          break;
+      case 98:
     assert_hex_atoms("{61 6? 63 [1-5] 65 66 }", 16, atoms_61_6X_63);
-
+          break;
+      case 99:
     assert_hex_atoms("{(61 62 63 | 65 66 67 68)}", 2, (struct atom[]) {
       {4, {0x65, 0x66, 0x67, 0x68}},
       {3, {0x61, 0x62, 0x63}},
     });
-
+          break;
+      case 100:
     assert_hex_atoms("{61 62 0? 64}", 16, atoms_61_62_0X_64);
-
+          break;
+      case 101:
     assert_hex_atoms("{11 ?? 11 ?? 22 33 44 55 66 }", 1, (struct atom[]) {
       {4, {0x22, 0x33, 0x44, 0x55}},
     });
+          break;
+  }
 }
 
 
diff --git a/tests/test-bitmask.c b/tests/test-bitmask.c
index 95897f7b..1f5bffd7 100644
--- a/tests/test-bitmask.c
+++ b/tests/test-bitmask.c
@@ -31,6 +31,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <yara/bitmask.h>
 #include <yara.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 #define BITMAP_SIZE 512
 
@@ -232,7 +233,16 @@ void test_find_non_colliding_offsets_2()
 
 int main(int argc, char** argv)
 {
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 102:
   test_set_clear();
+          break;
+      case 103:
   test_find_non_colliding_offsets_1();
+          break;
+      case 104:
   test_find_non_colliding_offsets_2();
+          break;
+  }
 }
diff --git a/tests/test-dex.c b/tests/test-dex.c
index 012375a0..93d5b78c 100644
--- a/tests/test-dex.c
+++ b/tests/test-dex.c
@@ -1,107 +1,131 @@
 #include <yara.h>
 #include "util.h"
 #include "blob.h"
+#include "defects4cpp.h"
 
 int main(int argc, char** argv)
 {
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 105:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.header.magic == \
         dex.DEX_FILE_MAGIC_035 }",
       DEX_FILE);
-
+          break;
+      case 106:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.header.checksum == \
         0x3F9C602F }",
       DEX_FILE);
-
+          break;
+      case 107:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.header.data_size == \
         0x18C }",
       DEX_FILE);
-
+          break;
+      case 108:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.string_ids[0].value ==\
       \"<clinit>\" }",
       DEX_FILE);
-
+          break;
+      case 109:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.string_ids[8].value == \
         \"com.google.helloyara\" }",
       DEX_FILE);
-
+          break;
+      case 110:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.type_ids[0].descriptor_idx == \
         0x2 }",
       DEX_FILE);
-
+          break;
+      case 111:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.proto_ids[0].shorty_idx == \
         0x6 }",
       DEX_FILE);
-
+          break;
+      case 112:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.field_ids[0].class_idx == \
         0x1 }",
       DEX_FILE);
-
+          break;
+      case 113:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.method_ids[0].class_idx == \
         0x1 }",
       DEX_FILE);
-
+          break;
+      case 114:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.class_defs[0].class_idx == \
         0x1 }",
       DEX_FILE);
-
+          break;
+      case 115:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.number_of_fields == 2 }",
       DEX_FILE);
-
+          break;
+      case 116:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.field[0].class_name == \
         \"Lcom/android/tools/ir/server/AppInfo;\" }",
       DEX_FILE);
-
+          break;
+      case 117:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.field[0].name == \
         \"applicationId\" }",
       DEX_FILE);
-
+          break;
+      case 118:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.number_of_methods == 2 }",
       DEX_FILE);
-
+          break;
+      case 119:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.method[0].class_name == \
         \"Lcom/android/tools/ir/server/AppInfo;\" }",
       DEX_FILE);
-
+          break;
+      case 120:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.method[0].proto == \"V\" }",
       DEX_FILE);
-
+          break;
+      case 121:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.method[0].name == \
         \"<clinit>\" }",
       DEX_FILE);
-
+          break;
+      case 122:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.method[1].name == \
         \"<init>\" }",
       DEX_FILE);
-
+          break;
+      case 123:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.map_list.size == 12 }",
       DEX_FILE);
-
+          break;
+      case 124:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: \
           dex.map_list.map_item[0].type == dex.TYPE_HEADER_ITEM \
         }",
       DEX_FILE);
+          break;
+  }
 
   yr_finalize();
 }
diff --git a/tests/test-elf.c b/tests/test-elf.c
index b8a18aef..42d64f13 100644
--- a/tests/test-elf.c
+++ b/tests/test-elf.c
@@ -1,27 +1,34 @@
 #include <yara.h>
 #include "util.h"
 #include "blob.h"
+#include "defects4cpp.h"
 
 int main(int argc, char** argv)
 {
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 125:
   assert_true_rule_blob(
       "import \"elf\" rule test { condition: elf.type }",
       ELF32_FILE);
-
+          break;
+      case 126:
   assert_true_rule_blob(
       "import \"elf\" rule test { condition: elf.type }",
       ELF64_FILE);
-
+          break;
+      case 127:
   assert_true_rule_blob(
       "import \"elf\" rule test { condition: elf.machine == elf.EM_386 }",
       ELF32_FILE)
-
+          break;
+      case 128:
   assert_true_rule_blob(
       "import \"elf\" rule test { condition: elf.machine == elf.EM_X86_64 }",
       ELF64_FILE)
-
+          break;
+      case 129:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -29,7 +36,8 @@ int main(int argc, char** argv)
         condition: $a at elf.entry_point \
       }",
       ELF32_FILE);
-
+          break;
+      case 130:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -37,29 +45,34 @@ int main(int argc, char** argv)
         condition: $a at elf.entry_point \
       }",
       ELF64_FILE);
-
+          break;
+      case 131:
   assert_true_rule_blob(
       "import \"elf\" rule test { condition: elf.entry_point == 0xa0 }",
       ELF32_NOSECTIONS);
-
+          break;
+      case 132:
   assert_true_rule_blob(
       "import \"elf\" rule test { condition: elf.entry_point == 0x1a0 }",
       ELF32_SHAREDOBJ);
-
+        break;
+      case 133:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
         condition: elf.sections[2].name == \".comment\" \
       }",
       ELF64_FILE);
-
+          break;
+      case 134:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
         condition: elf.machine == elf.EM_MIPS \
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 135:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -67,7 +80,8 @@ int main(int argc, char** argv)
           elf.number_of_sections == 35 and elf.number_of_segments == 10 \
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 136:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -78,7 +92,8 @@ int main(int argc, char** argv)
             elf.sections[i].name == \".text\") \
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 137:
   assert_true_rule_blob(
       "import \"elf\" \
         rule test { \
@@ -89,7 +104,8 @@ int main(int argc, char** argv)
             elf.segments[i].file_size == 0x95c)\
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 138:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -98,7 +114,8 @@ int main(int argc, char** argv)
           elf.symtab_entries == 80 \
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 139:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -109,7 +126,8 @@ int main(int argc, char** argv)
             elf.symtab[i].name == \"_start_c\") \
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 140:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -121,7 +139,8 @@ int main(int argc, char** argv)
           elf.symtab[68].size == 56 \
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 141:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -130,7 +149,8 @@ int main(int argc, char** argv)
           elf.dynamic[4].val == 0x400484\
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 142:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -140,14 +160,16 @@ int main(int argc, char** argv)
             elf.dynamic[i].val == 0x400000)\
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 143:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
         condition: elf.machine == elf.EM_X86_64 \
       }",
       ELF_x64_FILE);
-
+          break;
+      case 144:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -156,7 +178,8 @@ int main(int argc, char** argv)
           elf.number_of_segments == 7 \
       }",
       ELF_x64_FILE);
-
+          break;
+      case 145:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -167,7 +190,8 @@ int main(int argc, char** argv)
             elf.sections[i].name == \".got.plt\") \
       }",
       ELF_x64_FILE);
-
+          break;
+      case 146:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -178,7 +202,8 @@ int main(int argc, char** argv)
               elf.segments[i].file_size == 0x1b0) \
       }",
       ELF_x64_FILE);
-
+          break;
+      case 147:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -187,7 +212,8 @@ int main(int argc, char** argv)
             elf.symtab_entries == 48  \
       }",
       ELF_x64_FILE);
-
+          break;
+      case 148:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -198,7 +224,8 @@ int main(int argc, char** argv)
             elf.symtab[i].name == \"main\") \
      }",
      ELF_x64_FILE);
-
+          break;
+      case 149:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -210,7 +237,8 @@ int main(int argc, char** argv)
           elf.symtab[20].size == 0 \
       }",
       ELF_x64_FILE);
-
+          break;
+      case 150:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -219,7 +247,8 @@ int main(int argc, char** argv)
           elf.dynamic[13].val == 0x601000 \
      }",
      ELF_x64_FILE);
-
+          break;
+      case 151:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -229,6 +258,7 @@ int main(int argc, char** argv)
             elf.dynamic[i].val == 0x4003c0) \
       }",
       ELF_x64_FILE);
-
+          break;
+  }
   yr_finalize();
 }
diff --git a/tests/test-exception.c b/tests/test-exception.c
index b33b38b4..e74ad439 100644
--- a/tests/test-exception.c
+++ b/tests/test-exception.c
@@ -36,6 +36,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <yara.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 #define COUNT 128
 char wbuf[1024];
@@ -229,12 +230,16 @@ int main(int argc, char **argv)
   if (op == NULL)
   {
     int status;
+    int index = defects4cpp_test_index();
+    switch (index) {
+        case 152:
     puts("Test: crash");
     setenv("TEST_OP", "CRASH", 1);
     status = reexec(argv[0]);
     if (status != 0)
       return 1;
-
+            break;
+        case 153:
     puts("Test: crash-no-handle");
     setenv("TEST_OP", "CRASH-NO-HANDLE", 1);
     status = reexec(argv[0]);
@@ -243,13 +248,15 @@ int main(int argc, char **argv)
       fputs("Expected subprocess to be terminated by signal\n", stderr);
       return 1;
     }
-
+            break;
+        case 154:
     puts("Test: blocked-signal");
     setenv("TEST_OP", "BLOCKED-SIGNAL", 1);
     status = reexec(argv[0]);
     if (status != 0)
       return 1;
-
+            break;
+        case 155:
     puts("Test: crash-other-thread");
     setenv("TEST_OP", "CRASH-OTHER-THREAD", 1);
     status = reexec(argv[0]);
@@ -258,7 +265,8 @@ int main(int argc, char **argv)
       fputs("Expected subprocess to be terminated by signal\n", stderr);
       return 1;
     }
-
+            break;
+    }
     puts("Done.");
   }
   else if (!strcmp(op, "CRASH"))
diff --git a/tests/test-macho.c b/tests/test-macho.c
index 58c8950f..11a216ab 100644
--- a/tests/test-macho.c
+++ b/tests/test-macho.c
@@ -3,6 +3,7 @@
 #include <unistd.h>
 #include "util.h"
 #include "blob.h"
+#include "defects4cpp.h"
 
 int main(int argc, char** argv)
 {
@@ -11,40 +12,56 @@ int main(int argc, char** argv)
     chdir(top_srcdir);
 
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 156:
   //  Tests for executable files
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.cputype == macho.CPU_TYPE_X86 }", MACHO_X86_FILE);
+          break;
+      case 157:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.filetype == macho.MH_EXECUTE }", MACHO_X86_FILE);
+          break;
+      case 158:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.flags & macho.MH_PIE }", MACHO_X86_FILE);
-
+          break;
+      case 159:
   // Segments
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.number_of_segments == 4 }", MACHO_X86_FILE);
+          break;
+      case 160:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[0].segname == \"__PAGEZERO\" and \
     macho.segments[1].segname == \"__TEXT\" and \
     macho.segments[2].segname == \"__DATA\" and \
     macho.segments[3].segname == \"__LINKEDIT\" }", MACHO_X86_FILE);
+          break;
+      case 161:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[0].vmaddr == 0 and \
     macho.segments[0].vmsize == 0x1000 and \
     macho.segments[2].nsects == 2 and \
     macho.segments[3].fsize == 0x118 }", MACHO_X86_FILE);
-
+          break;
+      case 162:
   // Sections
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[1].sections[0].addr == 0x1e90 and \
     macho.segments[1].sections[0].size == 0xa6 and \
     macho.segments[1].sections[0].offset == 0x0e90 }", MACHO_X86_FILE);
+          break;
+      case 163:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[1].sections[0].sectname == \"__text\" and \
     macho.segments[1].sections[0].segname == \"__TEXT\" }", MACHO_X86_FILE);
+          break;
+      case 164:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[1].sections[1].sectname == \"__symbol_stub\" and \
     macho.segments[1].sections[2].sectname == \"__stub_helper\" and \
@@ -53,19 +70,24 @@ int main(int argc, char** argv)
     macho.segments[2].sections[0].sectname == \"__nl_symbol_ptr\" and \
     macho.segments[2].sections[1].sectname == \"__la_symbol_ptr\" }",
     MACHO_X86_FILE);
-
+          break;
+      case 165:
   // Entry point (LC_MAIN)
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.entry_point == 0xe90 }", MACHO_X86_FILE);
-
+          break;
+      case 166:
   // Tests for object files
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.cputype == macho.CPU_TYPE_X86 }", MACHO_X86_OBJECT_FILE);
+          break;
+      case 167:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.filetype == macho.MH_OBJECT }", MACHO_X86_OBJECT_FILE);
-
+          break;
+      case 168:
   // Segments and sections
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
@@ -73,14 +95,18 @@ int main(int argc, char** argv)
     macho.segments[0].sections[0].sectname == \"__text\" and \
     macho.segments[0].sections[0].segname == \"__TEXT\" }",
     MACHO_X86_OBJECT_FILE);
-
+          break;
+      case 169:
   // Tests for big-endian byte order
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.cputype == macho.CPU_TYPE_POWERPC }", MACHO_PPC_FILE);
+          break;
+      case 170:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.filetype == macho.MH_EXECUTE }", MACHO_PPC_FILE);
-
+          break;
+      case 171:
   // Segments
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
@@ -92,50 +118,68 @@ int main(int argc, char** argv)
     macho.segments[0].vmsize == 0x1000 and \
     macho.segments[3].fileoff == 65536 and \
     macho.segments[3].fsize == 46032 }", MACHO_PPC_FILE);
-
+          break;
+      case 172:
   // Entry point (LC_UNIXTHREAD)
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.entry_point == 0xeb8 }", MACHO_PPC_FILE);
-
+          break;
+      case 173:
   // Tests for 64-bit and shared library files
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.cputype == macho.CPU_TYPE_X86_64 }", MACHO_X86_64_DYLIB_FILE);
+          break;
+      case 174:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.filetype == macho.MH_DYLIB }", MACHO_X86_64_DYLIB_FILE);
+          break;
+      case 175:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.flags & macho.MH_DYLDLINK and \
     macho.flags & macho.MH_NOUNDEFS and \
     macho.flags & macho.MH_NO_REEXPORTED_DYLIBS and \
     macho.flags & macho.MH_TWOLEVEL }", MACHO_X86_64_DYLIB_FILE);
-
+          break;
+      case 176:
   // Segments and sections
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.number_of_segments == 2 }", MACHO_X86_64_DYLIB_FILE);
+          break;
+      case 177:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[0].segname == \"__TEXT\" and \
     macho.segments[1].segname == \"__LINKEDIT\" }", MACHO_X86_64_DYLIB_FILE);
+          break;
+      case 178:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[1].vmaddr == 0x0000000000001000 and \
     macho.segments[1].vmsize == 0x0000000000001000 and \
     macho.segments[1].nsects == 0 and \
     macho.segments[1].fsize == 128 }", MACHO_X86_64_DYLIB_FILE);
+          break;
+      case 179:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[0].sections[0].sectname == \"__text\" and \
     macho.segments[0].sections[0].segname == \"__TEXT\" }",
     MACHO_X86_64_DYLIB_FILE);
+          break;
+      case 180:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[0].sections[1].addr == 0x0000000000000f98 and \
     macho.segments[0].sections[1].size == 0x0000000000000048 and \
     macho.segments[0].sections[1].offset == 3992 }", MACHO_X86_64_DYLIB_FILE);
-
+          break;
+      case 181:
   // Mach-O Universal Binaries tests
 
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.fat_magic == macho.FAT_MAGIC and macho.nfat_arch == 2 }",
     "tests/data/tiny-universal");
+          break;
+      case 182:
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.fat_arch[0].cputype == macho.CPU_TYPE_I386 and \
     macho.fat_arch[0].cpusubtype == macho.CPU_SUBTYPE_I386_ALL and \
@@ -144,42 +188,53 @@ int main(int argc, char** argv)
     macho.fat_arch[1].cpusubtype == macho.CPU_SUBTYPE_X86_64_ALL | \
     macho.CPU_SUBTYPE_LIB64 and macho.fat_arch[1].align == 12 }",
     "tests/data/tiny-universal");
+          break;
+      case 183:
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.file[0].cputype == macho.fat_arch[0].cputype and \
     macho.file[1].cputype == macho.fat_arch[1].cputype }",
     "tests/data/tiny-universal");
-
+          break;
+      case 184:
   // Entry points for files (LC_MAIN)
 
   assert_true_rule_file("import \"macho\" rule test { \
     strings: $1 = { 55 89 e5 56 83 ec 34 } \
     condition: $1 at macho.file[0].entry_point + macho.fat_arch[0].offset }",
     "tests/data/tiny-universal");
-
+          break;
+      case 185:
   assert_true_rule_file("import \"macho\" rule test { \
     strings: $1 = { 55 48 89 e5 48 83 ec 20 } \
     condition: $1 at macho.file[1].entry_point + macho.fat_arch[1].offset }",
     "tests/data/tiny-universal");
-
+          break;
+      case 186:
   // Helper functions
 
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.file[macho.file_index_for_arch(macho.CPU_TYPE_I386)].entry_point == \
     macho.file[0].entry_point }", "tests/data/tiny-universal");
+          break;
+      case 187:
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.file[macho.file_index_for_arch(macho.CPU_TYPE_X86_64)].entry_point == \
     macho.file[1].entry_point }", "tests/data/tiny-universal");
-
+          break;
+      case 188:
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.file[macho.file_index_for_arch(macho.CPU_TYPE_I386, \
                macho.CPU_SUBTYPE_I386_ALL)].entry_point == \
     macho.file[0].entry_point }", "tests/data/tiny-universal");
+          break;
+      case 189:
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.file[macho.file_index_for_arch(macho.CPU_TYPE_X86_64, \
                macho.CPU_SUBTYPE_X86_64_ALL | \
                macho.CPU_SUBTYPE_LIB64)].entry_point == \
     macho.file[1].entry_point }", "tests/data/tiny-universal");
-
+          break;
+      case 190:
   // Entry point for specific architecture
 
   assert_true_rule_file("import \"macho\" rule test { \
@@ -187,11 +242,13 @@ int main(int argc, char** argv)
     condition: $1 at macho.entry_point_for_arch(macho.CPU_TYPE_I386, \
                                        macho.CPU_SUBTYPE_I386_ALL) }",
     "tests/data/tiny-universal");
-
+          break;
+      case 191:
   assert_true_rule_file("import \"macho\" rule test { \
     strings: $1 = { 55 48 89 e5 48 83 ec 20 } \
     condition: $1 at macho.entry_point_for_arch(macho.CPU_TYPE_X86_64) }",
     "tests/data/tiny-universal");
-
+          break;
+  }
   yr_finalize();
 }
diff --git a/tests/test-math.c b/tests/test-math.c
index e2e497b5..99420b06 100644
--- a/tests/test-math.c
+++ b/tests/test-math.c
@@ -1,11 +1,14 @@
 #include <yara.h>
 #include <stdio.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 int main(int argc, char** argv)
 {
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 192:
   assert_true_rule_blob(
       "import \"math\" \
       rule test { \
@@ -13,7 +16,8 @@ int main(int argc, char** argv)
           math.min(0, 1) == 0 \
       }",
       "A");
-
+          break;
+      case 193:
   assert_true_rule_blob(
       "import \"math\" \
       rule test { \
@@ -21,7 +25,8 @@ int main(int argc, char** argv)
           math.max(0, 1) == 1 \
       }",
       "A");
-
+          break;
+  }
   yr_finalize();
   return 0;
 }
diff --git a/tests/test-pe.c b/tests/test-pe.c
index 4ef377d5..e58858a7 100644
--- a/tests/test-pe.c
+++ b/tests/test-pe.c
@@ -3,6 +3,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 int main(int argc, char** argv)
 {
@@ -11,7 +12,9 @@ int main(int argc, char** argv)
     chdir(top_srcdir);
 
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 194:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -19,7 +22,8 @@ int main(int argc, char** argv)
           pe.imports(\"KERNEL32.dll\", \"DeleteCriticalSection\") \
       }",
       "tests/data/tiny");
-
+          break;
+      case 195:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -27,7 +31,8 @@ int main(int argc, char** argv)
           pe.imports(\"KERNEL32.dll\", \"DeleteCriticalSection\") \
       }",
       "tests/data/tiny-idata-51ff");
-
+          break;
+      case 196:
   assert_false_rule_file(
       "import \"pe\" \
       rule test { \
@@ -35,7 +40,8 @@ int main(int argc, char** argv)
           pe.imports(\"KERNEL32.dll\", \"DeleteCriticalSection\") \
       }",
       "tests/data/tiny-idata-5200");
-
+          break;
+      case 197:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -43,7 +49,8 @@ int main(int argc, char** argv)
           pe.imports(/.*/, /.*CriticalSection/) \
       }",
       "tests/data/tiny");
-
+          break;
+      case 198:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -51,7 +58,8 @@ int main(int argc, char** argv)
           pe.imports(/kernel32\\.dll/i, /.*/) \
       }",
       "tests/data/tiny");
-
+          break;
+      case 199:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -59,7 +67,8 @@ int main(int argc, char** argv)
           pe.imports(/.*/, /.*/) \
       }",
       "tests/data/tiny-idata-5200");
-
+          break;
+      case 200:
   assert_false_rule_file(
       "import \"pe\" \
       rule test { \
@@ -67,7 +76,8 @@ int main(int argc, char** argv)
           pe.imports(/.*/, /.*CriticalSection/) \
       }",
       "tests/data/tiny-idata-5200");
-
+          break;
+      case 201:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -75,7 +85,8 @@ int main(int argc, char** argv)
           pe.number_of_imports == 2 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 202:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -83,7 +94,8 @@ int main(int argc, char** argv)
           pe.number_of_sections == 7 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 203:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -91,7 +103,8 @@ int main(int argc, char** argv)
           pe.entry_point == 0x14E0 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 204:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -100,7 +113,8 @@ int main(int argc, char** argv)
           pe.linker_version.minor == 26 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 205:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -114,11 +128,11 @@ int main(int argc, char** argv)
           pe.sections[6].name == \".tls\" \
       }",
       "tests/data/tiny");
-
+          break;
+      case 206:
   #if defined(HAVE_LIBCRYPTO) || \
       defined(HAVE_WINCRYPT_H) || \
       defined(HAVE_COMMONCRYPTO_COMMONCRYPTO_H)
-
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -126,11 +140,8 @@ int main(int argc, char** argv)
           pe.imphash() == \"1720bf764274b7a4052bbef0a71adc0d\" \
       }",
       "tests/data/tiny");
-
   #endif
-
   #if defined(HAVE_LIBCRYPTO)
-
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -140,9 +151,9 @@ int main(int argc, char** argv)
           pe.signatures[0].subject == \"/C=US/ST=California/L=Menlo Park/O=Quicken, Inc./OU=Operations/CN=Quicken, Inc.\" \
       }",
       "tests/data/079a472d22290a94ebb212aa8015cdc8dd28a968c6b4d3b88acdd58ce2d3b885");
-
   #endif
-
+      break;
+      case 207:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -150,7 +161,8 @@ int main(int argc, char** argv)
           pe.section_index(\".text\") == 0 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 208:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -158,7 +170,8 @@ int main(int argc, char** argv)
           pe.section_index(pe.entry_point) == 0 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 209:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -166,7 +179,8 @@ int main(int argc, char** argv)
           pe.is_32bit() and not pe.is_64bit() \
       }",
       "tests/data/tiny");
-
+          break;
+      case 210:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -174,7 +188,8 @@ int main(int argc, char** argv)
           pe.checksum == 0xA8DC \
       }",
       "tests/data/tiny");
-
+          break;
+      case 211:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -182,7 +197,8 @@ int main(int argc, char** argv)
           pe.checksum == pe.calculate_checksum() \
       }",
       "tests/data/tiny");
-
+          break;
+      case 212:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -190,7 +206,8 @@ int main(int argc, char** argv)
           pe.overlay.offset == 0x8000 and pe.overlay.size == 7 \
       }",
       "tests/data/tiny-overlay");
-
+          break;
+      case 213:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -198,7 +215,8 @@ int main(int argc, char** argv)
          pe.overlay.size == 0 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 214:
   assert_false_rule_file(
       "import \"pe\" \
       rule test { \
@@ -206,7 +224,8 @@ int main(int argc, char** argv)
           pe.checksum == pe.calculate_checksum() \
       }",
       "tests/data/tiny-idata-51ff");
-
+          break;
+  }
   yr_finalize();
   return 0;
 }
diff --git a/tests/test-rules.c b/tests/test-rules.c
index 3b6fd69a..cb7933be 100644
--- a/tests/test-rules.c
+++ b/tests/test-rules.c
@@ -37,6 +37,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <yara.h>
 #include "blob.h"
 #include "util.h"
+#include "defects4cpp.h"
 
 
 static void test_boolean_operators()
@@ -2034,27 +2035,69 @@ int main(int argc, char** argv)
     chdir(top_srcdir);
 
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 215:
   test_boolean_operators();
+          break;
+      case 216:
   test_comparison_operators();
+          break;
+      case 217:
   test_arithmetic_operators();
+          break;
+      case 218:
   test_bitwise_operators();
+          break;
+      case 219:
   test_matches_operator();
+          break;
+      case 220:
   test_syntax();
+          break;
+      case 221:
   test_anonymous_strings();
+          break;
+      case 222:
   test_strings();
+          break;
+      case 223:
   test_wildcard_strings();
+          break;
+      case 224:
   test_hex_strings();
+          break;
+      case 225:
   test_count();
+          break;
+      case 226:
   test_at();
+          break;
+      case 227:
   test_in();
+          break;
+      case 228:
   test_offset();
+          break;
+      case 229:
   test_length();
+          break;
+      case 230:
   test_of();
+          break;
+      case 231:
   test_for();
+          break;
+      case 232:
   test_re();
+          break;
+      case 233:
   test_filesize();
+          break;
+      case 234:
   test_include_files();
+          break;
+      case 235:
   // test_compile_file();
   // test_compile_files();
 
@@ -2062,24 +2105,37 @@ int main(int argc, char** argv)
   // test_callback();
   // test_compare();
   test_comments();
+          break;
+      case 236:
   test_modules();
+          break;
+      case 237:
   test_integer_functions();
+          break;
+      case 238:
   // test_string_io();
   test_entrypoint();
+          break;
+      case 239:
   test_global_rules();
-
+          break;
+      case 240:
   #if !defined(USE_WINDOWS_PROC) && !defined(USE_NO_PROC)
   test_process_scan();
   #endif
-
+          break;
+      case 241:
   #if defined(HASH_MODULE)
   test_hash_module();
   #endif
-
+          break;
+      case 242:
   test_time_module();
+          break;
+      case 243:
   test_performance_warnings();
-
+          break;
+  }
   yr_finalize();
-
   return 0;
 }
diff --git a/tests/test-stack.c b/tests/test-stack.c
index ee4ce060..7dbd9c8f 100644
--- a/tests/test-stack.c
+++ b/tests/test-stack.c
@@ -31,6 +31,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <yara/stack.h>
 #include <yara.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 
 int main(int argc, char** argv)
@@ -42,6 +43,9 @@ int main(int argc, char** argv)
   yr_initialize();
   yr_stack_create(1, sizeof(item),  &stack);
 
+  int index = defects4cpp_test_index();
+  switch (index) {
+    case 244:
   item = 1;
 
   if (yr_stack_push(stack, &item) != ERROR_SUCCESS)
@@ -77,5 +81,7 @@ int main(int argc, char** argv)
   if (yr_stack_pop(stack, &item) || item != 1)
     exit(EXIT_FAILURE);
 
+        break;
+  }
   yr_stack_destroy(stack);
 }
-- 
2.25.1

