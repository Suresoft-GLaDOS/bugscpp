From b71f7199510912a0c35677dc44f346440bde809a Mon Sep 17 00:00:00 2001
From: haku <gentlebuuny@gmail.com>
Date: Wed, 1 Sep 2021 10:41:03 +0900
Subject: [PATCH] split tests

---
 tests/defects4cpp.h    |  11 ++++
 tests/defects4cpp.lua  |   1 +
 tests/test-alignment.c | 100 ++++++++++++++++++++++++++++++---
 tests/test-api.c       |  21 ++++++-
 tests/test-arena.c     |   8 +++
 tests/test-atoms.c     | 122 +++++++++++++++++++++++++++++++++++------
 tests/test-bitmask.c   |  11 +++-
 tests/test-dex.c       |  64 ++++++++++++++-------
 tests/test-dotnet.c    |  24 ++++++--
 tests/test-elf.c       |  86 +++++++++++++++++++----------
 tests/test-exception.c |  16 ++++--
 tests/test-macho.c     |  97 +++++++++++++++++++++++++-------
 tests/test-math.c      |  11 +++-
 tests/test-pb.c        |  11 +++-
 tests/test-pe.c        |  98 +++++++++++++++++++++------------
 tests/test-re-split.c  |   7 ++-
 tests/test-rules.c     |  69 +++++++++++++++++++++--
 tests/test-stack.c     |   6 ++
 18 files changed, 609 insertions(+), 154 deletions(-)
 create mode 100644 tests/defects4cpp.h
 create mode 100644 tests/defects4cpp.lua

diff --git a/tests/defects4cpp.h b/tests/defects4cpp.h
new file mode 100644
index 00000000..39a25b15
--- /dev/null
+++ b/tests/defects4cpp.h
@@ -0,0 +1,11 @@
+#include <lua5.3/lualib.h>
+#include <lua5.3/lauxlib.h>
+
+static int defects4cpp_test_index() {
+  lua_State *L = luaL_newstate();
+  luaL_openlibs(L);
+  luaL_dofile(L, "tests/defects4cpp.lua");
+  int ret = lua_tonumber(L, -1);
+  lua_close(L);
+  return ret;
+}
diff --git a/tests/defects4cpp.lua b/tests/defects4cpp.lua
new file mode 100644
index 00000000..a4325f62
--- /dev/null
+++ b/tests/defects4cpp.lua
@@ -0,0 +1 @@
+return 1
diff --git a/tests/test-alignment.c b/tests/test-alignment.c
index e0052677..5f6e0d83 100644
--- a/tests/test-alignment.c
+++ b/tests/test-alignment.c
@@ -31,6 +31,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <stdio.h>
 #undef NDEBUG
 #include <assert.h>
+#include "defects4cpp.h"
 
 int err = 0;
 
@@ -68,57 +69,140 @@ int err = 0;
 
 int main (int argc, char **argv)
 {
+  int index = defects4cpp_test_index();
+  switch (index) {
+    case 1:
   CHECK_SIZE(YR_NAMESPACE, 16);
+      break;
+    case 2:
   CHECK_OFFSET(YR_NAMESPACE, 0, name);
+      break;
+    case 3:
   CHECK_OFFSET(YR_NAMESPACE, 8, idx);
-
+      break;
+    case 4:
   CHECK_SIZE(YR_META, 32);
+      break;
+    case 5:
   CHECK_OFFSET(YR_META, 0, identifier);
+      break;
+    case 6:
   CHECK_OFFSET(YR_META, 8, string);
+      break;
+    case 7:
   CHECK_OFFSET(YR_META, 16,  integer);
+      break;
+    case 8:
   CHECK_OFFSET(YR_META, 24,  type);
+      break;
+    case 9:
   CHECK_OFFSET(YR_META, 28,  flags);
-
+      break;
+    case 10:
   CHECK_SIZE(YR_STRING, 56);
+      break;
+    case 11:
   CHECK_OFFSET(YR_STRING, 0, flags);
+      break;
+    case 12:
   CHECK_OFFSET(YR_STRING, 4, idx);
+      break;
+    case 13:
   CHECK_OFFSET(YR_STRING, 8, fixed_offset);
+      break;
+    case 14:
   CHECK_OFFSET(YR_STRING, 16, rule_idx);
+      break;
+    case 15:
   CHECK_OFFSET(YR_STRING, 20, length);
+      break;
+    case 16:
   CHECK_OFFSET(YR_STRING, 24, string);
+      break;
+    case 17:
   CHECK_OFFSET(YR_STRING, 32, chained_to);
+      break;
+    case 18:
   CHECK_OFFSET(YR_STRING, 40, chain_gap_min);
+      break;
+    case 19:
   CHECK_OFFSET(YR_STRING, 44, chain_gap_max);
+      break;
+    case 20:
   CHECK_OFFSET(YR_STRING, 48, identifier);
-
+      break;
+    case 21:
   CHECK_SIZE(YR_RULE, 48);
+      break;
+    case 22:
   CHECK_OFFSET(YR_RULE, 8,  identifier);
+      break;
+    case 23:
   CHECK_OFFSET(YR_RULE, 16, tags);
+      break;
+    case 24:
   CHECK_OFFSET(YR_RULE, 24, metas);
+      break;
+    case 25:
   CHECK_OFFSET(YR_RULE, 32, strings);
+      break;
+    case 26:
   CHECK_OFFSET(YR_RULE, 40, ns);
-
+      break;
+    case 27:
   CHECK_SIZE(YR_SUMMARY, 12);
+      break;
+    case 28:
   CHECK_OFFSET(YR_SUMMARY, 0,  num_rules);
+      break;
+    case 29:
   CHECK_OFFSET(YR_SUMMARY, 4,  num_strings);
+      break;
+    case 30:
   CHECK_OFFSET(YR_SUMMARY, 8,  num_namespaces);
-
+      break;
+    case 31:
   CHECK_SIZE(YR_EXTERNAL_VARIABLE, 24);
+      break;
+    case 32:
   CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 8,  value.i);
+      break;
+    case 33:
   CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 8,  value.f);
+      break;
+    case 34:
   CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 8,  value.s);
+      break;
+    case 35:
   CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 16, identifier);
-
+      break;
+    case 36:
   CHECK_SIZE(YR_AC_MATCH, 40);
+      break;
+    case 37:
   CHECK_OFFSET(YR_AC_MATCH, 0, string);
+      break;
+    case 38:
   CHECK_OFFSET(YR_AC_MATCH, 8, forward_code);
+      break;
+    case 39:
   CHECK_OFFSET(YR_AC_MATCH, 16, backward_code);
+      break;
+    case 40:
   CHECK_OFFSET(YR_AC_MATCH, 24, next);
+      break;
+    case 41:
   CHECK_OFFSET(YR_AC_MATCH, 32, backtrack);
-
+      break;
+    case 42:
   CHECK_SIZE(SIZED_STRING, 12);
+      break;
+    case 43:
   CHECK_OFFSET(SIZED_STRING, 4, flags);
+      break;
+    case 44:
   CHECK_OFFSET(SIZED_STRING, 8, c_string);
-
+      break;
+  }
   return err;
 }
diff --git a/tests/test-api.c b/tests/test-api.c
index cb2b677e..4ac6b5b8 100644
--- a/tests/test-api.c
+++ b/tests/test-api.c
@@ -10,6 +10,8 @@
 #endif
 #include <fcntl.h>
 
+#include "defects4cpp.h"
+
 void test_disabled_rules()
 {
   YR_RULES* rules;
@@ -802,13 +804,27 @@ int main(int argc, char** argv)
   char *top_srcdir = getenv("TOP_SRCDIR");
   if (top_srcdir)
     chdir(top_srcdir);
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 45:
   test_disabled_rules();
+          break;
+      case 46:
   test_file_descriptor();
+          break;
+      case 47:
   test_max_string_per_rules();
+          break;
+      case 48:
   test_max_match_data();
+          break;
+      case 49:
   test_include_callback();
+          break;
+      case 50:
   test_save_load_rules();
+          break;
+      case 51:
   test_scanner();
 // test_ast_callback();
 // //TODO(vmalvarez): Enable these tests.
@@ -816,6 +832,7 @@ int main(int argc, char** argv)
 //
 // test_issue_834();
 // test_issue_920();
-
+          break;
+  }
   return 0;
 }
diff --git a/tests/test-arena.c b/tests/test-arena.c
index 2853ef27..87b1e985 100644
--- a/tests/test-arena.c
+++ b/tests/test-arena.c
@@ -31,6 +31,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <yara/stream.h>
 #include <yara.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 static void basic_tests()
 {
@@ -172,8 +173,15 @@ static void advanced_tests()
 
 int main(int argc, char** argv)
 {
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 52:
   basic_tests();
+          break;
+      case 53:
   advanced_tests();
+          break;
+  }
 
   return 0;
 }
diff --git a/tests/test-atoms.c b/tests/test-atoms.c
index db4e39cd..e2b7e9e3 100644
--- a/tests/test-atoms.c
+++ b/tests/test-atoms.c
@@ -29,6 +29,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <yara.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 
 void test_table_quality()
@@ -62,19 +63,42 @@ void test_table_quality()
   c.quality_table = l1;
   c.quality_table_entries = 3;
 
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 54:
   assert_true_expr(yr_atoms_table_quality(&c, &a0) == 1);
+          break;
+      case 55:
   assert_true_expr(yr_atoms_table_quality(&c, &a1) == 2);
+          break;
+      case 56:
   assert_true_expr(yr_atoms_table_quality(&c, &a2) == 3);
+          break;
+      case 57:
   assert_true_expr(yr_atoms_table_quality(&c, &a3) == YR_MAX_ATOM_QUALITY);
+          break;
+  }
 
   c.quality_table = l2;
   c.quality_table_entries = 4;
 
+  switch (index) {
+      case 58:
   assert_true_expr(yr_atoms_table_quality(&c, &a0) == 1);
+          break;
+      case 59:
   assert_true_expr(yr_atoms_table_quality(&c, &a1) == 2);
+          break;
+      case 60:
   assert_true_expr(yr_atoms_table_quality(&c, &a2) == 3);
+          break;
+      case 61:
   assert_true_expr(yr_atoms_table_quality(&c, &a3) == 4);
+          break;
+      case 62:
   assert_true_expr(yr_atoms_table_quality(&c, &a4) == 1);
+          break;
+  }
 }
 
 
@@ -180,28 +204,72 @@ void test_heuristic_quality()
 
   int q010X0X   = yr_atoms_heuristic_quality(&c, &a010203);
 
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 63:
   assert_true_expr(q00000001 > q00000000);
+          break;
+      case 64:
   assert_true_expr(q00000001 > q000001);
+          break;
+      case 65:
   assert_true_expr(q000001   > q0001);
+          break;
+      case 66:
   assert_true_expr(q00000102 > q00000001);
+          break;
+      case 67:
   assert_true_expr(q00010203 > q00000102);
+          break;
+      case 68:
   assert_true_expr(q01020304 > q00010203);
+          break;
+      case 69:
   assert_true_expr(q000102   > q000001);
+          break;
+      case 70:
   assert_true_expr(q00010203 > q010203);
+          break;
+      case 71:
   assert_true_expr(q010203   > q0102);
+          break;
+      case 72:
   assert_true_expr(q0102     > q01);
+          break;
+      case 73:
   assert_true_expr(q01X203   > q0102);
+          break;
+      case 74:
   assert_true_expr(q01X203   > q0001);
+          break;
+      case 75:
   assert_true_expr(q01X203   < q010203);
+          break;
+      case 76:
   assert_true_expr(q01X203   == q010X03);
+          break;
+      case 77:
   assert_true_expr(q01XX03   <= q0102);
+          break;
+      case 78:
   assert_true_expr(q01XX03   < q010X03);
+          break;
+      case 79:
   assert_true_expr(q01XX03   < q010203);
+          break;
+      case 80:
   assert_true_expr(q010X0X   > q01);
+          break;
+      case 81:
   assert_true_expr(q010X0X   < q010203);
+          break;
+      case 82:
   assert_true_expr(q01020000 > q0102XX04);
-
+          break;
+      case 83:
   assert_true_expr(q01020304 == YR_MAX_ATOM_QUALITY);
+          break;
+  }
 }
 
 
@@ -506,72 +574,92 @@ void test_atom_choose()
       {3, {0x61, 0x6F, 0x63}},
     };
 
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 84:
     assert_re_atoms("abcd", 1, (struct atom[]) {
       {4, {0x61, 0x62, 0x63, 0x64}},
     });
-
+          break;
+      case 85:
     assert_re_atoms("abcd1234", 1, (struct atom[]) {
       {4, {0x31, 0x32, 0x33, 0x34}},
     });
-
+          break;
+      case 86:
     assert_re_atoms("a..d", 1, (struct atom[]) {
       {1, {0x61}},
     });
-
+          break;
+      case 87:
     assert_re_atoms("a..de", 1, (struct atom[]) {
       {2, {0x64, 0x65}},
     });
-
+          break;
+      case 88:
     assert_re_atoms("abcd.efgh", 1, (struct atom[]) {
       {4, {0x61, 0x62, 0x63, 0x64}},
     });
-
+          break;
+      case 89:
     assert_re_atoms("(abcd|efgh)", 2, (struct atom[]) {
       {4, {0x65, 0x66, 0x67, 0x68}},
       {4, {0x61, 0x62, 0x63, 0x64}},
     });
-
+          break;
+      case 90:
     assert_re_atoms("(abcd|efgh|ij)", 3, (struct atom[]) {
       {2, {0x69, 0x6A}},
       {4, {0x65, 0x66, 0x67, 0x68}},
       {4, {0x61, 0x62, 0x63, 0x64}},
     });
-
+          break;
+      case 91:
     assert_re_atoms("a.cd", 256, atoms_61_XX_63_64);
-
+          break;
+      case 92:
     assert_hex_atoms("{61 62 63 64}", 1, (struct atom[]) {
       {4, {0x61, 0x62, 0x63, 0x64}},
     });
-
+          break;
+      case 93:
     assert_hex_atoms("{61 62 63 64 [1-5] 65 66 67 68}", 1, (struct atom[]) {
       {4, {0x61, 0x62, 0x63, 0x64}},
     });
-
+          break;
+      case 94:
     assert_hex_atoms("{61 62 63 [1-5] 65 66 67 68}", 1, (struct atom[]) {
       {4, {0x65, 0x66, 0x67, 0x68}},
     });
-
+          break;
+      case 95:
     assert_hex_atoms("{61 62 63 [1-5] 65 66 }", 1, (struct atom[]) {
       {3, {0x61, 0x62, 0x63}},
     });
-
+          break;
+      case 96:
     assert_hex_atoms("{61 6? 63 [1-5] 65 66 }", 16, atoms_61_6X_63);
-
+          break;
+      case 97:
     assert_hex_atoms("{(61 62 63 | 65 66 67 68)}", 2, (struct atom[]) {
       {4, {0x65, 0x66, 0x67, 0x68}},
       {3, {0x61, 0x62, 0x63}},
     });
-
+          break;
+      case 98:
     assert_hex_atoms("{61 62 0? 64}", 16, atoms_61_62_0X_64);
-
+          break;
+      case 99:
     assert_hex_atoms("{11 ?? 11 ?? 22 33 44 55 66 }", 1, (struct atom[]) {
       {4, {0x22, 0x33, 0x44, 0x55}},
     });
-
+        break;
+      case 100:
     // Test case for issue #1025
     assert_hex_atoms("{?? 11 22 33 ?? 55 66 }", 1, (struct atom[]) {
       {3, {0x11, 0x22, 0x33}},
     });
+  }
 }
 
 
diff --git a/tests/test-bitmask.c b/tests/test-bitmask.c
index f721369a..26434b57 100644
--- a/tests/test-bitmask.c
+++ b/tests/test-bitmask.c
@@ -31,6 +31,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <yara/bitmask.h>
 #include <yara.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 #define BITMAP_SIZE 512
 
@@ -231,9 +232,17 @@ void test_find_non_colliding_offsets_2()
 
 int main(int argc, char** argv)
 {
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 101:
   test_set_clear();
+          break;
+      case 102:
   test_find_non_colliding_offsets_1();
+          break;
+      case 103:
   test_find_non_colliding_offsets_2();
-
+          break;
+  }
   return 0;
 }
diff --git a/tests/test-dex.c b/tests/test-dex.c
index 9b51e302..65c0ebe6 100644
--- a/tests/test-dex.c
+++ b/tests/test-dex.c
@@ -1,107 +1,131 @@
 #include <yara.h>
 #include "util.h"
 #include "blob.h"
+#include "defects4cpp.h"
 
 int main(int argc, char** argv)
 {
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 104:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.header.magic == \
         dex.DEX_FILE_MAGIC_035 }",
       DEX_FILE);
-
+          break;
+      case 105:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.header.checksum == \
         0x3F9C602F }",
       DEX_FILE);
-
+          break;
+      case 106:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.header.data_size == \
         0x18C }",
       DEX_FILE);
-
+          break;
+      case 107:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.string_ids[0].value ==\
       \"<clinit>\" }",
       DEX_FILE);
-
+          break;
+      case 108:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.string_ids[8].value == \
         \"com.google.helloyara\" }",
       DEX_FILE);
-
+          break;
+      case 109:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.type_ids[0].descriptor_idx == \
         0x2 }",
       DEX_FILE);
-
+          break;
+      case 110:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.proto_ids[0].shorty_idx == \
         0x6 }",
       DEX_FILE);
-
+          break;
+      case 111:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.field_ids[0].class_idx == \
         0x1 }",
       DEX_FILE);
-
+          break;
+      case 112:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.method_ids[0].class_idx == \
         0x1 }",
       DEX_FILE);
-
+          break;
+      case 113:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.class_defs[0].class_idx == \
         0x1 }",
       DEX_FILE);
-
+          break;
+      case 114:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.number_of_fields == 2 }",
       DEX_FILE);
-
+          break;
+      case 115:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.field[0].class_name == \
         \"Lcom/android/tools/ir/server/AppInfo;\" }",
       DEX_FILE);
-
+          break;
+      case 116:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.field[0].name == \
         \"applicationId\" }",
       DEX_FILE);
-
+          break;
+      case 117:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.number_of_methods == 2 }",
       DEX_FILE);
-
+          break;
+      case 118:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.method[0].class_name == \
         \"Lcom/android/tools/ir/server/AppInfo;\" }",
       DEX_FILE);
-
+          break;
+      case 119:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.method[0].proto == \"V\" }",
       DEX_FILE);
-
+          break;
+      case 120:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.method[0].name == \
         \"<clinit>\" }",
       DEX_FILE);
-
+          break;
+      case 121:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.method[1].name == \
         \"<init>\" }",
       DEX_FILE);
-
+          break;
+      case 122:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: dex.map_list.size == 12 }",
       DEX_FILE);
-
+          break;
+      case 123:
   assert_true_rule_blob(
       "import \"dex\" rule test { condition: \
           dex.map_list.map_item[0].type == dex.TYPE_HEADER_ITEM \
         }",
       DEX_FILE);
+          break;
+  }
 
   yr_finalize();
   return 0;
diff --git a/tests/test-dotnet.c b/tests/test-dotnet.c
index a5a3b602..e66f0f55 100644
--- a/tests/test-dotnet.c
+++ b/tests/test-dotnet.c
@@ -3,6 +3,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 int main(int argc, char** argv)
 {
@@ -12,6 +13,9 @@ int main(int argc, char** argv)
 
   yr_initialize();
 
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 124:
   assert_true_rule_file(
       "import \"dotnet\" \
       rule test { \
@@ -19,7 +23,8 @@ int main(int argc, char** argv)
           dotnet.assembly.name == \"hpjsoaputility.Sv.resources\" \
       }",
       "tests/data/0ca09bde7602769120fadc4f7a4147347a7a97271370583586c9e587fd396171");
-
+          break;
+      case 125:
   assert_true_rule_file(
       "import \"dotnet\" \
       rule test { \
@@ -30,7 +35,8 @@ int main(int argc, char** argv)
           dotnet.resources[0].name == \"hpjsoaputility.XmlStreamSoapExtension.pt.resources\" \
       }",
       "tests/data/0ca09bde7602769120fadc4f7a4147347a7a97271370583586c9e587fd396171");
-
+          break;
+      case 126:
   assert_true_rule_file(
       "import \"dotnet\" \
       rule test { \
@@ -39,7 +45,8 @@ int main(int argc, char** argv)
           dotnet.guids[0] == \"3764d539-e21a-4366-bc7c-b56fa67efbb0\" \
       }",
       "tests/data/0ca09bde7602769120fadc4f7a4147347a7a97271370583586c9e587fd396171");
-
+          break;
+      case 127:
   assert_true_rule_file(
       "import \"dotnet\" \
       rule test { \
@@ -52,7 +59,8 @@ int main(int argc, char** argv)
           dotnet.streams[4].name == \"#Blob\" \
       }",
       "tests/data/0ca09bde7602769120fadc4f7a4147347a7a97271370583586c9e587fd396171");
-
+          break;
+      case 128:
   assert_true_rule_file(
       "import \"dotnet\" \
       rule test { \
@@ -61,7 +69,8 @@ int main(int argc, char** argv)
           dotnet.version == \"v2.0.50727\" \
       }",
       "tests/data/0ca09bde7602769120fadc4f7a4147347a7a97271370583586c9e587fd396171");
-
+          break;
+      case 129:
   assert_true_rule_file(
       "import \"dotnet\" \
       rule test { \
@@ -71,7 +80,8 @@ int main(int argc, char** argv)
           dotnet.guids[1] == \"00000000-0000-0000-0000-000000000000\" \
       }",
       "tests/data/33fc70f99be6d2833ae48852d611c8048d0c053ed0b2c626db4dbe902832a08b");
-
+          break;
+      case 130:
   assert_true_rule_file(
       "import \"dotnet\" \
       rule test { \
@@ -79,6 +89,8 @@ int main(int argc, char** argv)
           dotnet.user_strings[0] == \"F\\x00r\\x00e\\x00e\\x00D\\x00i\\x00s\\x00c\\x00B\\x00u\\x00r\\x00n\\x00e\\x00r\\x00.\\x00S\\x00t\\x00r\\x00i\\x00n\\x00g\\x00R\\x00e\\x00s\\x00o\\x00u\\x00r\\x00c\\x00e\\x00s\\x00\" \
       }",
       "tests/data/33fc70f99be6d2833ae48852d611c8048d0c053ed0b2c626db4dbe902832a08b");
+          break;
+  }
   yr_finalize();
   return 0;
 }
diff --git a/tests/test-elf.c b/tests/test-elf.c
index df010bcc..f5628a19 100644
--- a/tests/test-elf.c
+++ b/tests/test-elf.c
@@ -1,27 +1,34 @@
 #include <yara.h>
 #include "util.h"
 #include "blob.h"
+#include "defects4cpp.h"
 
 int main(int argc, char** argv)
 {
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 131:
   assert_true_rule_blob(
       "import \"elf\" rule test { condition: elf.type }",
       ELF32_FILE);
-
+          break;
+      case 132:
   assert_true_rule_blob(
       "import \"elf\" rule test { condition: elf.type }",
       ELF64_FILE);
-
+          break;
+      case 133:
   assert_true_rule_blob(
       "import \"elf\" rule test { condition: elf.machine == elf.EM_386 }",
       ELF32_FILE)
-
+          break;
+      case 134:
   assert_true_rule_blob(
       "import \"elf\" rule test { condition: elf.machine == elf.EM_X86_64 }",
       ELF64_FILE)
-
+          break;
+      case 135:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -29,7 +36,8 @@ int main(int argc, char** argv)
         condition: $a at elf.entry_point \
       }",
       ELF32_FILE);
-
+          break;
+      case 136:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -37,29 +45,34 @@ int main(int argc, char** argv)
         condition: $a at elf.entry_point \
       }",
       ELF64_FILE);
-
+          break;
+      case 137:
   assert_true_rule_blob(
       "import \"elf\" rule test { condition: elf.entry_point == 0xa0 }",
       ELF32_NOSECTIONS);
-
+          break;
+      case 138:
   assert_true_rule_blob(
       "import \"elf\" rule test { condition: elf.entry_point == 0x1a0 }",
       ELF32_SHAREDOBJ);
-
+        break;
+      case 139:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
         condition: elf.sections[2].name == \".comment\" \
       }",
       ELF64_FILE);
-
+          break;
+      case 140:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
         condition: elf.machine == elf.EM_MIPS \
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 141:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -67,7 +80,8 @@ int main(int argc, char** argv)
           elf.number_of_sections == 35 and elf.number_of_segments == 10 \
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 142:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -78,7 +92,8 @@ int main(int argc, char** argv)
             elf.sections[i].name == \".text\") \
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 143:
   assert_true_rule_blob(
       "import \"elf\" \
         rule test { \
@@ -89,7 +104,8 @@ int main(int argc, char** argv)
             elf.segments[i].file_size == 0x95c)\
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 144:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -98,7 +114,8 @@ int main(int argc, char** argv)
           elf.symtab_entries == 80 \
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 145:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -109,7 +126,8 @@ int main(int argc, char** argv)
             elf.symtab[i].name == \"_start_c\") \
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 146:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -121,7 +139,8 @@ int main(int argc, char** argv)
           elf.symtab[68].size == 56 \
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 147:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -130,7 +149,8 @@ int main(int argc, char** argv)
           elf.dynamic[4].val == 0x400484\
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 148:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -140,14 +160,16 @@ int main(int argc, char** argv)
             elf.dynamic[i].val == 0x400000)\
       }",
       ELF32_MIPS_FILE);
-
+          break;
+      case 149:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
         condition: elf.machine == elf.EM_X86_64 \
       }",
       ELF_x64_FILE);
-
+          break;
+      case 150:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -156,7 +178,8 @@ int main(int argc, char** argv)
           elf.number_of_segments == 7 \
       }",
       ELF_x64_FILE);
-
+          break;
+      case 151:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -167,7 +190,8 @@ int main(int argc, char** argv)
             elf.sections[i].name == \".got.plt\") \
       }",
       ELF_x64_FILE);
-
+          break;
+      case 152:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -178,7 +202,8 @@ int main(int argc, char** argv)
               elf.segments[i].file_size == 0x1b0) \
       }",
       ELF_x64_FILE);
-
+          break;
+      case 153:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -187,7 +212,8 @@ int main(int argc, char** argv)
             elf.symtab_entries == 48  \
       }",
       ELF_x64_FILE);
-
+          break;
+      case 154:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -198,7 +224,8 @@ int main(int argc, char** argv)
             elf.symtab[i].name == \"main\") \
      }",
      ELF_x64_FILE);
-
+          break;
+      case 155:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -210,7 +237,8 @@ int main(int argc, char** argv)
           elf.symtab[20].size == 0 \
       }",
       ELF_x64_FILE);
-
+          break;
+      case 156:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -219,7 +247,8 @@ int main(int argc, char** argv)
           elf.dynamic[13].val == 0x601000 \
      }",
      ELF_x64_FILE);
-
+          break;
+      case 157:
   assert_true_rule_blob(
       "import \"elf\" \
       rule test { \
@@ -229,7 +258,8 @@ int main(int argc, char** argv)
             elf.dynamic[i].val == 0x4003c0) \
       }",
       ELF_x64_FILE);
-
+          break;
+  }
   yr_finalize();
   return 0;
 }
diff --git a/tests/test-exception.c b/tests/test-exception.c
index edf96628..4a084a46 100644
--- a/tests/test-exception.c
+++ b/tests/test-exception.c
@@ -36,6 +36,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <yara.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 #define COUNT 128
 char wbuf[1024];
@@ -239,12 +240,16 @@ int main(int argc, char **argv)
   if (op == NULL)
   {
     int status;
+    int index = defects4cpp_test_index();
+    switch (index) {
+        case 158:
     puts("Test: crash");
     setenv("TEST_OP", "CRASH", 1);
     status = reexec(argv[0]);
     if (status != 0)
       return 1;
-
+            break;
+        case 159:
     puts("Test: crash-no-handle");
     setenv("TEST_OP", "CRASH-NO-HANDLE", 1);
     status = reexec(argv[0]);
@@ -253,13 +258,15 @@ int main(int argc, char **argv)
       fputs("Expected subprocess to be terminated by signal\n", stderr);
       return 1;
     }
-
+            break;
+        case 160:
     puts("Test: blocked-signal");
     setenv("TEST_OP", "BLOCKED-SIGNAL", 1);
     status = reexec(argv[0]);
     if (status != 0)
       return 1;
-
+            break;
+        case 161:
     puts("Test: crash-other-thread");
     setenv("TEST_OP", "CRASH-OTHER-THREAD", 1);
     status = reexec(argv[0]);
@@ -268,7 +275,8 @@ int main(int argc, char **argv)
       fputs("Expected subprocess to be terminated by signal\n", stderr);
       return 1;
     }
-
+            break;
+    }
     puts("Done.");
   }
   else if (!strcmp(op, "CRASH"))
diff --git a/tests/test-macho.c b/tests/test-macho.c
index bd052bb9..4d12ae06 100644
--- a/tests/test-macho.c
+++ b/tests/test-macho.c
@@ -3,6 +3,7 @@
 #include <unistd.h>
 #include "util.h"
 #include "blob.h"
+#include "defects4cpp.h"
 
 int main(int argc, char** argv)
 {
@@ -11,42 +12,58 @@ int main(int argc, char** argv)
     chdir(top_srcdir);
 
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 162:
   //  Tests for executable files
-
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.cputype == macho.CPU_TYPE_X86 }", MACHO_X86_FILE);
+          break;
+      case 163:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.filetype == macho.MH_EXECUTE }", MACHO_X86_FILE);
+          break;
+      case 164:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.flags & macho.MH_PIE }", MACHO_X86_FILE);
-
+          break;
+      case 165:
   // Segments
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.number_of_segments == 4 }", MACHO_X86_FILE);
+          break;
+      case 166:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[0].segname == \"__PAGEZERO\" and \
     macho.segments[1].segname == \"__TEXT\" and \
     macho.segments[2].segname == \"__DATA\" and \
     macho.segments[3].segname == \"__LINKEDIT\" }", MACHO_X86_FILE);
+          break;
+      case 167:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[0].vmaddr == 0 and \
     macho.segments[0].vmsize == 0x1000 and \
     macho.segments[2].nsects == 2 and \
     macho.segments[3].fsize == 0x118 }", MACHO_X86_FILE);
+      case 168:
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.number_of_segments == 1 }", "tests/data/tiny-macho");
-
+          break;
+      case 169:
   // Sections
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[1].sections[0].addr == 0x1e90 and \
     macho.segments[1].sections[0].size == 0xa6 and \
     macho.segments[1].sections[0].offset == 0x0e90 }", MACHO_X86_FILE);
+          break;
+      case 170:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[1].sections[0].sectname == \"__text\" and \
     macho.segments[1].sections[0].segname == \"__TEXT\" }", MACHO_X86_FILE);
+          break;
+      case 171:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[1].sections[1].sectname == \"__symbol_stub\" and \
     macho.segments[1].sections[2].sectname == \"__stub_helper\" and \
@@ -55,19 +72,24 @@ int main(int argc, char** argv)
     macho.segments[2].sections[0].sectname == \"__nl_symbol_ptr\" and \
     macho.segments[2].sections[1].sectname == \"__la_symbol_ptr\" }",
     MACHO_X86_FILE);
-
+          break;
+      case 172:
   // Entry point (LC_MAIN)
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.entry_point == 0xe90 }", MACHO_X86_FILE);
-
+          break;
+      case 173:
   // Tests for object files
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.cputype == macho.CPU_TYPE_X86 }", MACHO_X86_OBJECT_FILE);
+          break;
+      case 174:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.filetype == macho.MH_OBJECT }", MACHO_X86_OBJECT_FILE);
-
+          break;
+      case 175:
   // Segments and sections
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
@@ -75,14 +97,18 @@ int main(int argc, char** argv)
     macho.segments[0].sections[0].sectname == \"__text\" and \
     macho.segments[0].sections[0].segname == \"__TEXT\" }",
     MACHO_X86_OBJECT_FILE);
-
+          break;
+      case 176:
   // Tests for big-endian byte order
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.cputype == macho.CPU_TYPE_POWERPC }", MACHO_PPC_FILE);
+          break;
+      case 177:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.filetype == macho.MH_EXECUTE }", MACHO_PPC_FILE);
-
+          break;
+      case 178:
   // Segments
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
@@ -94,50 +120,68 @@ int main(int argc, char** argv)
     macho.segments[0].vmsize == 0x1000 and \
     macho.segments[3].fileoff == 65536 and \
     macho.segments[3].fsize == 46032 }", MACHO_PPC_FILE);
-
+          break;
+      case 179:
   // Entry point (LC_UNIXTHREAD)
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.entry_point == 0xeb8 }", MACHO_PPC_FILE);
-
+          break;
+      case 180:
   // Tests for 64-bit and shared library files
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.cputype == macho.CPU_TYPE_X86_64 }", MACHO_X86_64_DYLIB_FILE);
+          break;
+      case 181:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.filetype == macho.MH_DYLIB }", MACHO_X86_64_DYLIB_FILE);
+          break;
+      case 182:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.flags & macho.MH_DYLDLINK and \
     macho.flags & macho.MH_NOUNDEFS and \
     macho.flags & macho.MH_NO_REEXPORTED_DYLIBS and \
     macho.flags & macho.MH_TWOLEVEL }", MACHO_X86_64_DYLIB_FILE);
-
+          break;
+      case 183:
   // Segments and sections
 
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.number_of_segments == 2 }", MACHO_X86_64_DYLIB_FILE);
+          break;
+      case 184:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[0].segname == \"__TEXT\" and \
     macho.segments[1].segname == \"__LINKEDIT\" }", MACHO_X86_64_DYLIB_FILE);
+          break;
+      case 185:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[1].vmaddr == 0x0000000000001000 and \
     macho.segments[1].vmsize == 0x0000000000001000 and \
     macho.segments[1].nsects == 0 and \
     macho.segments[1].fsize == 128 }", MACHO_X86_64_DYLIB_FILE);
+          break;
+      case 186:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[0].sections[0].sectname == \"__text\" and \
     macho.segments[0].sections[0].segname == \"__TEXT\" }",
     MACHO_X86_64_DYLIB_FILE);
+          break;
+      case 187:
   assert_true_rule_blob("import \"macho\" rule test { condition: \
     macho.segments[0].sections[1].addr == 0x0000000000000f98 and \
     macho.segments[0].sections[1].size == 0x0000000000000048 and \
     macho.segments[0].sections[1].offset == 3992 }", MACHO_X86_64_DYLIB_FILE);
-
+          break;
+      case 188:
   // Mach-O Universal Binaries tests
 
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.fat_magic == macho.FAT_MAGIC and macho.nfat_arch == 2 }",
     "tests/data/tiny-universal");
+          break;
+      case 189:
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.fat_arch[0].cputype == macho.CPU_TYPE_I386 and \
     macho.fat_arch[0].cpusubtype == macho.CPU_SUBTYPE_I386_ALL and \
@@ -146,42 +190,53 @@ int main(int argc, char** argv)
     macho.fat_arch[1].cpusubtype == macho.CPU_SUBTYPE_X86_64_ALL | \
     macho.CPU_SUBTYPE_LIB64 and macho.fat_arch[1].align == 12 }",
     "tests/data/tiny-universal");
+          break;
+      case 190:
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.file[0].cputype == macho.fat_arch[0].cputype and \
     macho.file[1].cputype == macho.fat_arch[1].cputype }",
     "tests/data/tiny-universal");
-
+          break;
+      case 191:
   // Entry points for files (LC_MAIN)
 
   assert_true_rule_file("import \"macho\" rule test { \
     strings: $1 = { 55 89 e5 56 83 ec 34 } \
     condition: $1 at macho.file[0].entry_point + macho.fat_arch[0].offset }",
     "tests/data/tiny-universal");
-
+          break;
+      case 192:
   assert_true_rule_file("import \"macho\" rule test { \
     strings: $1 = { 55 48 89 e5 48 83 ec 20 } \
     condition: $1 at macho.file[1].entry_point + macho.fat_arch[1].offset }",
     "tests/data/tiny-universal");
-
+          break;
+      case 193:
   // Helper functions
 
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.file[macho.file_index_for_arch(macho.CPU_TYPE_I386)].entry_point == \
     macho.file[0].entry_point }", "tests/data/tiny-universal");
+          break;
+      case 194:
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.file[macho.file_index_for_arch(macho.CPU_TYPE_X86_64)].entry_point == \
     macho.file[1].entry_point }", "tests/data/tiny-universal");
-
+          break;
+      case 195:
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.file[macho.file_index_for_arch(macho.CPU_TYPE_I386, \
                macho.CPU_SUBTYPE_I386_ALL)].entry_point == \
     macho.file[0].entry_point }", "tests/data/tiny-universal");
+          break;
+      case 196:
   assert_true_rule_file("import \"macho\" rule test { condition: \
     macho.file[macho.file_index_for_arch(macho.CPU_TYPE_X86_64, \
                macho.CPU_SUBTYPE_X86_64_ALL | \
                macho.CPU_SUBTYPE_LIB64)].entry_point == \
     macho.file[1].entry_point }", "tests/data/tiny-universal");
-
+          break;
+      case 197:
   // Entry point for specific architecture
 
   assert_true_rule_file("import \"macho\" rule test { \
@@ -189,12 +244,14 @@ int main(int argc, char** argv)
     condition: $1 at macho.entry_point_for_arch(macho.CPU_TYPE_I386, \
                                        macho.CPU_SUBTYPE_I386_ALL) }",
     "tests/data/tiny-universal");
-
+          break;
+      case 198:
   assert_true_rule_file("import \"macho\" rule test { \
     strings: $1 = { 55 48 89 e5 48 83 ec 20 } \
     condition: $1 at macho.entry_point_for_arch(macho.CPU_TYPE_X86_64) }",
     "tests/data/tiny-universal");
-
+          break;
+  }
   yr_finalize();
   return 0;
 }
diff --git a/tests/test-math.c b/tests/test-math.c
index e2e497b5..9150c217 100644
--- a/tests/test-math.c
+++ b/tests/test-math.c
@@ -1,11 +1,14 @@
 #include <yara.h>
 #include <stdio.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 int main(int argc, char** argv)
 {
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 199:
   assert_true_rule_blob(
       "import \"math\" \
       rule test { \
@@ -13,7 +16,8 @@ int main(int argc, char** argv)
           math.min(0, 1) == 0 \
       }",
       "A");
-
+          break;
+      case 200:
   assert_true_rule_blob(
       "import \"math\" \
       rule test { \
@@ -21,7 +25,8 @@ int main(int argc, char** argv)
           math.max(0, 1) == 1 \
       }",
       "A");
-
+          break;
+  }
   yr_finalize();
   return 0;
 }
diff --git a/tests/test-pb.c b/tests/test-pb.c
index 631cd53a..bee454d1 100644
--- a/tests/test-pb.c
+++ b/tests/test-pb.c
@@ -29,12 +29,15 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <yara.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 
 int main(int argc, char** argv)
 {
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 201:
   assert_true_rule_module_data_file(
       "import \"pb_tests\" \
       rule test { \
@@ -45,7 +48,8 @@ int main(int argc, char** argv)
           pb_tests.f_struct_array[0].f_enum == pb_tests.struct.enum.SECOND \
       }",
       "tests/data/test-pb.data.bin");
-
+          break;
+      case 202:
   assert_true_rule_module_data_file(
       "import \"pb_tests\" \
       rule test { \
@@ -55,7 +59,8 @@ int main(int argc, char** argv)
           ) \
       }",
       "tests/data/test-pb.data.bin");
-
+          break;
+  }
   yr_finalize();
   return 0;
 }
diff --git a/tests/test-pe.c b/tests/test-pe.c
index 68144297..05c66e00 100644
--- a/tests/test-pe.c
+++ b/tests/test-pe.c
@@ -3,6 +3,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 int main(int argc, char** argv)
 {
@@ -11,7 +12,9 @@ int main(int argc, char** argv)
     chdir(top_srcdir);
 
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 203:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -19,7 +22,8 @@ int main(int argc, char** argv)
           pe.imports(\"KERNEL32.dll\", \"DeleteCriticalSection\") \
       }",
       "tests/data/tiny");
-
+          break;
+      case 204:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -27,7 +31,8 @@ int main(int argc, char** argv)
           pe.imports(\"KERNEL32.dll\", \"DeleteCriticalSection\") \
       }",
       "tests/data/tiny-idata-51ff");
-
+          break;
+      case 205:
   assert_false_rule_file(
       "import \"pe\" \
       rule test { \
@@ -35,7 +40,8 @@ int main(int argc, char** argv)
           pe.imports(\"KERNEL32.dll\", \"DeleteCriticalSection\") \
       }",
       "tests/data/tiny-idata-5200");
-
+          break;
+      case 206:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -43,7 +49,8 @@ int main(int argc, char** argv)
           pe.imports(/.*/, /.*CriticalSection/) == 4 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 207:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -51,7 +58,8 @@ int main(int argc, char** argv)
           pe.imports(/kernel32\\.dll/i, /.*/) == 21 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 208:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -59,7 +67,8 @@ int main(int argc, char** argv)
           pe.imports(/.*/, /.*/) \
       }",
       "tests/data/tiny-idata-5200");
-
+          break;
+      case 209:
   assert_false_rule_file(
       "import \"pe\" \
       rule test { \
@@ -67,7 +76,8 @@ int main(int argc, char** argv)
           pe.imports(/.*/, /.*CriticalSection/) \
       }",
       "tests/data/tiny-idata-5200");
-
+          break;
+      case 210:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -75,7 +85,8 @@ int main(int argc, char** argv)
           pe.number_of_imports == 2 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 211:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -83,7 +94,8 @@ int main(int argc, char** argv)
           pe.number_of_sections == 7 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 212:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -91,7 +103,8 @@ int main(int argc, char** argv)
           pe.entry_point == 0x14E0 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 213:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -100,7 +113,8 @@ int main(int argc, char** argv)
           pe.linker_version.minor == 26 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 214:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -114,11 +128,11 @@ int main(int argc, char** argv)
           pe.sections[6].name == \".tls\" \
       }",
       "tests/data/tiny");
-
+          break;
+      case 215:
   #if defined(HAVE_LIBCRYPTO) || \
       defined(HAVE_WINCRYPT_H) || \
       defined(HAVE_COMMONCRYPTO_COMMONCRYPTO_H)
-
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -126,11 +140,8 @@ int main(int argc, char** argv)
           pe.imphash() == \"1720bf764274b7a4052bbef0a71adc0d\" \
       }",
       "tests/data/tiny");
-
   #endif
-
   #if defined(HAVE_LIBCRYPTO)
-
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -140,9 +151,9 @@ int main(int argc, char** argv)
           pe.signatures[0].subject == \"/C=US/ST=California/L=Menlo Park/O=Quicken, Inc./OU=Operations/CN=Quicken, Inc.\" \
       }",
       "tests/data/079a472d22290a94ebb212aa8015cdc8dd28a968c6b4d3b88acdd58ce2d3b885");
-
   #endif
-
+      break;
+      case 216:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -150,7 +161,8 @@ int main(int argc, char** argv)
           pe.section_index(\".text\") == 0 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 217:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -158,7 +170,8 @@ int main(int argc, char** argv)
           pe.section_index(pe.entry_point) == 0 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 218:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -166,7 +179,8 @@ int main(int argc, char** argv)
           pe.is_32bit() and not pe.is_64bit() \
       }",
       "tests/data/tiny");
-
+          break;
+      case 219:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -174,7 +188,8 @@ int main(int argc, char** argv)
           pe.checksum == 0xA8DC \
       }",
       "tests/data/tiny");
-
+          break;
+      case 220:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -182,7 +197,8 @@ int main(int argc, char** argv)
           pe.checksum == pe.calculate_checksum() \
       }",
       "tests/data/tiny");
-
+          break;
+      case 221:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -190,7 +206,8 @@ int main(int argc, char** argv)
           pe.overlay.offset == 0x8000 and pe.overlay.size == 7 \
       }",
       "tests/data/tiny-overlay");
-
+          break;
+      case 222:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -198,7 +215,8 @@ int main(int argc, char** argv)
          pe.overlay.size == 0 \
       }",
       "tests/data/tiny");
-
+          break;
+      case 223:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -206,7 +224,8 @@ int main(int argc, char** argv)
           pe.pdb_path == \"D:\\\\workspace\\\\2018_R9_RelBld\\\\target\\\\checkout\\\\custprof\\\\Release\\\\custprof.pdb\" \
       }",
        "tests/data/079a472d22290a94ebb212aa8015cdc8dd28a968c6b4d3b88acdd58ce2d3b885");
-
+          break;
+      case 224:
   assert_false_rule_file(
       "import \"pe\" \
       rule test { \
@@ -214,7 +233,8 @@ int main(int argc, char** argv)
           pe.checksum == pe.calculate_checksum() \
       }",
       "tests/data/tiny-idata-51ff");
-
+          break;
+      case 225:
   /*
    * mtxex.dll is 23e72ce7e9cdbc80c0095484ebeb02f56b21e48fd67044e69e7a2ae76db631e5,
    * which was taken from a Windows 10 install. The details of which are:
@@ -256,7 +276,8 @@ int main(int argc, char** argv)
           pe.export_details[1].forward_name == \"COMSVCS.GetObjectContext\" \
       }",
       "tests/data/mtxex.dll");
-
+          break;
+      case 226:
   // Make sure exports function is case insensitive (historically this has been
   // the case) and supports ordinals...
   assert_true_rule_file(
@@ -268,7 +289,8 @@ int main(int argc, char** argv)
           pe.exports(/mtscreateactivity/i) \
       }",
       "tests/data/mtxex.dll");
-
+          break;
+      case 227:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -278,7 +300,8 @@ int main(int argc, char** argv)
           pe.exports_index(/mtscreateactivity/i) == 2 \
       }",
       "tests/data/mtxex.dll");
-
+          break;
+      case 228:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -286,8 +309,8 @@ int main(int argc, char** argv)
           pe.export_details[0].name == \"CP_PutItem\" \
       }",
       "tests/data/079a472d22290a94ebb212aa8015cdc8dd28a968c6b4d3b88acdd58ce2d3b885.upx");
-
-
+          break;
+      case 229:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -298,9 +321,10 @@ int main(int argc, char** argv)
           pe.rich_signature.version(40219, 170) == 11 \
       }",
       "tests/data/079a472d22290a94ebb212aa8015cdc8dd28a968c6b4d3b88acdd58ce2d3b885");
-
+          break;
   // This is the first 840 bytes (just enough to make sure the rich header is
   // parsed) of 3593d3d08761d8ddc269dde945c0cb07e5cef5dd46ad9eefc22d17901f542093.
+      case 230:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -311,7 +335,8 @@ int main(int argc, char** argv)
           pe.rich_signature.clear_data == \"DanS\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x11\\x00\\x00\\x00\\xc3\\x0f]\\x00\\x03\\x00\\x00\\x00\\x09x\\x95\\x00\\x01\\x00\\x00\\x00\\x09x\\x83\\x00\\x05\\x00\\x00\\x00\\x09x\\x94\\x00\\x01\\x00\\x00\\x00\\x09x\\x91\\x00\\x01\\x00\\x00\\x00\" \
       }",
       "tests/data/weird_rich");
-
+          break;
+      case 231:
   assert_true_rule_file(
       "import \"pe\" \
       rule test { \
@@ -319,7 +344,8 @@ int main(int argc, char** argv)
           pe.language(0x09) and pe.locale(0x0409) \
       }",
       "tests/data/mtxex.dll");
-
+          break;
+  }
   yr_finalize();
   return 0;
 }
diff --git a/tests/test-re-split.c b/tests/test-re-split.c
index b1374f0c..124684c4 100644
--- a/tests/test-re-split.c
+++ b/tests/test-re-split.c
@@ -30,6 +30,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <yara.h>
 #include <stdio.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 
 int main(int argc, char** argv)
@@ -42,6 +43,9 @@ int main(int argc, char** argv)
   int32_t min_gap;
   int32_t max_gap;
 
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 232:
   yr_initialize();
   yr_re_parse_hex(
       "{ 01 02 03 04 [0-300] 05 06 07 08 [1-400] 09 0A 0B 0C }",
@@ -76,8 +80,9 @@ int main(int argc, char** argv)
 
   assert(re_ast != NULL);
   assert(re_ast_remain == NULL);
-
   yr_re_ast_destroy(re_ast);
   yr_finalize();
+          break;
+  }
   return 0;
 }
diff --git a/tests/test-rules.c b/tests/test-rules.c
index af39692f..12934ccf 100644
--- a/tests/test-rules.c
+++ b/tests/test-rules.c
@@ -37,6 +37,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <yara.h>
 #include "blob.h"
 #include "util.h"
+#include "defects4cpp.h"
 
 
 static void test_boolean_operators()
@@ -2808,27 +2809,69 @@ int main(int argc, char** argv)
     chdir(top_srcdir);
 
   yr_initialize();
-
+  int index = defects4cpp_test_index();
+  switch (index) {
+      case 233:
   test_boolean_operators();
+          break;
+      case 234:
   test_comparison_operators();
+          break;
+      case 235:
   test_arithmetic_operators();
+          break;
+      case 236:
   test_bitwise_operators();
+          break;
+      case 237:
   test_matches_operator();
+          break;
+      case 238:
   test_syntax();
+          break;
+      case 239:
   test_anonymous_strings();
+          break;
+      case 240:
   test_strings();
+          break;
+      case 241:
   test_wildcard_strings();
+          break;
+      case 242:
   test_hex_strings();
+          break;
+      case 243:
   test_count();
+          break;
+      case 244:
   test_at();
+          break;
+      case 245:
   test_in();
+          break;
+      case 246:
   test_offset();
+          break;
+      case 247:
   test_length();
+          break;
+      case 248:
   test_of();
+          break;
+      case 249:
   test_for();
+          break;
+      case 250:
   test_re();
+          break;
+      case 251:
   test_filesize();
+          break;
+      case 252:
   test_include_files();
+          break;
+      case 253:
   // test_compile_file();
   // test_compile_files();
 
@@ -2836,24 +2879,40 @@ int main(int argc, char** argv)
   // test_callback();
   // test_compare();
   test_comments();
+          break;
+      case 254:
   test_modules();
+          break;
+      case 255:
   test_integer_functions();
+          break;
+      case 256:
   // test_string_io();
   test_entrypoint();
+          break;
+      case 257:
   test_global_rules();
+      case 258:
+          break;
   test_tags();
-
+          break;
+      case 259:
   #if !defined(USE_WINDOWS_PROC) && !defined(USE_NO_PROC)
   test_process_scan();
   #endif
-
+          break;
+      case 260:
   #if defined(HASH_MODULE)
   test_hash_module();
   #endif
-
+          break;
+      case 261:
   test_time_module();
+          break;
+      case 262:
   test_performance_warnings();
-
+          break;
+  }
   yr_finalize();
   return 0;
 }
diff --git a/tests/test-stack.c b/tests/test-stack.c
index 1b3b7492..3620778a 100644
--- a/tests/test-stack.c
+++ b/tests/test-stack.c
@@ -31,6 +31,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <yara/stack.h>
 #include <yara.h>
 #include "util.h"
+#include "defects4cpp.h"
 
 
 int main(int argc, char** argv)
@@ -42,6 +43,9 @@ int main(int argc, char** argv)
   yr_initialize();
   yr_stack_create(1, sizeof(item),  &stack);
 
+  int index = defects4cpp_test_index();
+  switch (index) {
+    case 263:
   item = 1;
 
   if (yr_stack_push(stack, &item) != ERROR_SUCCESS)
@@ -77,6 +81,8 @@ int main(int argc, char** argv)
   if (yr_stack_pop(stack, &item) || item != 1)
     exit(EXIT_FAILURE);
 
+        break;
+  }
   yr_stack_destroy(stack);
   yr_finalize();
   return 0;
-- 
2.25.1

