        -:    0:Source:/home/workspace/include/internal/chewing-private.h
        -:    1:/**
        -:    2: * chewing-private.h
        -:    3: *
        -:    4: * Copyright (c) 2008, 2010
        -:    5: *	libchewing Core Team. See ChangeLog for details.
        -:    6: *
        -:    7: * See the file "COPYING" for information on usage and redistribution
        -:    8: * of this file.
        -:    9: */
        -:   10:
        -:   11:#ifndef _CHEWING_CORE_PRIVATE_H
        -:   12:#define _CHEWING_CORE_PRIVATE_H
        -:   13:
        -:   14:#ifdef HAVE_CONFIG_H
        -:   15:#  include <config.h>
        -:   16:#endif
        -:   17:
        -:   18:#ifdef HAVE_INTTYPES_H
        -:   19:#  include <inttypes.h>
        -:   20:#elif defined HAVE_STDINT_H
        -:   21:#  include <stdint.h>
        -:   22:#endif
        -:   23:
        -:   24:/* visual C++ does not have ssize_t type */
        -:   25:#if defined(_MSC_VER)
        -:   26:#include <BaseTsd.h>
        -:   27:typedef SSIZE_T ssize_t;
        -:   28:#endif
        -:   29:
        -:   30:#include "global.h"
        -:   31:#include "plat_mmap.h"
        -:   32:
        -:   33:#include "userphrase-private.h"
        -:   34:#if WITH_SQLITE3
        -:   35:#include "sqlite3.h"
        -:   36:#include "chewing-sql.h"
        -:   37:#endif
        -:   38:
        -:   39:#define MAX_KBTYPE 13
        -:   40:#define MAX_UTF8_SIZE 4
        -:   41:#define ZUIN_SIZE 4
        -:   42:#define PINYIN_SIZE 10
        -:   43:#define MAX_PHRASE_LEN 11
        -:   44:#define MAX_PHONE_SEQ_LEN 50
        -:   45:#define MIN_CHI_SYMBOL_LEN 0
        -:   46:#define MAX_CHI_SYMBOL_LEN (MAX_PHONE_SEQ_LEN - MAX_PHRASE_LEN)
        -:   47:#define MAX_INTERVAL ( ( MAX_PHONE_SEQ_LEN + 1 ) * MAX_PHONE_SEQ_LEN / 2 )
        -:   48:#define MAX_CHOICE (567)
        -:   49:#define MAX_CHOICE_BUF (50)                   /* max length of the choise buffer */
        -:   50:#define N_HASH_BIT (14)
        -:   51:#define HASH_TABLE_SIZE (1<<N_HASH_BIT)
        -:   52:#define EASY_SYMBOL_KEY_TAB_LEN (36)
        -:   53:#define AUX_PREFIX_LEN (3)
        -:   54:
        -:   55:/* For isSymbol */
        -:   56:#define WORD_CHOICE            (0)
        -:   57:#define SYMBOL_CATEGORY_CHOICE (1)
        -:   58:#define SYMBOL_CHOICE_INSERT   (2)
        -:   59:#define SYMBOL_CHOICE_UPDATE   (3)
        -:   60:
        -:   61:#ifndef _MSC_VER
        -:   62:#undef max
        1:   63:static inline int max( int a, int b )
        -:   64:{
        1:   65:	return a > b ? a : b;
        -:   66:}
        -:   67:
        -:   68:#undef min
        1:   69:static inline int min( int a, int b )
        -:   70:{
        1:   71:	return a < b ? a : b;
        -:   72:}
        -:   73:#endif
        -:   74:
        -:   75:/*
        -:   76: * This structure may represent both internal nodes and leaf nodes of a phrase
        -:   77: * tree. Two kinds are distinguished by whether key is 0. For an internal node,
        -:   78: * child.begin and child.end give a list of children in the position
        -:   79: * [child.begin, child.end). For a leaf node, phrase.pos offers the position
        -:   80: * of the phrase in system dictionary, and phrase.freq offers frequency of this
        -:   81: * phrase using a specific input method (may be bopomofo or non-phone). Note
        -:   82: * that key in root represents the number of total elements(nodes) in the tree.
        -:   83: */
        -:   84:typedef struct TreeType {
        -:   85:	unsigned char key[2];
        -:   86:	union {
        -:   87:		struct {
        -:   88:			unsigned char begin[3];
        -:   89:			unsigned char end[3];
        -:   90:		} child;
        -:   91:		struct {
        -:   92:			unsigned char pos[3];
        -:   93:			unsigned char freq[3];
        -:   94:		} phrase;
        -:   95:	};
        -:   96:} TreeType;
        -:   97:
        -:   98:typedef struct PhrasingOutput {
        -:   99:	IntervalType dispInterval[ MAX_INTERVAL ];
        -:  100:	int nDispInterval;
        -:  101:	int nNumCut;
        -:  102:} PhrasingOutput;
        -:  103:
        -:  104:typedef struct PinYinData {
        -:  105:	int type;
        -:  106:	char keySeq[ PINYIN_SIZE ];
        -:  107:} PinYinData;
        -:  108:
        -:  109:typedef struct ZuinData {
        -:  110:	int kbtype;
        -:  111:	int pho_inx[ ZUIN_SIZE ];
        -:  112:	int pho_inx_alt[ ZUIN_SIZE ];
        -:  113:	uint16_t phone;
        -:  114:	uint16_t phoneAlt;
        -:  115:	PinYinData pinYinData;
        -:  116:} ZuinData;
        -:  117:
        -:  118:typedef struct AvailInfo {
        -:  119:	/** @brief all kinds of lengths of available phrases. */
        -:  120:	struct {
        -:  121:		int len;
        -:  122:		/** @brief phone id. */
        -:  123:		const TreeType *id;
        -:  124:	} avail[ MAX_PHRASE_LEN ];
        -:  125:	/** @brief total number of availble lengths. */
        -:  126:	int nAvail;
        -:  127:	/** @brief the current choosing available length. */
        -:  128:	int currentAvail;
        -:  129:} AvailInfo;
        -:  130:/**
        -:  131: *	@struct AvailInfo
        -:  132: *	@brief information of available phrases or characters choices.
        -:  133: */
        -:  134:
        -:  135:typedef struct ChoiceInfo {
        -:  136:	/** @brief total page number. */
        -:  137:	int nPage;
        -:  138:	/** @brief current page number. */
        -:  139:	int pageNo;
        -:  140:	/** @brief number of choices per page. */
        -:  141:	int nChoicePerPage;
        -:  142:	/** @brief store possible phrases for being chosen. */
        -:  143:	char totalChoiceStr[ MAX_CHOICE ][ MAX_PHRASE_LEN * MAX_UTF8_SIZE + 1 ];
        -:  144:	/** @brief number of phrases to choose. */
        -:  145:	int nTotalChoice;
        -:  146:	int oldChiSymbolCursor;
        -:  147:	int isSymbol;
        -:  148:} ChoiceInfo;
        -:  149:
        -:  150:/** @brief entry of symbol table */
        -:  151:typedef struct SymbolEntry {
        -:  152:	/** @brief  nSymnols is total number of symbols in this category.
        -:  153:	 * If nSymbols = 0, category is treat as a symbol,
        -:  154:	 * which is a zero-terminated utf-8 string.
        -:  155:	 * In that case, symbols[] is unused and isn't allocated at all.
        -:  156:	 */
        -:  157:	int nSymbols;
        -:  158:
        -:  159:	/** @brief  Category name of these symbols */
        -:  160:	char category[ MAX_PHRASE_LEN * MAX_UTF8_SIZE + 1 ];
        -:  161:
        -:  162:	/** @brief  Symbols in this category.
        -:  163:	 * This is an char[] array of variable length.
        -:  164:	 * When nSymbols = 0, this array is not allocated.
        -:  165:	 */
        -:  166:	char symbols[][ MAX_UTF8_SIZE + 1 ];
        -:  167:} SymbolEntry;
        -:  168:
        -:  169:typedef struct ChewingStaticData {
        -:  170:	const TreeType *tree;
        -:  171:	size_t tree_size;
        -:  172:	plat_mmap tree_mmap;
        -:  173:	const TreeType *tree_cur_pos, *tree_end_pos;
        -:  174:
        -:  175:	const char *dict;
        -:  176:	plat_mmap dict_mmap;
        -:  177:
        -:  178:#if WITH_SQLITE3
        -:  179:	sqlite3 *db;
        -:  180:	sqlite3_stmt *stmt_config[STMT_CONFIG_COUNT];
        -:  181:	sqlite3_stmt *stmt_userphrase[STMT_USERPHRASE_COUNT];
        -:  182:
        -:  183:	unsigned int original_lifetime;
        -:  184:	unsigned int new_lifetime;
        -:  185:#else
        -:  186:	int chewing_lifetime;
        -:  187:
        -:  188:	char hashfilename[ 200 ];
        -:  189:	struct HASH_ITEM *hashtable[ HASH_TABLE_SIZE ];
        -:  190:	struct HASH_ITEM *userphrase_enum; /* FIXME: Shall be in ChewingData? */
        -:  191:#endif
        -:  192:
        -:  193:	unsigned int n_symbol_entry;
        -:  194:	SymbolEntry ** symbol_table;
        -:  195:
        -:  196:	char *g_easy_symbol_value[ EASY_SYMBOL_KEY_TAB_LEN ];
        -:  197:	int g_easy_symbol_num[ EASY_SYMBOL_KEY_TAB_LEN ];
        -:  198:
        -:  199:	struct keymap *hanyuInitialsMap;
        -:  200:	struct keymap *hanyuFinalsMap;
        -:  201:	int HANYU_INITIALS;
        -:  202:	int HANYU_FINALS;
        -:  203:} ChewingStaticData;
        -:  204:
        -:  205:typedef enum Category {
        -:  206:	CHEWING_NONE,
        -:  207:	CHEWING_CHINESE,
        -:  208:	CHEWING_SYMBOL,
        -:  209:} Category;
        -:  210:
        -:  211:typedef struct PreeditBuf {
        -:  212:	Category category;
        -:  213:	char char_[ MAX_UTF8_SIZE + 1 ];
        -:  214:} PreeditBuf;
        -:  215:
        -:  216:typedef struct ChewingData {
        -:  217:	AvailInfo availInfo;
        -:  218:	ChoiceInfo choiceInfo;
        -:  219:	PhrasingOutput phrOut;
        -:  220:	ZuinData zuinData;
        -:  221:	ChewingConfigData config;
        -:  222:	/** @brief current input buffer, content==0 means Chinese code */
        -:  223:	PreeditBuf preeditBuf[ MAX_PHONE_SEQ_LEN ];
        -:  224:	int chiSymbolCursor;
        -:  225:	int chiSymbolBufLen;
        -:  226:	int PointStart;
        -:  227:	int PointEnd;
        -:  228:
        -:  229:	int bShowMsg;
        -:  230:	char showMsg[ MAX_UTF8_SIZE * ( MAX_PHRASE_LEN + AUX_PREFIX_LEN ) + 1 ];
        -:  231:	int showMsgLen;
        -:  232:
        -:  233:	uint16_t phoneSeq[ MAX_PHONE_SEQ_LEN ];
        -:  234:	uint16_t phoneSeqAlt[ MAX_PHONE_SEQ_LEN ];
        -:  235:	int nPhoneSeq;
        -:  236:	char selectStr[ MAX_PHONE_SEQ_LEN ][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ];
        -:  237:	IntervalType selectInterval[ MAX_PHONE_SEQ_LEN ];
        -:  238:	int nSelect;
        -:  239:	IntervalType preferInterval[ MAX_INTERVAL ]; /* add connect points */
        -:  240:	int nPrefer;
        -:  241:	int bUserArrCnnct[ MAX_PHONE_SEQ_LEN + 1 ];
        -:  242:	int bUserArrBrkpt[ MAX_PHONE_SEQ_LEN + 1 ];
        -:  243:	int bArrBrkpt[ MAX_PHONE_SEQ_LEN + 1 ];
        -:  244:	int bSymbolArrBrkpt[ MAX_PHONE_SEQ_LEN + 1 ];
        -:  245:	/* "bArrBrkpt[10]=True" means "it breaks between 9 and 10" */
        -:  246:	int bChiSym, bSelect, bFirstKey, bFullShape;
        -:  247:	/* Symbol Key buffer */
        -:  248:	char symbolKeyBuf[ MAX_PHONE_SEQ_LEN ];
        -:  249:
        -:  250:#if WITH_SQLITE3
        -:  251:	UserPhraseData userphrase_data;
        -:  252:#else
        -:  253:	struct HASH_ITEM *prev_userphrase;
        -:  254:#endif
        -:  255:
        -:  256:	ChewingStaticData static_data;
        -:  257:	void (*logger)( void *data, int level, const char *fmt, ... );
        -:  258:	void *loggerData;
        -:  259:} ChewingData;
        -:  260:
        -:  261:typedef struct ChewingOutput {
        -:  262:	/** @brief the content of Edit buffer. */
        -:  263:	char preeditBuf[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ];
        -:  264:	/** @brief the length of Edit buffer. */
        -:  265:	int chiSymbolBufLen;
        -:  266:	/** @brief current position of the cursor. */
        -:  267:	long chiSymbolCursor;
        -:  268:	long PointStart;
        -:  269:	long PointEnd;
        -:  270:	char bopomofoBuf[ ZUIN_SIZE * MAX_UTF8_SIZE + 1 ];
        -:  271:	/** @brief indicate the method of showing sentence break. */
        -:  272:	IntervalType dispInterval[ MAX_INTERVAL ]; /* from prefer, considering symbol */
        -:  273:	int nDispInterval;
        -:  274:	/** @brief indicate the break points going to display.*/
        -:  275:	int dispBrkpt[ MAX_PHONE_SEQ_LEN + 1 ];
        -:  276:	/** @brief the string going to commit. */
        -:  277:
        -:  278:	char commitBuf[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ];
        -:  279:	int commitBufLen;
        -:  280:	/** @brief information of character selections. */
        -:  281:	ChoiceInfo* pci;
        -:  282:	/** @brief indicate English mode or Chinese mode. */
        -:  283:	int bChiSym;
        -:  284:	int selKey[ MAX_SELKEY ];
        -:  285:	/** @brief return value. */
        -:  286:	int keystrokeRtn;
        -:  287:	/** @brief user message. */
        -:  288:} ChewingOutput;
        -:  289:/**
        -:  290: *   @struct ChewingOutput
        -:  291: *   @brief  information for Chewing output.
        -:  292: */
        -:  293:
        -:  294:struct ChewingContext {
        -:  295:	ChewingData *data;
        -:  296:	ChewingOutput *output;
        -:  297:	int cand_no;
        -:  298:	int it_no;
        -:  299:	int kb_no;
        -:  300:};
        -:  301:/**
        -:  302: * @struct ChewingContext
        -:  303: * @brief context of Chewing IM
        -:  304: */
        -:  305:
        -:  306:typedef struct Phrase {
        -:  307:	char phrase[ MAX_PHRASE_LEN * MAX_UTF8_SIZE + 1 ];
        -:  308:	int freq;
        -:  309:} Phrase;
        -:  310:
        -:  311:#endif
