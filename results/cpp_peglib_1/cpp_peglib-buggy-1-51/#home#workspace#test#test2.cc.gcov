        -:    0:Source:/home/workspace/test/test2.cc
        -:    0:Programs:4
        -:    1:﻿#include "catch.hh"
        -:    2:#include <peglib.h>
        -:    3:
        -:    4:using namespace peg;
        -:    5:
        1:    6:TEST_CASE("Infinite loop 1", "[infinite loop]")
        -:    7:{
        -:    8:    parser pg(R"(
        -:    9:        ROOT  <- WH TOKEN* WH
        -:   10:        TOKEN <- [a-z0-9]*
        -:   11:        WH    <- [ \t]*
    #####:   12:    )");
        -:   13:
    #####:   14:    REQUIRE(!pg);
    #####:   15:}
        -:   16:
        1:   17:TEST_CASE("Infinite loop 2", "[infinite loop]")
        -:   18:{
        -:   19:    parser pg(R"(
        -:   20:        ROOT  <- WH TOKEN+ WH
        -:   21:        TOKEN <- [a-z0-9]*
        -:   22:        WH    <- [ \t]*
    #####:   23:    )");
        -:   24:
    #####:   25:    REQUIRE(!pg);
    #####:   26:}
        -:   27:
        1:   28:TEST_CASE("Infinite loop 3", "[infinite loop]")
        -:   29:{
        -:   30:    parser pg(R"(
        -:   31:        ROOT  <- WH TOKEN* WH
        -:   32:        TOKEN <- !'word1'
        -:   33:        WH    <- [ \t]*
    #####:   34:    )");
        -:   35:
    #####:   36:    REQUIRE(!pg);
    #####:   37:}
        -:   38:
        2:   39:TEST_CASE("Infinite loop 4", "[infinite loop]")
        -:   40:{
        -:   41:    parser pg(R"(
        -:   42:        ROOT  <- WH TOKEN* WH
        -:   43:        TOKEN <- &'word1'
        -:   44:        WH    <- [ \t]*
        2:   45:    )");
        -:   46:
        1:   47:    REQUIRE(!pg);
        1:   48:}
        -:   49:
        1:   50:TEST_CASE("Infinite loop 5", "[infinite loop]")
        -:   51:{
        -:   52:    parser pg(R"(
        -:   53:        Numbers <- Number*
        -:   54:        Number <- [0-9]+ / Spacing
        -:   55:        Spacing <- ' ' / '\t' / '\n' / EOF # EOF is empty
        -:   56:        EOF <- !.
    #####:   57:    )");
        -:   58:
    #####:   59:    REQUIRE(!pg);
    #####:   60:}
        -:   61:
        1:   62:TEST_CASE("Infinite loop 6", "[infinite loop]")
        -:   63:{
        -:   64:    parser pg(R"(
        -:   65:        S <- ''*
    #####:   66:    )");
        -:   67:
    #####:   68:    REQUIRE(!pg);
    #####:   69:}
        -:   70:
        1:   71:TEST_CASE("Infinite loop 7", "[infinite loop]")
        -:   72:{
        -:   73:    parser pg(R"(
        -:   74:        S <- A*
        -:   75:        A <- ''
    #####:   76:    )");
        -:   77:
    #####:   78:    REQUIRE(!pg);
    #####:   79:}
        -:   80:
        1:   81:TEST_CASE("Not infinite 1", "[infinite loop]")
        -:   82:{
        -:   83:    parser pg(R"(
        -:   84:        Numbers <- Number* EOF
        -:   85:        Number <- [0-9]+ / Spacing
        -:   86:        Spacing <- ' ' / '\t' / '\n'
        -:   87:        EOF <- !.
    #####:   88:    )");
        -:   89:
    #####:   90:    REQUIRE(!!pg); // OK
    #####:   91:}
        -:   92:
        1:   93:TEST_CASE("Not infinite 2", "[infinite loop]")
        -:   94:{
        -:   95:    parser pg(R"(
        -:   96:        ROOT      <-  _ ('[' TAG_NAME ']' _)*
        -:   97:        # In a sequence operator, if there is at least one non-empty element, we can treat it as non-empty
        -:   98:        TAG_NAME  <-  (!']' .)+
        -:   99:        _         <-  [ \t]*
    #####:  100:    )");
        -:  101:
    #####:  102:    REQUIRE(!!pg); // OK
    #####:  103:}
        -:  104:
        1:  105:TEST_CASE("Not infinite 3", "[infinite loop]")
        -:  106:{
        -:  107:    parser pg(R"(
        -:  108:        EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*
        -:  109:        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*
        -:  110:        FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _ # Recursive...
        -:  111:        TERM_OPERATOR    <-  < [-+] > _
        -:  112:        FACTOR_OPERATOR  <-  < [/*] > _
        -:  113:        NUMBER           <-  < [0-9]+ > _
        -:  114:        _                <-  [ \t\r\n]*
    #####:  115:    )");
        -:  116:
    #####:  117:    REQUIRE(!!pg); // OK
    #####:  118:}
        -:  119:
        1:  120:TEST_CASE("Precedence climbing", "[precedence]")
        -:  121:{
        -:  122:    parser parser(R"(
        -:  123:        START            <-  _ EXPRESSION
        -:  124:        EXPRESSION       <-  ATOM (OPERATOR ATOM)* {
        -:  125:                               precedence
        -:  126:                                 L + -
        -:  127:                                 L * /
        -:  128:                             }
        -:  129:        ATOM             <-  NUMBER / T('(') EXPRESSION T(')')
        -:  130:        OPERATOR         <-  T([-+/*])
        -:  131:        NUMBER           <-  T('-'? [0-9]+)
        -:  132:		~_               <-  [ \t]*
        -:  133:		T(S)             <-  < S > _
    #####:  134:	)");
        -:  135:
    #####:  136:    parser.enable_packrat_parsing();
        -:  137:
        -:  138:    // Setup actions
    #####:  139:    parser["EXPRESSION"] = [](const SemanticValues& sv) -> long {
    #####:  140:        auto result = any_cast<long>(sv[0]);
    #####:  141:        if (sv.size() > 1) {
    #####:  142:            auto ope = any_cast<char>(sv[1]);
    #####:  143:            auto num = any_cast<long>(sv[2]);
    #####:  144:            switch (ope) {
    #####:  145:                case '+': result += num; break;
    #####:  146:                case '-': result -= num; break;
    #####:  147:                case '*': result *= num; break;
    #####:  148:                case '/': result /= num; break;
        -:  149:            }
        -:  150:        }
    #####:  151:        return result;
        -:  152:    };
    #####:  153:    parser["OPERATOR"] = [](const SemanticValues& sv) { return *sv.c_str(); };
    #####:  154:    parser["NUMBER"] = [](const SemanticValues& sv) { return atol(sv.c_str()); };
        -:  155:
    #####:  156:    bool ret = parser;
    #####:  157:    REQUIRE(ret == true);
        -:  158:
        -:  159:    {
    #####:  160:        auto expr = " 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 ";
    #####:  161:        long val = 0;
    #####:  162:        ret = parser.parse(expr, val);
        -:  163:
    #####:  164:        REQUIRE(ret == true);
    #####:  165:        REQUIRE(val == -3);
        -:  166:    }
        -:  167:
        -:  168:    {
    #####:  169:      auto expr = "-1+-2--3"; // -1 + -2 - -3 = 0
    #####:  170:      long val = 0;
    #####:  171:      ret = parser.parse(expr, val);
        -:  172:
    #####:  173:      REQUIRE(ret == true);
    #####:  174:      REQUIRE(val == 0);
        -:  175:    }
    #####:  176:}
        -:  177:
        1:  178:TEST_CASE("Precedence climbing with macro", "[precedence]")
        -:  179:{
        -:  180:    // Create a PEG parser
        -:  181:    parser parser(R"(
        -:  182:        EXPRESSION             <-  INFIX_EXPRESSION(ATOM, OPERATOR)
        -:  183:        INFIX_EXPRESSION(A, O) <-  A (O A)* {
        -:  184:                                     precedence
        -:  185:                                       L + -
        -:  186:                                       L * /
        -:  187:                                   }
        -:  188:        ATOM                   <-  NUMBER / '(' EXPRESSION ')'
        -:  189:        OPERATOR               <-  < [-+/*] >
        -:  190:        NUMBER                 <-  < '-'? [0-9]+ >
        -:  191:        %whitespace            <-  [ \t]*
    #####:  192:	)");
        -:  193:
    #####:  194:    parser.enable_packrat_parsing();
        -:  195:
    #####:  196:    bool ret = parser;
    #####:  197:    REQUIRE(ret == true);
        -:  198:
        -:  199:    // Setup actions
    #####:  200:    parser["INFIX_EXPRESSION"] = [](const SemanticValues& sv) -> long {
    #####:  201:        auto result = any_cast<long>(sv[0]);
    #####:  202:        if (sv.size() > 1) {
    #####:  203:            auto ope = any_cast<char>(sv[1]);
    #####:  204:            auto num = any_cast<long>(sv[2]);
    #####:  205:            switch (ope) {
    #####:  206:                case '+': result += num; break;
    #####:  207:                case '-': result -= num; break;
    #####:  208:                case '*': result *= num; break;
    #####:  209:                case '/': result /= num; break;
        -:  210:            }
        -:  211:        }
    #####:  212:        return result;
        -:  213:    };
    #####:  214:    parser["OPERATOR"] = [](const SemanticValues& sv) { return *sv.c_str(); };
    #####:  215:    parser["NUMBER"] = [](const SemanticValues& sv) { return atol(sv.c_str()); };
        -:  216:
        -:  217:    {
    #####:  218:        auto expr = " 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 ";
    #####:  219:        long val = 0;
    #####:  220:        ret = parser.parse(expr, val);
        -:  221:
    #####:  222:        REQUIRE(ret == true);
    #####:  223:        REQUIRE(val == -3);
        -:  224:    }
        -:  225:
        -:  226:    {
    #####:  227:      auto expr = "-1+-2--3"; // -1 + -2 - -3 = 0
    #####:  228:      long val = 0;
    #####:  229:      ret = parser.parse(expr, val);
        -:  230:
    #####:  231:      REQUIRE(ret == true);
    #####:  232:      REQUIRE(val == 0);
        -:  233:    }
    #####:  234:}
        -:  235:
        1:  236:TEST_CASE("Precedence climbing error1", "[precedence]")
        -:  237:{
        -:  238:    parser parser(R"(
        -:  239:        START            <-  _ EXPRESSION
        -:  240:        EXPRESSION       <-  ATOM (OPERATOR ATOM1)* {
        -:  241:                               precedence
        -:  242:                                 L + -
        -:  243:                                 L * /
        -:  244:                             }
        -:  245:        ATOM             <-  NUMBER / T('(') EXPRESSION T(')')
        -:  246:        ATOM1            <-  NUMBER / T('(') EXPRESSION T(')')
        -:  247:        OPERATOR         <-  T([-+/*])
        -:  248:        NUMBER           <-  T('-'? [0-9]+)
        -:  249:		~_               <-  [ \t]*
        -:  250:		T(S)             <-  < S > _
    #####:  251:	)");
        -:  252:
    #####:  253:    bool ret = parser;
    #####:  254:    REQUIRE(ret == false);
    #####:  255:}
        -:  256:
        1:  257:TEST_CASE("Precedence climbing error2", "[precedence]")
        -:  258:{
        -:  259:    parser parser(R"(
        -:  260:        START            <-  _ EXPRESSION
        -:  261:        EXPRESSION       <-  ATOM OPERATOR ATOM {
        -:  262:                               precedence
        -:  263:                                 L + -
        -:  264:                                 L * /
        -:  265:                             }
        -:  266:        ATOM             <-  NUMBER / T('(') EXPRESSION T(')')
        -:  267:        OPERATOR         <-  T([-+/*])
        -:  268:        NUMBER           <-  T('-'? [0-9]+)
        -:  269:		~_               <-  [ \t]*
        -:  270:		T(S)             <-  < S > _
    #####:  271:	)");
        -:  272:
    #####:  273:    bool ret = parser;
    #####:  274:    REQUIRE(ret == false);
    #####:  275:}
        -:  276:
        1:  277:TEST_CASE("Precedence climbing error3", "[precedence]") {
        -:  278:    parser parser(R"(
        -:  279:        EXPRESSION               <-  PRECEDENCE_PARSING(ATOM, OPERATOR)
        -:  280:        PRECEDENCE_PARSING(A, O) <-  A (O A)+ {
        -:  281:                                       precedence
        -:  282:                                         L + -
        -:  283:                                         L * /
        -:  284:                                     }
        -:  285:        ATOM                     <-  NUMBER / '(' EXPRESSION ')'
        -:  286:        OPERATOR                 <-  < [-+/*] >
        -:  287:        NUMBER                   <-  < '-'? [0-9]+ >
        -:  288:        %whitespace              <-  [ \t]*
    #####:  289:	)");
        -:  290:
    #####:  291:    bool ret = parser;
    #####:  292:    REQUIRE(ret == false);
    #####:  293:}
        -:  294:
        1:  295:TEST_CASE("Packrat parser test with %whitespace%", "[packrat]") {
        -:  296:    peg::parser parser(R"(
        -:  297:        ROOT         <-  'a'
        -:  298:        %whitespace  <-  SPACE*
        -:  299:        SPACE        <-  ' '
    #####:  300:    )");
        -:  301:
    #####:  302:    parser.enable_packrat_parsing();
        -:  303:
    #####:  304:    auto ret = parser.parse("a");
    #####:  305:    REQUIRE(ret == true);
    #####:  306:}
        -:  307:
        1:  308:TEST_CASE("Packrat parser test with macro", "[packrat]")
        -:  309:{
        -:  310:    parser parser(R"(
        -:  311:        EXPRESSION       <-  _ LIST(TERM, TERM_OPERATOR)
        -:  312:        TERM             <-  LIST(FACTOR, FACTOR_OPERATOR)
        -:  313:        FACTOR           <-  NUMBER / T('(') EXPRESSION T(')')
        -:  314:        TERM_OPERATOR    <-  T([-+])
        -:  315:        FACTOR_OPERATOR  <-  T([/*])
        -:  316:        NUMBER           <-  T([0-9]+)
        -:  317:		~_               <-  [ \t]*
        -:  318:		LIST(I, D)       <-  I (D I)*
        -:  319:		T(S)             <-  < S > _
    #####:  320:	)");
        -:  321:
    #####:  322:    parser.enable_packrat_parsing();
        -:  323:
    #####:  324:    auto ret = parser.parse(" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 ");
    #####:  325:    REQUIRE(ret == true);
    #####:  326:}
        -:  327:
        1:  328:TEST_CASE("Packrat parser test with precedence expression parser", "[packrat]") {
        -:  329:  peg::parser parser(R"(
        -:  330:    Expression  <- Atom (Operator Atom)* { precedence L + - L * / }
        -:  331:    Atom        <- _? Number _?
        -:  332:    Number      <- [0-9]+
        -:  333:    Operator    <- '+' / '-' / '*' / '/'
        -:  334:    _           <- ' '+
    #####:  335:  )");
        -:  336:
    #####:  337:  bool ret = parser;
    #####:  338:  REQUIRE(ret == true);
        -:  339:
    #####:  340:  parser.enable_packrat_parsing();
        -:  341:
    #####:  342:  ret = parser.parse(" 1 + 2 * 3 ");
    #####:  343:  REQUIRE(ret == true);
    #####:  344:}
        -:  345:
        1:  346:TEST_CASE("Backreference test", "[backreference]")
        -:  347:{
        -:  348:    parser parser(R"(
        -:  349:        START  <- _ LQUOTE < (!RQUOTE .)* > RQUOTE _
        -:  350:        LQUOTE <- 'R"' $delm< [a-zA-Z]* > '('
        -:  351:        RQUOTE <- ')' $delm '"'
        -:  352:        ~_     <- [ \t\r\n]*
    #####:  353:    )");
        -:  354:
    #####:  355:    std::string token;
    #####:  356:    parser["START"] = [&](const SemanticValues& sv) {
    #####:  357:        token = sv.token();
    #####:  358:    };
        -:  359:
        -:  360:    {
    #####:  361:        token.clear();
        -:  362:        auto ret = parser.parse(R"delm(
        -:  363:            R"("hello world")"
    #####:  364:        )delm");
        -:  365:
    #####:  366:        REQUIRE(ret == true);
    #####:  367:        REQUIRE(token == "\"hello world\"");
        -:  368:    }
        -:  369:
        -:  370:    {
    #####:  371:        token.clear();
        -:  372:        auto ret = parser.parse(R"delm(
        -:  373:            R"foo("(hello world)")foo"
    #####:  374:        )delm");
        -:  375:
    #####:  376:        REQUIRE(ret == true);
    #####:  377:        REQUIRE(token == "\"(hello world)\"");
        -:  378:    }
        -:  379:
        -:  380:    {
    #####:  381:        token.clear();
        -:  382:        auto ret = parser.parse(R"delm(
        -:  383:            R"foo("(hello world)foo")foo"
    #####:  384:        )delm");
        -:  385:
    #####:  386:        REQUIRE(ret == false);
    #####:  387:        REQUIRE(token == "\"(hello world");
        -:  388:    }
        -:  389:
        -:  390:    {
    #####:  391:        token.clear();
        -:  392:        auto ret = parser.parse(R"delm(
        -:  393:            R"foo("(hello world)")bar"
    #####:  394:        )delm");
        -:  395:
    #####:  396:        REQUIRE(ret == false);
    #####:  397:        REQUIRE(token.empty());
        -:  398:    }
    #####:  399:}
        -:  400:
        1:  401:TEST_CASE("Invalid backreference test", "[backreference]")
        -:  402:{
        -:  403:    parser parser(R"(
        -:  404:        START  <- _ LQUOTE (!RQUOTE .)* RQUOTE _
        -:  405:        LQUOTE <- 'R"' $delm< [a-zA-Z]* > '('
        -:  406:        RQUOTE <- ')' $delm2 '"'
        -:  407:        ~_     <- [ \t\r\n]*
    #####:  408:    )");
        -:  409:
    #####:  410:    REQUIRE_THROWS_AS(
        -:  411:        parser.parse(R"delm(
        -:  412:            R"foo("(hello world)")foo"
        -:  413:        )delm"),
        -:  414:        std::runtime_error);
    #####:  415:}
        -:  416:
        -:  417:
        1:  418:TEST_CASE("Nested capture test", "[backreference]")
        -:  419:{
        -:  420:    parser parser(R"(
        -:  421:        ROOT      <- CONTENT
        -:  422:        CONTENT   <- (ELEMENT / TEXT)*
        -:  423:        ELEMENT   <- $(STAG CONTENT ETAG)
        -:  424:        STAG      <- '<' $tag< TAG_NAME > '>'
        -:  425:        ETAG      <- '</' $tag '>'
        -:  426:        TAG_NAME  <- 'b' / 'u'
        -:  427:        TEXT      <- TEXT_DATA
        -:  428:        TEXT_DATA <- ![<] .
    #####:  429:    )");
        -:  430:
    #####:  431:    REQUIRE(parser.parse("This is <b>a <u>test</u> text</b>."));
    #####:  432:    REQUIRE(!parser.parse("This is <b>a <u>test</b> text</u>."));
    #####:  433:    REQUIRE(!parser.parse("This is <b>a <u>test text</b>."));
    #####:  434:    REQUIRE(!parser.parse("This is a <u>test</u> text</b>."));
    #####:  435:}
        -:  436:
        1:  437:TEST_CASE("Backreference with Prioritized Choice test", "[backreference]")
        -:  438:{
        -:  439:    parser parser(R"(
        -:  440:        TREE           <- WRONG_BRANCH / CORRECT_BRANCH
        -:  441:        WRONG_BRANCH   <- BRANCH THAT IS_capture WRONG
        -:  442:        CORRECT_BRANCH <- BRANCH THAT IS_backref CORRECT
        -:  443:        BRANCH         <- 'branch'
        -:  444:        THAT           <- 'that'
        -:  445:        IS_capture     <- $ref<..>
        -:  446:        IS_backref     <- $ref
        -:  447:        WRONG          <- 'wrong'
        -:  448:        CORRECT        <- 'correct'
    #####:  449:    )");
        -:  450:
    #####:  451:    REQUIRE_THROWS_AS(parser.parse("branchthatiscorrect"), std::runtime_error);
    #####:  452:}
        -:  453:
        1:  454:TEST_CASE("Backreference with Zero or More test", "[backreference]")
        -:  455:{
        -:  456:    parser parser(R"(
        -:  457:        TREE           <- WRONG_BRANCH* CORRECT_BRANCH
        -:  458:        WRONG_BRANCH   <- BRANCH THAT IS_capture WRONG
        -:  459:        CORRECT_BRANCH <- BRANCH THAT IS_backref CORRECT
        -:  460:        BRANCH         <- 'branch'
        -:  461:        THAT           <- 'that'
        -:  462:        IS_capture     <- $ref<..>
        -:  463:        IS_backref     <- $ref
        -:  464:        WRONG          <- 'wrong'
        -:  465:        CORRECT        <- 'correct'
    #####:  466:    )");
        -:  467:
    #####:  468:    REQUIRE(parser.parse("branchthatiswrongbranchthatiscorrect"));
    #####:  469:    REQUIRE(!parser.parse("branchthatiswrongbranchthatIscorrect"));
    #####:  470:    REQUIRE(!parser.parse("branchthatiswrongbranchthatIswrongbranchthatiscorrect"));
    #####:  471:    REQUIRE(parser.parse("branchthatiswrongbranchthatIswrongbranchthatIscorrect"));
    #####:  472:    REQUIRE_THROWS_AS(parser.parse("branchthatiscorrect"), std::runtime_error);
    #####:  473:    REQUIRE_THROWS_AS(parser.parse("branchthatiswron_branchthatiscorrect"), std::runtime_error);
    #####:  474:}
        -:  475:
        1:  476:TEST_CASE("Backreference with One or More test", "[backreference]")
        -:  477:{
        -:  478:    parser parser(R"(
        -:  479:        TREE           <- WRONG_BRANCH+ CORRECT_BRANCH
        -:  480:        WRONG_BRANCH   <- BRANCH THAT IS_capture WRONG
        -:  481:        CORRECT_BRANCH <- BRANCH THAT IS_backref CORRECT
        -:  482:        BRANCH         <- 'branch'
        -:  483:        THAT           <- 'that'
        -:  484:        IS_capture     <- $ref<..>
        -:  485:        IS_backref     <- $ref
        -:  486:        WRONG          <- 'wrong'
        -:  487:        CORRECT        <- 'correct'
    #####:  488:    )");
        -:  489:
    #####:  490:    REQUIRE(parser.parse("branchthatiswrongbranchthatiscorrect"));
    #####:  491:    REQUIRE(!parser.parse("branchthatiswrongbranchthatIscorrect"));
    #####:  492:    REQUIRE(!parser.parse("branchthatiswrongbranchthatIswrongbranchthatiscorrect"));
    #####:  493:    REQUIRE(parser.parse("branchthatiswrongbranchthatIswrongbranchthatIscorrect"));
    #####:  494:    REQUIRE(!parser.parse("branchthatiscorrect"));
    #####:  495:    REQUIRE(!parser.parse("branchthatiswron_branchthatiscorrect"));
    #####:  496:}
        -:  497:
        1:  498:TEST_CASE("Backreference with Option test", "[backreference]")
        -:  499:{
        -:  500:    parser parser(R"(
        -:  501:        TREE           <- WRONG_BRANCH? CORRECT_BRANCH
        -:  502:        WRONG_BRANCH   <- BRANCH THAT IS_capture WRONG
        -:  503:        CORRECT_BRANCH <- BRANCH THAT IS_backref CORRECT
        -:  504:        BRANCH         <- 'branch'
        -:  505:        THAT           <- 'that'
        -:  506:        IS_capture     <- $ref<..>
        -:  507:        IS_backref     <- $ref
        -:  508:        WRONG          <- 'wrong'
        -:  509:        CORRECT        <- 'correct'
    #####:  510:    )");
        -:  511:
    #####:  512:    REQUIRE(parser.parse("branchthatiswrongbranchthatiscorrect"));
    #####:  513:    REQUIRE(!parser.parse("branchthatiswrongbranchthatIscorrect"));
    #####:  514:    REQUIRE(!parser.parse("branchthatiswrongbranchthatIswrongbranchthatiscorrect"));
    #####:  515:    REQUIRE(!parser.parse("branchthatiswrongbranchthatIswrongbranchthatIscorrect"));
    #####:  516:    REQUIRE_THROWS_AS(parser.parse("branchthatiscorrect"), std::runtime_error);
    #####:  517:    REQUIRE_THROWS_AS(parser.parse("branchthatiswron_branchthatiscorrect"), std::runtime_error);
    #####:  518:}
        -:  519:
        1:  520:TEST_CASE("Repetition {0}", "[repetition]")
        -:  521:{
        -:  522:    parser parser(R"(
        -:  523:        START <- '(' DIGIT{3} ') ' DIGIT{3} '-' DIGIT{4}
        -:  524:        DIGIT <- [0-9]
    #####:  525:    )");
    #####:  526:    REQUIRE(parser.parse("(123) 456-7890"));
    #####:  527:    REQUIRE(!parser.parse("(12a) 456-7890"));
    #####:  528:    REQUIRE(!parser.parse("(123) 45-7890"));
    #####:  529:    REQUIRE(!parser.parse("(123) 45-7a90"));
    #####:  530:}
        -:  531:
        1:  532:TEST_CASE("Repetition {2,4}", "[repetition]")
        -:  533:{
        -:  534:    parser parser(R"(
        -:  535:        START <- DIGIT{2,4}
        -:  536:        DIGIT <- [0-9]
    #####:  537:    )");
    #####:  538:    REQUIRE(!parser.parse("1"));
    #####:  539:    REQUIRE(parser.parse("12"));
    #####:  540:    REQUIRE(parser.parse("123"));
    #####:  541:    REQUIRE(parser.parse("1234"));
    #####:  542:    REQUIRE(!parser.parse("12345"));
    #####:  543:}
        -:  544:
        1:  545:TEST_CASE("Repetition {2,1}", "[repetition]")
        -:  546:{
        -:  547:    parser parser(R"(
        -:  548:        START <- DIGIT{2,1} # invalid range
        -:  549:        DIGIT <- [0-9]
    #####:  550:    )");
    #####:  551:    REQUIRE(!parser.parse("1"));
    #####:  552:    REQUIRE(parser.parse("12"));
    #####:  553:    REQUIRE(!parser.parse("123"));
    #####:  554:}
        -:  555:
        1:  556:TEST_CASE("Repetition {2,}", "[repetition]")
        -:  557:{
        -:  558:    parser parser(R"(
        -:  559:        START <- DIGIT{2,}
        -:  560:        DIGIT <- [0-9]
    #####:  561:    )");
    #####:  562:    REQUIRE(!parser.parse("1"));
    #####:  563:    REQUIRE(parser.parse("12"));
    #####:  564:    REQUIRE(parser.parse("123"));
    #####:  565:    REQUIRE(parser.parse("1234"));
    #####:  566:}
        -:  567:
        1:  568:TEST_CASE("Repetition {,2}", "[repetition]")
        -:  569:{
        -:  570:    parser parser(R"(
        -:  571:        START <- DIGIT{,2}
        -:  572:        DIGIT <- [0-9]
    #####:  573:    )");
    #####:  574:    REQUIRE(parser.parse("1"));
    #####:  575:    REQUIRE(parser.parse("12"));
    #####:  576:    REQUIRE(!parser.parse("123"));
    #####:  577:    REQUIRE(!parser.parse("1234"));
    #####:  578:}
        -:  579:
        1:  580:TEST_CASE("Left recursive test", "[left recursive]")
        -:  581:{
        -:  582:    parser parser(R"(
        -:  583:        A <- A 'a'
        -:  584:        B <- A 'a'
    #####:  585:    )");
        -:  586:
    #####:  587:    REQUIRE(!parser);
    #####:  588:}
        -:  589:
        1:  590:TEST_CASE("Left recursive with option test", "[left recursive]")
        -:  591:{
        -:  592:    parser parser(R"(
        -:  593:        A  <- 'a' / 'b'? B 'c'
        -:  594:        B  <- A
    #####:  595:    )");
        -:  596:
    #####:  597:    REQUIRE(!parser);
    #####:  598:}
        -:  599:
        1:  600:TEST_CASE("Left recursive with zom test", "[left recursive]")
        -:  601:{
        -:  602:    parser parser(R"(
        -:  603:        A <- 'a'* A*
    #####:  604:    )");
        -:  605:
    #####:  606:    REQUIRE(!parser);
    #####:  607:}
        -:  608:
        1:  609:TEST_CASE("Left recursive with a ZOM content rule", "[left recursive]")
        -:  610:{
        -:  611:    parser parser(R"(
        -:  612:        A <- B
        -:  613:        B <- _ A
        -:  614:        _ <- ' '* # Zero or more
    #####:  615:    )");
        -:  616:
    #####:  617:    REQUIRE(!parser);
    #####:  618:}
        -:  619:
        1:  620:TEST_CASE("Left recursive with empty string test", "[left recursive]")
        -:  621:{
        -:  622:    parser parser(
        -:  623:        " A <- '' A"
    #####:  624:    );
        -:  625:
    #####:  626:    REQUIRE(!parser);
    #####:  627:}
        -:  628:
        1:  629:TEST_CASE("User defined rule test", "[user rule]")
        -:  630:{
        -:  631:    auto g = parser(R"(
        -:  632:        ROOT <- _ 'Hello' _ NAME '!' _
        -:  633:    )",
        -:  634:    {
        -:  635:        {
    #####:  636:            "NAME", usr([](const char* s, size_t n, SemanticValues& /*sv*/, any& /*dt*/) -> size_t {
    #####:  637:                static std::vector<std::string> names = { "PEG", "BNF" };
    #####:  638:                for (const auto& name: names) {
    #####:  639:                    if (name.size() <= n && !name.compare(0, name.size(), s, name.size())) {
    #####:  640:                        return name.size();
        -:  641:                    }
        -:  642:                }
    #####:  643:                return static_cast<size_t>(-1);
        -:  644:            })
        -:  645:        },
        -:  646:        {
    #####:  647:            "~_", zom(cls(" \t\r\n"))
        -:  648:        }
    #####:  649:    });
        -:  650:
    #####:  651:    REQUIRE(g.parse(" Hello BNF! ") == true);
    #####:  652:}
        -:  653:
        1:  654:TEST_CASE("Semantic predicate test", "[predicate]")
        -:  655:{
    #####:  656:    parser parser("NUMBER  <-  [0-9]+");
        -:  657:
    #####:  658:    parser["NUMBER"] = [](const SemanticValues& sv) {
    #####:  659:        auto val = stol(sv.token(), nullptr, 10);
    #####:  660:        if (val != 100) {
    #####:  661:            throw parse_error("value error!!");
        -:  662:        }
    #####:  663:        return val;
        -:  664:    };
        -:  665:
        -:  666:    long val;
    #####:  667:    REQUIRE(parser.parse("100", val));
    #####:  668:    REQUIRE(val == 100);
        -:  669:
    #####:  670:    parser.log = [](size_t line, size_t col, const std::string& msg) {
    #####:  671:        REQUIRE(line == 1);
    #####:  672:        REQUIRE(col == 1);
    #####:  673:        REQUIRE(msg == "value error!!");
    #####:  674:    };
    #####:  675:    REQUIRE(!parser.parse("200", val));
    #####:  676:}
        -:  677:
        1:  678:TEST_CASE("Japanese character", "[unicode]")
        -:  679:{
        -:  680:    peg::parser parser(u8R"(
        -:  681:        文 <- 修飾語? 主語 述語 '。'
        -:  682:        主語 <- 名詞 助詞
        -:  683:        述語 <- 動詞 助詞
        -:  684:        修飾語 <- 形容詞
        -:  685:        名詞 <- 'サーバー' / 'クライアント'
        -:  686:        形容詞 <- '古い' / '新しい'
        -:  687:        動詞 <- '落ち' / '復旧し'
        -:  688:        助詞 <- 'が' / 'を' / 'た' / 'ます' / 'に'
    #####:  689:    )");
        -:  690:
    #####:  691:    bool ret = parser;
    #####:  692:    REQUIRE(ret == true);
        -:  693:
    #####:  694:    REQUIRE(parser.parse(u8R"(サーバーを復旧します。)"));
    #####:  695:}
        -:  696:
        1:  697:TEST_CASE("dot with a code", "[unicode]")
        -:  698:{
    #####:  699:    peg::parser parser(" S <- 'a' . 'b' ");
    #####:  700:    REQUIRE(parser.parse(u8R"(aあb)"));
    #####:  701:}
        -:  702:
        1:  703:TEST_CASE("dot with a char", "[unicode]")
        -:  704:{
    #####:  705:    peg::parser parser(" S <- 'a' . 'b' ");
    #####:  706:    REQUIRE(parser.parse(u8R"(aåb)"));
    #####:  707:}
        -:  708:
        1:  709:TEST_CASE("character class", "[unicode]")
        -:  710:{
        -:  711:    peg::parser parser(R"(
        -:  712:        S <- 'a' [い-おAさC-Eた-とは] 'b'
    #####:  713:    )");
        -:  714:
    #####:  715:    bool ret = parser;
    #####:  716:    REQUIRE(ret == true);
        -:  717:
    #####:  718:    REQUIRE(!parser.parse(u8R"(aあb)"));
    #####:  719:    REQUIRE(parser.parse(u8R"(aいb)"));
    #####:  720:    REQUIRE(parser.parse(u8R"(aうb)"));
    #####:  721:    REQUIRE(parser.parse(u8R"(aおb)"));
    #####:  722:    REQUIRE(!parser.parse(u8R"(aかb)"));
    #####:  723:    REQUIRE(parser.parse(u8R"(aAb)"));
    #####:  724:    REQUIRE(!parser.parse(u8R"(aBb)"));
    #####:  725:    REQUIRE(parser.parse(u8R"(aEb)"));
    #####:  726:    REQUIRE(!parser.parse(u8R"(aFb)"));
    #####:  727:    REQUIRE(!parser.parse(u8R"(aそb)"));
    #####:  728:    REQUIRE(parser.parse(u8R"(aたb)"));
    #####:  729:    REQUIRE(parser.parse(u8R"(aちb)"));
    #####:  730:    REQUIRE(parser.parse(u8R"(aとb)"));
    #####:  731:    REQUIRE(!parser.parse(u8R"(aなb)"));
    #####:  732:    REQUIRE(parser.parse(u8R"(aはb)"));
    #####:  733:    REQUIRE(!parser.parse(u8R"(a?b)"));
    #####:  734:}
        -:  735:
        -:  736:#if 0 // TODO: Unicode Grapheme support
        -:  737:TEST_CASE("dot with a grapheme", "[unicode]")
        -:  738:{
        -:  739:    peg::parser parser(" S <- 'a' . 'b' ");
        -:  740:    REQUIRE(parser.parse(u8R"(aसिb)"));
        -:  741:}
        -:  742:#endif
        -:  743:
        1:  744:TEST_CASE("Macro simple test", "[macro]")
        -:  745:{
        -:  746:    parser parser(R"(
        -:  747:		S     <- HELLO WORLD
        -:  748:		HELLO <- T('hello')
        -:  749:		WORLD <- T('world')
        -:  750:		T(a)  <- a [ \t]*
    #####:  751:	)");
        -:  752:
    #####:  753:    REQUIRE(parser.parse("hello \tworld "));
    #####:  754:}
        -:  755:
        1:  756:TEST_CASE("Macro two parameters", "[macro]")
        -:  757:{
        -:  758:    parser parser(R"(
        -:  759:		S           <- HELLO_WORLD
        -:  760:		HELLO_WORLD <- T('hello', 'world')
        -:  761:		T(a, b)     <- a [ \t]* b [ \t]*
    #####:  762:	)");
        -:  763:
    #####:  764:    REQUIRE(parser.parse("hello \tworld "));
    #####:  765:}
        -:  766:
        1:  767:TEST_CASE("Macro syntax error", "[macro]")
        -:  768:{
        -:  769:    parser parser(R"(
        -:  770:		S     <- T('hello')
        -:  771:		T (a) <- a [ \t]*
    #####:  772:	)");
        -:  773:
    #####:  774:    bool ret = parser;
    #####:  775:    REQUIRE(ret == false);
    #####:  776:}
        -:  777:
        1:  778:TEST_CASE("Macro missing argument", "[macro]")
        -:  779:{
        -:  780:    parser parser(R"(
        -:  781:		S       <- T ('hello')
        -:  782:		T(a, b) <- a [ \t]* b
    #####:  783:	)");
        -:  784:
    #####:  785:    bool ret = parser;
    #####:  786:    REQUIRE(ret == false);
    #####:  787:}
        -:  788:
        1:  789:TEST_CASE("Macro reference syntax error", "[macro]")
        -:  790:{
        -:  791:    parser parser(R"(
        -:  792:		S    <- T ('hello')
        -:  793:		T(a) <- a [ \t]*
    #####:  794:	)");
        -:  795:
    #####:  796:    bool ret = parser;
    #####:  797:    REQUIRE(ret == false);
    #####:  798:}
        -:  799:
        1:  800:TEST_CASE("Macro invalid macro reference error", "[macro]")
        -:  801:{
        -:  802:    parser parser(R"(
        -:  803:		S <- T('hello')
        -:  804:		T <- 'world'
    #####:  805:	)");
        -:  806:
    #####:  807:    bool ret = parser;
    #####:  808:    REQUIRE(ret == false);
    #####:  809:}
        -:  810:
        1:  811:TEST_CASE("Macro calculator", "[macro]")
        -:  812:{
        -:  813:	// Create a PEG parser
        -:  814:    parser parser(R"(
        -:  815:        # Grammar for simple calculator...
        -:  816:        EXPRESSION       <-  _ LIST(TERM, TERM_OPERATOR)
        -:  817:        TERM             <-  LIST(FACTOR, FACTOR_OPERATOR)
        -:  818:        FACTOR           <-  NUMBER / T('(') EXPRESSION T(')')
        -:  819:        TERM_OPERATOR    <-  T([-+])
        -:  820:        FACTOR_OPERATOR  <-  T([/*])
        -:  821:        NUMBER           <-  T([0-9]+)
        -:  822:		~_               <-  [ \t]*
        -:  823:		LIST(I, D)       <-  I (D I)*
        -:  824:		T(S)             <-  < S > _
    #####:  825:	)");
        -:  826:
        -:  827:	// Setup actions
    #####:  828:    auto reduce = [](const SemanticValues& sv) -> long {
    #####:  829:        auto result = any_cast<long>(sv[0]);
    #####:  830:        for (auto i = 1u; i < sv.size(); i += 2) {
    #####:  831:            auto num = any_cast<long>(sv[i + 1]);
    #####:  832:            auto ope = any_cast<char>(sv[i]);
    #####:  833:            switch (ope) {
    #####:  834:                case '+': result += num; break;
    #####:  835:                case '-': result -= num; break;
    #####:  836:                case '*': result *= num; break;
    #####:  837:                case '/': result /= num; break;
        -:  838:            }
        -:  839:        }
    #####:  840:        return result;
        -:  841:    };
        -:  842:
    #####:  843:    parser["EXPRESSION"]      = reduce;
    #####:  844:    parser["TERM"]            = reduce;
    #####:  845:    parser["TERM_OPERATOR"]   = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };
    #####:  846:    parser["FACTOR_OPERATOR"] = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };
    #####:  847:    parser["NUMBER"]          = [](const SemanticValues& sv) { return atol(sv.c_str()); };
        -:  848:
    #####:  849:    bool ret = parser;
    #####:  850:    REQUIRE(ret == true);
        -:  851:
    #####:  852:	auto expr = " 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 ";
    #####:  853:    long val = 0;
    #####:  854:    ret = parser.parse(expr, val);
        -:  855:
    #####:  856:    REQUIRE(ret == true);
    #####:  857:    REQUIRE(val == -3);
    #####:  858:}
        -:  859:
        1:  860:TEST_CASE("Macro expression arguments", "[macro]")
        -:  861:{
        -:  862:    parser parser(R"(
        -:  863:		S             <- M('hello' / 'Hello', 'world' / 'World')
        -:  864:		M(arg0, arg1) <- arg0 [ \t]+ arg1
    #####:  865:	)");
        -:  866:
    #####:  867:    REQUIRE(parser.parse("Hello world"));
    #####:  868:}
        -:  869:
        1:  870:TEST_CASE("Macro recursive", "[macro]")
        -:  871:{
        -:  872:    parser parser(R"(
        -:  873:		S    <- M('abc')
        -:  874:		M(s) <- !s / s ' ' M(s / '123') / s
    #####:  875:	)");
        -:  876:
    #####:  877:    REQUIRE(parser.parse(""));
    #####:  878:    REQUIRE(parser.parse("abc"));
    #####:  879:    REQUIRE(parser.parse("abc abc"));
    #####:  880:    REQUIRE(parser.parse("abc 123 abc"));
    #####:  881:}
        -:  882:
        1:  883:TEST_CASE("Macro recursive2", "[macro]")
        -:  884:{
        -:  885:	auto syntaxes = std::vector<const char*>{
        -:  886:		"S <- M('abc') M(s) <- !s / s ' ' M(s* '-' '123') / s",
        -:  887:		"S <- M('abc') M(s) <- !s / s ' ' M(s+ '-' '123') / s",
        -:  888:		"S <- M('abc') M(s) <- !s / s ' ' M(s? '-' '123') / s",
        -:  889:		"S <- M('abc') M(s) <- !s / s ' ' M(&s s+ '-' '123') / s",
        -:  890:		"S <- M('abc') M(s) <- !s / s ' ' M(s '-' !s '123') / s",
        -:  891:		"S <- M('abc') M(s) <- !s / s ' ' M(< s > '-' '123') / s",
        -:  892:		"S <- M('abc') M(s) <- !s / s ' ' M(~s '-' '123') / s",
    #####:  893:	};
        -:  894:
    #####:  895:	for (const auto& syntax: syntaxes) {
    #####:  896:        parser parser(syntax);
    #####:  897:        REQUIRE(parser.parse("abc abc-123"));
        -:  898:	}
    #####:  899:}
        -:  900:
        1:  901:TEST_CASE("Macro exclusive modifiers", "[macro]")
        -:  902:{
        -:  903:    parser parser(R"(
        -:  904:		S                   <- Modifiers(!"") _
        -:  905:		Modifiers(Appeared) <- (!Appeared) (
        -:  906:								   Token('public') Modifiers(Appeared / 'public') /
        -:  907:								   Token('static') Modifiers(Appeared / 'static') /
        -:  908:								   Token('final') Modifiers(Appeared / 'final') /
        -:  909:								   "")
        -:  910:		Token(t)            <- t _
        -:  911:		_                   <- [ \t\r\n]*
    #####:  912:	)");
        -:  913:
    #####:  914:	REQUIRE(parser.parse("public"));
    #####:  915:	REQUIRE(parser.parse("static"));
    #####:  916:	REQUIRE(parser.parse("final"));
    #####:  917:	REQUIRE(parser.parse("public static final"));
    #####:  918:	REQUIRE(!parser.parse("public public"));
    #####:  919:	REQUIRE(!parser.parse("public static public"));
    #####:  920:}
        -:  921:
        1:  922:TEST_CASE("Macro token check test", "[macro]")
        -:  923:{
        -:  924:    parser parser(R"(
        -:  925:        # Grammar for simple calculator...
        -:  926:        EXPRESSION       <-  _ LIST(TERM, TERM_OPERATOR)
        -:  927:        TERM             <-  LIST(FACTOR, FACTOR_OPERATOR)
        -:  928:        FACTOR           <-  NUMBER / T('(') EXPRESSION T(')')
        -:  929:        TERM_OPERATOR    <-  T([-+])
        -:  930:        FACTOR_OPERATOR  <-  T([/*])
        -:  931:        NUMBER           <-  T([0-9]+)
        -:  932:		~_               <-  [ \t]*
        -:  933:		LIST(I, D)       <-  I (D I)*
        -:  934:		T(S)             <-  < S > _
    #####:  935:	)");
        -:  936:
    #####:  937:    REQUIRE(parser["EXPRESSION"].is_token() == false);
    #####:  938:    REQUIRE(parser["TERM"].is_token() == false);
    #####:  939:    REQUIRE(parser["FACTOR"].is_token() == false);
    #####:  940:    REQUIRE(parser["FACTOR_OPERATOR"].is_token() == true);
    #####:  941:    REQUIRE(parser["NUMBER"].is_token() == true);
    #####:  942:    REQUIRE(parser["_"].is_token() == true);
    #####:  943:    REQUIRE(parser["LIST"].is_token() == false);
    #####:  944:    REQUIRE(parser["T"].is_token() == true);
    #####:  945:}
        -:  946:
        1:  947:TEST_CASE("Macro passes an arg to another macro", "[macro]") {
        -:  948:  parser parser(R"(
        -:  949:        A    <- B(C)
        -:  950:        B(D) <- D
        -:  951:        C    <- 'c'
        -:  952:        D    <- 'd'
    #####:  953:	)");
        -:  954:
    #####:  955:  REQUIRE(parser.parse("c"));
    #####:  956:}
        -:  957:
        1:  958:TEST_CASE("Nested macro call", "[macro]") {
        -:  959:  parser parser(R"(
        -:  960:        A    <- B(T)
        -:  961:        B(X) <- C(X)
        -:  962:        C(Y) <- Y
        -:  963:        T    <- 'val'
    #####:  964:	)");
        -:  965:
    #####:  966:  REQUIRE(parser.parse("val"));
    #####:  967:}
        -:  968:
        1:  969:TEST_CASE("Nested macro call2", "[macro]")
        -:  970:{
        -:  971:    parser parser(R"(
        -:  972:        START           <- A('TestVal1', 'TestVal2')+
        -:  973:        A(Aarg1, Aarg2) <- B(Aarg1) '#End'
        -:  974:        B(Barg1)        <- '#' Barg1
    #####:  975:	)");
        -:  976:
    #####:  977:    REQUIRE(parser.parse("#TestVal1#End"));
    #####:  978:}
        -:  979:
        1:  980:TEST_CASE("Line information test", "[line information]") {
        -:  981:    parser parser(R"(
        -:  982:        S    <- _ (WORD _)+
        -:  983:        WORD <- [A-Za-z]+
        -:  984:        ~_   <- [ \t\r\n]+
    #####:  985:    )");
        -:  986:
    #####:  987:    std::vector<std::pair<size_t, size_t>> locations;
    #####:  988:    parser["WORD"] = [&](const peg::SemanticValues& sv) {
    #####:  989:        locations.push_back(sv.line_info());
    #####:  990:    };
        -:  991:
    #####:  992:    bool ret = parser;
    #####:  993:    REQUIRE(ret == true);
        -:  994:
    #####:  995:    ret = parser.parse(" Mon Tue Wed \nThu  Fri  Sat\nSun\n");
    #####:  996:    REQUIRE(ret == true);
        -:  997:
    #####:  998:    REQUIRE(locations[0] == std::make_pair<size_t, size_t>(1, 2));
    #####:  999:    REQUIRE(locations[1] == std::make_pair<size_t, size_t>(1, 6));
    #####: 1000:    REQUIRE(locations[2] == std::make_pair<size_t, size_t>(1, 10));
    #####: 1001:    REQUIRE(locations[3] == std::make_pair<size_t, size_t>(2, 1));
    #####: 1002:    REQUIRE(locations[4] == std::make_pair<size_t, size_t>(2, 6));
    #####: 1003:    REQUIRE(locations[5] == std::make_pair<size_t, size_t>(2, 11));
    #####: 1004:    REQUIRE(locations[6] == std::make_pair<size_t, size_t>(3, 1));
    #####: 1005:}
        -: 1006:
        1: 1007:TEST_CASE("Dictionary", "[dic]")
        -: 1008:{
        -: 1009:    parser parser(R"(
        -: 1010:        START <- 'This month is ' MONTH '.'
        -: 1011:        MONTH <- 'Jan' | 'January' | 'Feb' | 'February'
    #####: 1012:	)");
        -: 1013:
    #####: 1014:    REQUIRE(parser.parse("This month is Jan."));
    #####: 1015:    REQUIRE(parser.parse("This month is January."));
    #####: 1016:    REQUIRE_FALSE(parser.parse("This month is Jannuary."));
    #####: 1017:    REQUIRE_FALSE(parser.parse("This month is ."));
    #####: 1018:}
        -: 1019:
        1: 1020:TEST_CASE("Dictionary invalid", "[dic]")
        -: 1021:{
        -: 1022:    parser parser(R"(
        -: 1023:        START <- 'This month is ' MONTH '.'
        -: 1024:        MONTH <- 'Jan' | 'January' | [a-z]+ | 'Feb' | 'February'
    #####: 1025:	)");
        -: 1026:
    #####: 1027:    bool ret = parser;
    #####: 1028:    REQUIRE_FALSE(ret);
        3: 1029:}
        -: 1030:
        -: 1031:// vim: et ts=4 sw=4 cin cino={1s ff=unix
