        -:    0:Source:/usr/include/c++/7/typeinfo
        -:    0:Programs:4
        -:    1:// RTTI support for -*- C++ -*-
        -:    2:// Copyright (C) 1994-2017 Free Software Foundation, Inc.
        -:    3://
        -:    4:// This file is part of GCC.
        -:    5://
        -:    6:// GCC is free software; you can redistribute it and/or modify
        -:    7:// it under the terms of the GNU General Public License as published by
        -:    8:// the Free Software Foundation; either version 3, or (at your option)
        -:    9:// any later version.
        -:   10://
        -:   11:// GCC is distributed in the hope that it will be useful,
        -:   12:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:// GNU General Public License for more details.
        -:   15://
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/** @file typeinfo
        -:   26: *  This is a Standard C++ Library header.
        -:   27: */
        -:   28:
        -:   29:#ifndef _TYPEINFO
        -:   30:#define _TYPEINFO
        -:   31:
        -:   32:#pragma GCC system_header
        -:   33:
        -:   34:#include <bits/exception.h>
        -:   35:#if __cplusplus >= 201103L
        -:   36:#include <bits/hash_bytes.h>
        -:   37:#endif
        -:   38:
        -:   39:#pragma GCC visibility push(default)
        -:   40:
        -:   41:extern "C++" {
        -:   42:
        -:   43:namespace __cxxabiv1
        -:   44:{
        -:   45:  class __class_type_info;
        -:   46:} // namespace __cxxabiv1
        -:   47:
        -:   48:// Determine whether typeinfo names for the same type are merged (in which
        -:   49:// case comparison can just compare pointers) or not (in which case strings
        -:   50:// must be compared), and whether comparison is to be implemented inline or
        -:   51:// not.  We used to do inline pointer comparison by default if weak symbols
        -:   52:// are available, but even with weak symbols sometimes names are not merged
        -:   53:// when objects are loaded with RTLD_LOCAL, so now we always use strcmp by
        -:   54:// default.  For ABI compatibility, we do the strcmp inline if weak symbols
        -:   55:// are available, and out-of-line if not.  Out-of-line pointer comparison
        -:   56:// is used where the object files are to be portable to multiple systems,
        -:   57:// some of which may not be able to use pointer comparison, but the
        -:   58:// particular system for which libstdc++ is being built can use pointer
        -:   59:// comparison; in particular for most ARM EABI systems, where the ABI
        -:   60:// specifies out-of-line comparison.  The compiler's target configuration
        -:   61:// can override the defaults by defining __GXX_TYPEINFO_EQUALITY_INLINE to
        -:   62:// 1 or 0 to indicate whether or not comparison is inline, and
        -:   63:// __GXX_MERGED_TYPEINFO_NAMES to 1 or 0 to indicate whether or not pointer
        -:   64:// comparison can be used.
        -:   65:
        -:   66:#ifndef __GXX_MERGED_TYPEINFO_NAMES
        -:   67:// By default, typeinfo names are not merged.
        -:   68:#define __GXX_MERGED_TYPEINFO_NAMES 0
        -:   69:#endif
        -:   70:
        -:   71:// By default follow the old inline rules to avoid ABI changes.
        -:   72:#ifndef __GXX_TYPEINFO_EQUALITY_INLINE
        -:   73:  #if !__GXX_WEAK__
        -:   74:    #define __GXX_TYPEINFO_EQUALITY_INLINE 0
        -:   75:  #else
        -:   76:    #define __GXX_TYPEINFO_EQUALITY_INLINE 1
        -:   77:  #endif
        -:   78:#endif
        -:   79:
        -:   80:namespace std
        -:   81:{
        -:   82:  /**
        -:   83:   *  @brief  Part of RTTI.
        -:   84:   *
        -:   85:   *  The @c type_info class describes type information generated by
        -:   86:   *  an implementation.
        -:   87:  */
        -:   88:  class type_info
        -:   89:  {
        -:   90:  public:
        -:   91:    /** Destructor first. Being the first non-inline virtual function, this
        -:   92:     *  controls in which translation unit the vtable is emitted. The
        -:   93:     *  compiler makes use of that information to know where to emit
        -:   94:     *  the runtime-mandated type_info structures in the new-abi.  */
        -:   95:    virtual ~type_info();
        -:   96:
        -:   97:    /** Returns an @e implementation-defined byte string; this is not
        -:   98:     *  portable between compilers!  */
        -:   99:    const char* name() const _GLIBCXX_NOEXCEPT
        -:  100:    { return __name[0] == '*' ? __name + 1 : __name; }
        -:  101:
        -:  102:#if !__GXX_TYPEINFO_EQUALITY_INLINE
        -:  103:    // In old abi, or when weak symbols are not supported, there can
        -:  104:    // be multiple instances of a type_info object for one
        -:  105:    // type. Uniqueness must use the _name value, not object address.
        -:  106:    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT;
        -:  107:    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT;
        -:  108:#else
        -:  109:  #if !__GXX_MERGED_TYPEINFO_NAMES
        -:  110:    /** Returns true if @c *this precedes @c __arg in the implementation's
        -:  111:     *  collation order.  */
        -:  112:    // Even with the new abi, on systems that support dlopen
        -:  113:    // we can run into cases where type_info names aren't merged,
        -:  114:    // so we still need to do string comparison.
        -:  115:    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT
        -:  116:    { return (__name[0] == '*' && __arg.__name[0] == '*')
        -:  117:	? __name < __arg.__name
        -:  118:	: __builtin_strcmp (__name, __arg.__name) < 0; }
        -:  119:
      529:  120:    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT
        -:  121:    {
      529:  122:      return ((__name == __arg.__name)
      529:  123:	      || (__name[0] != '*' &&
      529:  124:		  __builtin_strcmp (__name, __arg.__name) == 0));
        -:  125:    }
        -:  126:  #else
        -:  127:    // On some targets we can rely on type_info's NTBS being unique,
        -:  128:    // and therefore address comparisons are sufficient.
        -:  129:    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT
        -:  130:    { return __name < __arg.__name; }
        -:  131:
        -:  132:    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT
        -:  133:    { return __name == __arg.__name; }
        -:  134:  #endif
        -:  135:#endif
        -:  136:    bool operator!=(const type_info& __arg) const _GLIBCXX_NOEXCEPT
        -:  137:    { return !operator==(__arg); }
        -:  138:
        -:  139:#if __cplusplus >= 201103L
        -:  140:    size_t hash_code() const noexcept
        -:  141:    {
        -:  142:#  if !__GXX_MERGED_TYPEINFO_NAMES
        -:  143:      return _Hash_bytes(name(), __builtin_strlen(name()),
        -:  144:			 static_cast<size_t>(0xc70f6907UL));
        -:  145:#  else
        -:  146:      return reinterpret_cast<size_t>(__name);
        -:  147:#  endif
        -:  148:    }
        -:  149:#endif // C++11
        -:  150:
        -:  151:    // Return true if this is a pointer type of some kind
        -:  152:    virtual bool __is_pointer_p() const;
        -:  153:
        -:  154:    // Return true if this is a function type
        -:  155:    virtual bool __is_function_p() const;
        -:  156:
        -:  157:    // Try and catch a thrown type. Store an adjusted pointer to the
        -:  158:    // caught type in THR_OBJ. If THR_TYPE is not a pointer type, then
        -:  159:    // THR_OBJ points to the thrown object. If THR_TYPE is a pointer
        -:  160:    // type, then THR_OBJ is the pointer itself. OUTER indicates the
        -:  161:    // number of outer pointers, and whether they were const
        -:  162:    // qualified.
        -:  163:    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
        -:  164:			    unsigned __outer) const;
        -:  165:
        -:  166:    // Internally used during catch matching
        -:  167:    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        -:  168:			     void **__obj_ptr) const;
        -:  169:
        -:  170:  protected:
        -:  171:    const char *__name;
        -:  172:
        -:  173:    explicit type_info(const char *__n): __name(__n) { }
        -:  174:
        -:  175:  private:
        -:  176:    /// Assigning type_info is not supported.
        -:  177:    type_info& operator=(const type_info&);
        -:  178:    type_info(const type_info&);
        -:  179:  };
        -:  180:
        -:  181:  /**
        -:  182:   *  @brief  Thrown during incorrect typecasting.
        -:  183:   *  @ingroup exceptions
        -:  184:   *
        -:  185:   *  If you attempt an invalid @c dynamic_cast expression, an instance of
        -:  186:   *  this class (or something derived from this class) is thrown.  */
        -:  187:  class bad_cast : public exception
        -:  188:  {
        -:  189:  public:
    #####:  190:    bad_cast() _GLIBCXX_USE_NOEXCEPT { }
        -:  191:
        -:  192:    // This declaration is not useless:
        -:  193:    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
        -:  194:    virtual ~bad_cast() _GLIBCXX_USE_NOEXCEPT;
        -:  195:
        -:  196:    // See comment in eh_exception.cc.
        -:  197:    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
        -:  198:  };
        -:  199:
        -:  200:  /**
        -:  201:   *  @brief Thrown when a NULL pointer in a @c typeid expression is used.
        -:  202:   *  @ingroup exceptions
        -:  203:   */
        -:  204:  class bad_typeid : public exception
        -:  205:  {
        -:  206:  public:
        -:  207:    bad_typeid () _GLIBCXX_USE_NOEXCEPT { }
        -:  208:
        -:  209:    // This declaration is not useless:
        -:  210:    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
        -:  211:    virtual ~bad_typeid() _GLIBCXX_USE_NOEXCEPT;
        -:  212:
        -:  213:    // See comment in eh_exception.cc.
        -:  214:    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
        -:  215:  };
        -:  216:} // namespace std
        -:  217:
        -:  218:} // extern "C++"
        -:  219:
        -:  220:#pragma GCC visibility pop
        -:  221:
        -:  222:#endif
