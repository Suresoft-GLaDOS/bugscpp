        -:    0:Source:/home/workspace/src/tools/dump_database.c
        -:    1:/**
        -:    2: * dump_database.c
        -:    3: *
        -:    4: * Copyright (c) 2014
        -:    5: *      libchewing Core Team. See ChangeLog for details.
        -:    6: *
        -:    7: * See the file "COPYING" for information on usage and redistribution
        -:    8: * of this file.
        -:    9: */
        -:   10:
        -:   11:/**
        -:   12: * @file dump_database.c
        -:   13: *
        -:   14: * @brief Dump system dictionary and phone phrase tree in a readable way.\n
        -:   15: *
        -:   16: *      This program reads in binary files of phone phrase tree\n
        -:   17: * and dictionary generated by init_database.
        -:   18: *      Output a human readable tree structure to stdout.\n
        -:   19: */
        -:   20:
        -:   21:#include <assert.h>
        -:   22:#include <stdio.h>
        -:   23:#include <stdlib.h>
        -:   24:
        -:   25:#ifdef HAVE_CONFIG_H
        -:   26:#    include <config.h>
        -:   27:#endif
        -:   28:
        -:   29:#include "chewing-private.h"
        -:   30:#include "global-private.h"
        -:   31:#include "key2pho-private.h"
        -:   32:#include "memory-private.h"
        -:   33:
        -:   34:#include "plat_types.h"
        -:   35:#include "private.h"
        -:   36:
        -:   37:const char *dict = NULL;
        -:   38:const TreeType *root = NULL;
        -:   39:const char USAGE[] =
        -:   40:    "Usage: %s <data_directory>\n"
        -:   41:    "This program dumps the entire index structure to stdout.\n";
        -:   42:
        -:   43:/*
        -:   44: * node_pos: Index of the starting node. 0 represents the root.
        -:   45: * indent: Degree of indentation.
        -:   46: */
    #####:   47:void dump(uint32_t node_pos, uint32_t indent)
        -:   48:{
    #####:   49:    uint16_t key = 0;
        -:   50:    uint32_t i;
        -:   51:
    #####:   52:    for (i = 0; i < indent; i++)
    #####:   53:        fputs("    ", stdout);
        -:   54:
    #####:   55:    key = GetUint16(root[node_pos].key);
    #####:   56:    if (key != 0) {
    #####:   57:        uint32_t beg = GetUint24(root[node_pos].child.begin);
    #####:   58:        uint32_t end = GetUint24(root[node_pos].child.end);
    #####:   59:        assert (beg < end);
        -:   60:
    #####:   61:        if (indent == 0)
    #####:   62:            printf("count=%u,", key);
        -:   63:        else {
        -:   64:            char buf[MAX_UTF8_SIZE * BOPOMOFO_SIZE + 1];
        -:   65:
    #####:   66:            PhoneFromUint(buf, sizeof(buf), key);
    #####:   67:            printf("key=%s,", buf);
        -:   68:        }
    #####:   69:        printf(" begin=%u, end=%u\n", beg, end);
        -:   70:
    #####:   71:        for (i = beg; i < end; i++)
    #####:   72:            dump(i, indent + 1);
        -:   73:    } else {
    #####:   74:        uint32_t pos = GetUint24(root[node_pos].phrase.pos);
    #####:   75:        uint32_t freq = GetUint24(root[node_pos].phrase.freq);
        -:   76:
    #####:   77:        printf("phrase=%s, freq=%u\n", &dict[pos], freq);
        -:   78:    }
    #####:   79:}
        -:   80:
    #####:   81:void *read_input(const char *dir_name, const char *base_name, plat_mmap *mmap)
        -:   82:{
        -:   83:    char filename[PATH_MAX];
        -:   84:    size_t len;
        -:   85:    size_t offset;
        -:   86:    size_t file_size;
        -:   87:    size_t csize;
    #####:   88:    void *buf = NULL;
        -:   89:
    #####:   90:    assert(dir_name);
    #####:   91:    assert(base_name);
        -:   92:
    #####:   93:    len = snprintf(filename, sizeof(filename), "%s" PLAT_SEPARATOR "%s", dir_name, base_name);
    #####:   94:    if (len + 1 > sizeof(filename)) {
    #####:   95:        fprintf(stderr, "Too long path %s" PLAT_SEPARATOR "%s\n", dir_name, base_name);
    #####:   96:        exit(-1);
        -:   97:    }
        -:   98:
    #####:   99:    file_size = plat_mmap_create(mmap, filename, FLAG_ATTRIBUTE_READ);
    #####:  100:    if (file_size <= 0) {
    #####:  101:        fprintf(stderr, "Error opening the file %s\n", filename);
    #####:  102:        exit(-1);
        -:  103:    }
        -:  104:
    #####:  105:    offset = 0;
    #####:  106:    csize = file_size;
    #####:  107:    buf = plat_mmap_set_view(mmap, &offset, &csize);
    #####:  108:    if (!buf) {
    #####:  109:        fprintf(stderr, "Error reading the file %s\n", filename);
    #####:  110:        exit(-1);
        -:  111:    }
        -:  112:
    #####:  113:    return buf;
        -:  114:}
        -:  115:
    #####:  116:int main(int argc, char *argv[])
        -:  117:{
        -:  118:    plat_mmap dict_mmap;
        -:  119:    plat_mmap tree_mmap;
        -:  120:
    #####:  121:    if (argc != 2) {
    #####:  122:        printf(USAGE, argv[0]);
    #####:  123:        return -1;
        -:  124:    }
        -:  125:
        -:  126:
    #####:  127:    dict = (const char *) read_input(argv[1], DICT_FILE, &dict_mmap);
    #####:  128:    root = (const TreeType *) read_input(argv[1], PHONE_TREE_FILE, &tree_mmap);
        -:  129:
    #####:  130:    dump(0, 0);
        -:  131:
    #####:  132:    plat_mmap_close(&dict_mmap);
    #####:  133:    plat_mmap_close(&tree_mmap);
        -:  134:
    #####:  135:    return 0;
        -:  136:}
